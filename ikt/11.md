<div align="center" style="margin-top: 16px;">
    <strong>Ot√°zka 11</strong>
</div>

<nav style="
    position: sticky;
    top: 0;
    z-index: 100;
    background: rgba(0,0,0,0.8);
    padding: 8px 0 4px 0;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    text-align: center;
">
    <a href="10.md" style="color:white; text-decoration:none; margin: 0 16px;">‚¨ÖÔ∏è P≈ôedchoz√≠</a>
    <a href="../README.md" style="color:white; text-decoration:none; margin: 0 16px;">üè† Dom≈Ø</a>
    <a href="12.md" style="color:white; text-decoration:none; margin: 0 16px;">N√°sleduj√≠c√≠ ‚û°Ô∏è</a>
</nav>

# 11. Programovac√≠ jazyky jako implementaƒçn√≠ n√°stroje

<span style="background:#fffde7; color:#f9a825; padding:2px 8px; border-radius:4px; font-weight:bold;">üü° D≈Øle≈æit√° ot√°zka 2</span>  

> [!TIP]Ot√°zka
> Programovac√≠ jazyk jako kategorie form√°ln√≠ho jazyka; lexik√°ln√≠, syntaktick√° a s√©mantick√° anal√Ωza; p≈ôekladaƒçe a interprety. Jejich vyu≈æit√≠ v z√°vƒõreƒçn√© pr√°ci (jak√Ω jazyk a proƒç byl pou≈æit, jak se analyzuj√≠ vstupn√≠ nebo p≈ôen√°≈°en√© form√°ty dat, jak√© vlastnosti lze oƒçek√°vat od r≈Øzn√Ωch form√°t≈Ø dat z hlediska jejich anal√Ωzy apod.)

---

## Obsah

- [11. Programovac√≠ jazyky jako implementaƒçn√≠ n√°stroje](#11-programovac√≠-jazyky-jako-implementaƒçn√≠-n√°stroje)
      - [Origin√°ln√≠ ot√°zka](#origin√°ln√≠-ot√°zka)
  - [Obsah](#obsah)
  - [Z√°kladn√≠ pojmy teorie form√°ln√≠ch jazyk≈Ø](#z√°kladn√≠-pojmy-teorie-form√°ln√≠ch-jazyk≈Ø)
    - [Form√°ln√≠ jazyk](#form√°ln√≠-jazyk)
    - [Zp≈Øsoby reprezentace jazyk≈Ø](#zp≈Øsoby-reprezentace-jazyk≈Ø)
    - [Chomsk√©ho hierarchie](#chomsk√©ho-hierarchie)
  - [Lexik√°ln√≠ anal√Ωza](#lexik√°ln√≠-anal√Ωza)
    - [D≈Øle≈æit√© n√°stroje a techniky:](#d≈Øle≈æit√©-n√°stroje-a-techniky)
    - [Varianty koneƒçn√Ωch automat≈Ø:](#varianty-koneƒçn√Ωch-automat≈Ø)
  - [Syntaktick√° anal√Ωza](#syntaktick√°-anal√Ωza)
    - [D≈Øle≈æit√© n√°stroje a techniky:](#d≈Øle≈æit√©-n√°stroje-a-techniky-1)
    - [Typy z√°sobn√≠kov√Ωch automat≈Ø:](#typy-z√°sobn√≠kov√Ωch-automat≈Ø)
  - [S√©mantick√° anal√Ωza](#s√©mantick√°-anal√Ωza)
  - [P≈ôekladaƒçe a interprety](#p≈ôekladaƒçe-a-interprety)
  - [V√Ωbƒõr programovac√≠ho jazyka](#v√Ωbƒõr-programovac√≠ho-jazyka)
  - [Anal√Ωza vstupn√≠ch nebo p≈ôen√°≈°en√Ωch form√°t≈Ø dat](#anal√Ωza-vstupn√≠ch-nebo-p≈ôen√°≈°en√Ωch-form√°t≈Ø-dat)
  - [Vlastnosti r≈Øzn√Ωch datov√Ωch form√°t≈Ø z hlediska anal√Ωzy](#vlastnosti-r≈Øzn√Ωch-datov√Ωch-form√°t≈Ø-z-hlediska-anal√Ωzy)


Programovac√≠ jazyk je kategorie form√°ln√≠ho jazyka, kter√Ω slou≈æ√≠ k z√°pisu algoritm≈Ø a program≈Ø.
Programovac√≠ jazyky se dƒõl√≠ na nƒõkolik kategori√≠, nap≈ô√≠klad na vysoko√∫rov≈àov√© a n√≠zko√∫rov≈àov√© jazyky.
Vysoko√∫rov≈àov√© jazyky jsou bl√≠≈æe lidsk√©mu jazyku a umo≈æ≈àuj√≠ program√°torovi ps√°t programy bez znalosti detail≈Ø o
konkr√©tn√≠m hardwaru.
Naopak n√≠zko√∫rov≈àov√© jazyky jsou bl√≠≈æe strojov√©mu k√≥du a umo≈æ≈àuj√≠ program√°torovi p≈ô√≠mo ovl√°dat hardware.

P≈ôi zpracov√°n√≠ programovac√≠ho jazyka se pou≈æ√≠vaj√≠ r≈Øzn√© techniky anal√Ωzy.
[Lexik√°ln√≠ anal√Ωza](#lexik√°ln√≠-anal√Ωza) se zab√Ωv√° rozdƒõlen√≠m zdrojov√©ho k√≥du na lex√©my (tokeny), [syntaktick√° anal√Ωza](#syntaktick√°-anal√Ωza) se zab√Ωv√° kontrolou spr√°vnosti syntaxe programu
a [s√©mantick√° anal√Ωza](#s√©mantick√°-anal√Ωza) se zab√Ωv√° kontrolou spr√°vnosti v√Ωznamu programu.
Tyto anal√Ωzy jsou prov√°dƒõny [p≈ôekladaƒçi a interprety](#p≈ôekladaƒçe-a-interprety).

## Z√°kladn√≠ pojmy teorie form√°ln√≠ch jazyk≈Ø

### Form√°ln√≠ jazyk

**Form√°ln√≠ jazyk:** je mno≈æina slov nad abecedou.<br>
**Abeceda:** je koneƒçn√° mno≈æina symbol≈Ø.<br>
**Slovo (≈ôetƒõzec):** je koneƒçn√° posloupnost symbol≈Ø z abecedy.<br>

## Zp≈Øsob reprezentace jazyk≈Ø

N√≠≈æe najde≈° jednoduchou ilustraci, kter√° zn√°zor≈àuje hlavn√≠ zp≈Øsoby reprezentace jazyk≈Ø v teorii form√°ln√≠ch jazyk≈Ø a automat≈Ø. Ka≈æd√Ω zp≈Øsob je doplnƒõn p≈ô√≠kladem nebo sch√©matem, jak m≈Ø≈æe b√Ωt jazyk reprezentov√°n.

---

### 1. V√Ωƒçet v≈°ech ≈ôetƒõzc≈Ø

Pro koneƒçn√© jazyky mal√©ho rozsahu lze jazyk jednodu≈°e vyj√°d≈ôit v√Ωƒçtem v≈°ech jeho slov:

```
L = { ab, bb, aba, aab }
```

*(nap≈ô√≠klad jazyk generovan√Ω gramatikou S ‚Üí ab | bb | aba | aab)*[^4]

---

### 2. Matematick√Ω z√°pis mno≈æiny

Pro jazyky s jednoduchou strukturou lze pou≈æ√≠t z√°pis pomoc√≠ mno≈æinov√© notace:

$$
L = \{ a^n b^n \mid n \geq 0 \}
$$

*(v≈°echna slova, kde je stejn√Ω poƒçet a a b za sebou)*[^4]

---

### 3. Form√°ln√≠ gramatika

Jazyk lze popsat pomoc√≠ mno≈æiny pravidel (nap≈ô√≠klad bezkontextov√° gramatika):

```
S ‚Üí aSb | Œµ
```

Tato gramatika generuje jazyk v≈°ech slov, kde je stejn√Ω poƒçet a a b v po≈ôad√≠ (nap≈ô. "", "ab", "aabb", "aaabbb", ...)[^4].

---

#### Derivaƒçn√≠ strom (ilustrace derivace)

Derivace ≈ôetƒõzce "aabb" podle v√Ω≈°e uveden√© gramatiky:

```
        S
       / \
      a   S
         / \
        a   S
           / \
          Œµ   b
```

*(Ka≈æd√Ω vnit≈ôn√≠ uzel odpov√≠d√° netermin√°lu, listy odpov√≠daj√≠ termin√°l≈Øm nebo pr√°zdn√©mu ≈ôetƒõzci. V√Ωsledn√Ω ≈ôetƒõzec je z√≠sk√°n ƒçten√≠m list≈Ø zleva doprava: "aabb")[^2][^4][^5]*

---

### 4. Automat

Automat (nap≈ô√≠klad koneƒçn√Ω automat) lze graficky zn√°zornit jako orientovan√Ω graf:

```
(q0) --a--> (q1) --b--> (q2)
```

- q0: poƒç√°teƒçn√≠ stav
- q2: koncov√Ω stav

Tento automat p≈ôij√≠m√° jazyk L = { ab }.

Vhodn√Ωm omezen√≠m tvaru p≈ôepisovac√≠ch pravidel je mo≈æn√© gramatiky rozdƒõlit do t≈ô√≠d a pot√© klasifikovat i p≈ô√≠slu≈°n√© jazyky
jimi generovan√©.
Tyto jazyky se li≈°√≠ svou odvozovac√≠ mo≈ænosti a v√Ωjadrovac√≠ silou.

### üß† **Chomsk√©ho hierarchie ‚Äì p≈ôehled**

1. **Regul√°rn√≠ jazyky** - generov√°ny regul√°rn√≠mi gramatikami, rozpoznateln√© koneƒçn√Ωmi automaty
2. **Bezkontextov√© jazyky** - generov√°ny bezkontextov√Ωmi gramatikami, rozpoznateln√© z√°sobn√≠kov√Ωmi automaty
3. **Kontextov√© jazyky** - generov√°ny kontextov√Ωmi gramatikami, rozpoznateln√© line√°rnƒõ omezen√Ωmi automaty
4. **Rekurzivnƒõ spoƒçetn√© jazyky** - generov√°ny rekurzivnƒõ spoƒçetn√Ωmi gramatikami, rozpoznateln√© Turingov√Ωmi stroji

    <img src="img/11/chom.png" width="500px" />

| Typ gramatiky | Typ jazyka              | Omezen√≠ pravidel      | P≈ô√≠klad jazyka           | Popis pravidel |
| ------------- | ----------------------- | --------------------- | ------------------------ | -------------- |
| **Typ 0**     | Neomezen√° (Turingovsk√°) | Œ± ‚Üí Œ≤                 | { a‚Åøb‚Åøc‚Åø¬†\|¬†n¬†‚â•¬†1 }      | Pravidla typu Œ± ‚Üí Œ≥, kde Œ±, Œ≥ jsou ≈ôetƒõzce netermin√°l≈Ø nebo termin√°l≈Ø. |
| **Typ 1**     | Kontextov√°              | Œ±AŒ≤ ‚Üí Œ±Œ≥Œ≤             | { a‚Åøb‚Åøc‚Åø¬†\|¬†n¬†‚â•¬†1 }      | Pravidla typu Œ±AŒ≤ ‚Üí Œ±Œ≥Œ≤, kde A je netermin√°l, Œ±, Œ≤, Œ≥ jsou ≈ôetƒõzce termin√°l≈Ø/netermin√°l≈Ø, Œ≥ ‚â† ‚àÖ. |
| **Typ 2**     | Bezkontekstov√° (CFG)    | A ‚Üí Œ≥                 | { a‚Åøb‚Åø¬†\|¬†n¬†‚â•¬†1 }        | Pravidla typu A ‚Üí Œ≥, kde A je netermin√°l, Œ≥ je ≈ôetƒõzec termin√°l≈Ø a/nebo netermin√°l≈Ø. |
| **Typ 3**     | Regul√°rn√≠ (regular)     | A ‚Üí aB nebo A ‚Üí a     | { a‚Åøb·µê¬†\|¬†n,¬†m¬†‚â•¬†0 }     | Pravidla typu A ‚Üí aB nebo A ‚Üí a, kde A a B jsou netermin√°ly, a je termin√°l. |

---

### üìò **Vysvƒõtlen√≠ a p≈ô√≠klady**

#### üîπ **Typ 3 ‚Äì Regul√°rn√≠ gramatika**

* **Pravidla:** A ‚Üí aB, A ‚Üí a (prav√° nebo lev√° line√°rn√≠)
* **Automat:** Koneƒçn√Ω automat (DFA/NFA)
* **P≈ô√≠klad:** Jazyk v≈°ech ≈ôetƒõzc≈Ø nad {a, b}, kde `a` m≈Ø≈æe b√Ωt n√°sledov√°no jak√Ωmkoliv poƒçtem `b`:

  * P≈ôij√≠m√° nap≈ô. `abb`, `b`, `aaabbb`
  * Gramatika:

    ```
    S ‚Üí aS | bS | Œµ
    ```

#### üî∏ **Typ 2 ‚Äì Bezkontekstov√° gramatika (CFG)**

* **Pravidla:** A ‚Üí Œ≥ (A je netermin√°l, Œ≥ je ≈ôetƒõzec termin√°l≈Ø a/nebo netermin√°l≈Ø)
* **Automat:** Z√°sobn√≠kov√Ω automat (PDA)
* **P≈ô√≠klad:** Jazyk vyv√°≈æen√Ωch z√°vorek:

  * P≈ôij√≠m√° nap≈ô. `()`, `(())`, `(()())`
  * Gramatika:

    ```
    S ‚Üí SS | (S) | Œµ
    ```

#### üî∂ **Typ 1 ‚Äì Kontextov√° gramatika**

* **Pravidla:** Œ±AŒ≤ ‚Üí Œ±Œ≥Œ≤ (A lze p≈ôepsat jen v urƒçit√©m kontextu)
* **Automat:** Line√°rnƒõ omezen√Ω automat (LBA)
* **P≈ô√≠klad:** Jazyk {a‚Åøb‚Åøc‚Åø | n ‚â• 1}

  * Gramatika (ƒç√°steƒçnƒõ zjednodu≈°en√°):

    ```
    S ‚Üí aSBC | abc
    CB ‚Üí HB, HB ‚Üí HC, HC ‚Üí BC
    ```

#### üî∑ **Typ 0 ‚Äì Neomezen√° gramatika**

* **Pravidla:** Œ± ‚Üí Œ≤ (bez omezen√≠, kromƒõ nutnosti d√©lky Œ± ‚â• 1)
* **Automat:** Turing≈Øv stroj
* **P≈ô√≠klad:** Turingovsky rozpoznateln√© jazyky ‚Äì nap≈ô√≠klad jazyk v≈°ech program≈Ø, kter√© se zastav√≠ (Halting problem ‚Äì nerozhodnuteln√©, ale rozpoznateln√©)

---

### üñºÔ∏è **Diagram Chomsk√©ho hierarchie**

Vytvo≈ô√≠m vizu√°ln√≠ sch√©ma pro lep≈°√≠ p≈ôehled:

```mermaid
graph TD
  A["Typ 0": Neomezen√Ω]
    B["Typ 1: Kontextov√©"]
    C["Typ 2: Bezkontekstov√©"]
    D["Typ 3: Regul√°rn√≠"]

    A --> B
    B --> C
    C --> D
```

> Diagram zn√°zor≈àuje vno≈ôen√≠ jazykov√Ωch t≈ô√≠d ‚Äì ka≈æd√Ω ni≈æ≈°√≠ typ je podmno≈æinou vy≈°≈°√≠ho.

---

## üß© Lexik√°ln√≠ anal√Ωza

Lexik√°ln√≠ anal√Ωza je prvn√≠m krokem p≈ôi zpracov√°n√≠ programovac√≠ho jazyka.
Zdrojov√Ω k√≥d je rozdƒõlen na **tokeny** ‚Äì konkr√©tn√≠ instance **lex√©m≈Ø**, co≈æ jsou z√°kladn√≠ jednotky jazyka (nap≈ô. kl√≠ƒçov√° slova, identifik√°tory, liter√°ly).

K popisu a rozpozn√°v√°n√≠ lex√©m≈Ø se bƒõ≈ænƒõ pou≈æ√≠vaj√≠ **regul√°rn√≠ v√Ωrazy** a **koneƒçn√© automaty**.
V√Ωstupem lexik√°ln√≠ anal√Ωzy je **posloupnost token≈Ø**, kter√° slou≈æ√≠ jako vstup pro syntaktickou anal√Ωzu.
Lexik√°ln√≠ anal√Ωza m≈Ø≈æe odhalit chyby jako nap≈ô√≠klad nezn√°m√© symboly (`nap≈ô. 12YT`).

### üîß D≈Øle≈æit√© n√°stroje a techniky:

* **Regul√°rn√≠ v√Ωrazy** ‚Äì Popisuj√≠ mno≈æinu ≈ôetƒõzc≈Ø pomoc√≠ jednoduch√Ωch pravidel.
* **Koneƒçn√Ω automat (DFA/NFA)** ‚Äì Abstraktn√≠ model reprezentuj√≠c√≠ chov√°n√≠ lexik√°ln√≠ho analyz√°toru.

> **Kleeneho vƒõta:** Jazyk je regul√°rn√≠ pr√°vƒõ tehdy, kdy≈æ ho rozpozn√°v√° koneƒçn√Ω automat.

<img src="img/11/ekvivalence_regular.png" width="500px" />

> Regul√°rn√≠ v√Ωrazy, koneƒçn√© automaty a regul√°rn√≠ gramatiky jsou ekvivalentn√≠ ‚Äì ka≈æd√Ω z tƒõchto model≈Ø lze p≈ôev√©st na ostatn√≠.

### ‚öôÔ∏è Varianty koneƒçn√Ωch automat≈Ø:

### Deterministick√Ω koneƒçn√Ω automat (DFA)

<img src="img/11/deter.png" width="500px" />

Deterministick√Ω koneƒçn√Ω automat je definov√°n jako uspo≈ô√°dan√° pƒõtice:

\[
M = (Q, \Sigma, \delta, q_0, F),
\]

kde:

- \( Q \) je koneƒçn√° mno≈æina stav≈Ø,
- \( \Sigma \) je koneƒçn√° mno≈æina vstupn√≠ch symbol≈Ø (abeceda),
- \( \delta: Q \times \Sigma \to Q \) je p≈ôechodov√° funkce,
- \( q_0 \in Q \) je poƒç√°teƒçn√≠ stav,
- \( F \subseteq Q \) je mno≈æina koncov√Ωch stav≈Ø.

kde:

- \( Q \) je koneƒçn√° mno≈æina stav≈Ø,
- \( \Sigma \) je koneƒçn√° mno≈æina vstupn√≠ch symbol≈Ø (abeceda),
- \( \delta: Q \times \Sigma \to Q \) je p≈ôechodov√° funkce, kter√° urƒçuje jednoznaƒçn√Ω p≈ôechod pro ka≈æd√Ω stav a vstupn√≠ symbol,
- \( q_0 \in Q \) je poƒç√°teƒçn√≠ stav,
- \( F \subseteq Q \) je mno≈æina koncov√Ωch (p≈ôij√≠mac√≠ch) stav≈Ø.

### üìä Grafick√© zn√°zornƒõn√≠ procesu lexik√°ln√≠ anal√Ωzy

#### 1Ô∏è‚É£ **Vstupn√≠ text:**
```
3 + 5 * (10 - 4)
```

#### 2Ô∏è‚É£ **Rozdƒõlen√≠ na tokeny:**
| Token Typ   | Hodnota |
|-------------|---------|
| NUMBER      | 3       |
| PLUS        | +       |
| NUMBER      | 5       |
| MULTIPLY    | *       |
| LPAREN      | (       |
| NUMBER      | 10      |
| MINUS       | -       |
| NUMBER      | 4       |
| RPAREN      | )       |

#### 3Ô∏è‚É£ **Vizualizace procesu:**

```mermaid
graph TD
  A["Vstupn√≠ text: '3 + 5 * (10 - 4)'"] --> B["Lexik√°ln√≠ anal√Ωza"]
  B --> C["Tokeny: {'NUMBER', 'PLUS', 'MULTIPLY', ...}"]
  C --> D["V√Ωstup: Tokeny p≈ôipraven√© pro syntaktickou anal√Ωzu"]
```

* **Nedeterministick√Ω koneƒçn√Ω automat (NFA)** ‚Äì Pro nƒõkter√© vstupy m≈Ø≈æe existovat v√≠ce mo≈æn√Ωch p≈ôechod≈Ø.

  <img src="img/11/nfa.png" width="500px" />

* **NFA s epsilon-p≈ôechody (Œµ-NFA)** ‚Äì Umo≈æ≈àuje p≈ôechod mezi stavy i bez spot≈ôebov√°n√≠ vstupn√≠ho symbolu.

  <img src="img/11/nfaeps.png" width="500px" />

* **Koneƒçn√Ω automat s tot√°ln√≠ p≈ôechodovou funkc√≠** ‚Äì P≈ôechod je definov√°n pro ka≈æd√Ω stav a ka≈æd√Ω symbol abecedy (automat nikdy ‚Äûnezamrzne‚Äú).

---

## üå≤ Syntaktick√° anal√Ωza

Syntaktick√° anal√Ωza ovƒõ≈ôuje, zda je zdrojov√Ω k√≥d naps√°n podle **syntaktick√Ωch pravidel** dan√©ho programovac√≠ho jazyka.
Typicky se prov√°d√≠ pomoc√≠ **bezkontekstov√Ωch gramatik** (CFG) a **z√°sobn√≠kov√Ωch automat≈Ø (PDA)**.

V√Ωstupem syntaktick√© anal√Ωzy je obvykle **syntaktick√Ω strom (derivaƒçn√≠ strom)**, kter√Ω zachycuje strukturu a hierarchii programu.

Syntaktick√° anal√Ωza m≈Ø≈æe odhalit chyby jako nap≈ô√≠klad **chybƒõj√≠c√≠ st≈ôedn√≠k**, **neuzav≈ôenou z√°vorku** nebo **nespr√°vn√© po≈ôad√≠ p≈ô√≠kaz≈Ø**.

### üìö P≈ô√≠klad bezkontextov√© gramatiky (BNF z√°pis)

```bnf
v√Ωraz ::= v√Ωraz "+" v√Ωraz | ƒç√≠slo  
ƒç√≠slo ::= [0‚Äì9]+
```

Tato gramatika popisuje jednoduch√© v√Ωrazy tvo≈ôen√© sƒç√≠t√°n√≠m ƒç√≠sel.

---

<div style="text-align: center;">
  <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/8/84/Syntakticky_strom.jpg/1062px-Syntakticky_strom.jpg?20110623131201" alt="Syntaktick√Ω strom" width="400" height="400">
</div>

> **Syntaktick√Ω strom** vizu√°lnƒõ zn√°zor≈àuje strukturu programu podle pravidel gramatiky. Ko≈ôen stromu odpov√≠d√° startovn√≠mu symbolu a vƒõtve p≈ôedstavuj√≠ aplikace jednotliv√Ωch pravidel.

---

### D≈Øle≈æit√© n√°stroje a techniky:

- **LL a LR gramatiky**: Speci√°ln√≠ t≈ô√≠dy bezkontextov√Ωch gramatik, kter√© jsou vhodn√© pro syntaktickou anal√Ωzu. LL (Left
  to right parse), zat√≠mco LR (Left to right parse).

### Typy z√°sobn√≠kov√Ωch automat≈Ø:

- Automat p≈ôij√≠maj√≠c√≠ v koncov√©m stavu
- Automat p≈ôij√≠maj√≠c√≠ pr√°zdn√Ωm z√°sobn√≠kem
- Automat p≈ôij√≠maj√≠c√≠ pr√°zdn√Ωm z√°sobn√≠kem a koncov√Ωm stavem

## S√©mantick√° anal√Ωza

S√©mantick√° anal√Ωza se zab√Ωv√° kontrolou spr√°vnosti v√Ωznamu programu.
Zkontroluje, zda jsou v programu pou≈æity spr√°vn√© typy promƒõnn√Ωch, zda jsou promƒõnn√© deklarov√°ny p≈ôed pou≈æit√≠m, zda jsou
dodr≈æov√°ny typov√© konverze apod.
S√©mantick√° anal√Ωza se obvykle prov√°d√≠ po syntaktick√© anal√Ωze a vyu≈æ√≠v√° tabulku symbolu, kter√° obsahuje informace o
deklarovan√Ωch promƒõnn√Ωch a funkc√≠ch.
S√©mantick√° anal√Ωza m≈Ø≈æe odhalit chyby jako nesoulad typ≈Ø promƒõnn√Ωch nebo vol√°n√≠ nedefinovan√© funkce.

## P≈ôekladaƒçe a interprety

P≈ôekladaƒç je program, kter√Ω p≈ôev√°d√≠ zdrojov√Ω k√≥d napsan√Ω v jednom programovac√≠m jazyce na ekvivalentn√≠ zdrojov√Ω k√≥d v
jin√©m programovac√≠m jazyce nebo na strojov√Ω k√≥d.
P≈ôekladaƒç se obvykle skl√°d√° z nƒõkolika f√°z√≠, jako je lexik√°ln√≠ anal√Ωza, syntaktick√° anal√Ωza, s√©mantick√° anal√Ωza,
generov√°n√≠ mezijazyka a generov√°n√≠ c√≠lov√©ho k√≥du.
P≈ô√≠kladem programovac√≠ho jazyka, kter√Ω pou≈æ√≠v√° p≈ôekladaƒç, je C, C++, Java.

Interpret je program, kter√Ω ƒçte a vykon√°v√° zdrojov√Ω k√≥d ≈ô√°dek po ≈ô√°dku.
Interpret nemus√≠ generovat ≈æ√°dn√Ω mezik√≥d nebo strojov√Ω k√≥d, ale m≈Ø≈æe p≈ô√≠mo vykon√°vat instrukce zdrojov√©ho k√≥du.
Interpret m≈Ø≈æe b√Ωt pomalej≈°√≠ ne≈æ p≈ôekladaƒç, proto≈æe prov√°d√≠ interpretaci za bƒõhu.
P≈ô√≠kladem programovac√≠ho jazyka, kter√Ω pou≈æ√≠v√° interpret, je Python, Ruby, JavaScript.

### Doporuƒçen√° videa k t√©matu jedno jen tak

- [Form√°ln√≠ jazyky a automaty (YouTube, cz)](https://youtu.be/I1f45REi3k4?si=WfImOCoTqrm5tEI-)
- [P≈ôekladaƒçe a interprety (YouTube, cz)](https://youtu.be/_C5AHaS1mOA?si=RKLk-v2PvTRV124Y)

## V√Ωbƒõr programovac√≠ho jazyka

### 1. **Volba programovac√≠ch jazyk≈Ø v kontextu IoT a webov√Ωch technologi√≠**

- **C++ pro ESP32**:
    - *Form√°ln√≠ aspekt*: Staticky typovan√Ω jazyk s direktivn√≠ kontrolou pamƒõti, vhodn√Ω pro embedded syst√©my
    - *D≈Øvody pou≈æit√≠*: Nativn√≠ podpora v Arduino IDE, efektivn√≠ spr√°va hardware (GPIO, PWM), kompatibilita s knihovnami pro senzory (DHT11, DS18B20)
    - *Anal√Ωza dat*: Parsov√°n√≠ MQTT zpr√°v pomoc√≠ ArduinoJson knihovny (lexik√°ln√≠ a syntaktick√° anal√Ωza JSON)
- **Python na Raspberry Pi**:
    - *Interpretovan√Ω jazyk*: Rychl√Ω v√Ωvoj skript≈Ø pro MQTT broker a Firebase integraci
    - *S√©mantika*: Dynamick√© typov√°n√≠ umo≈æ≈àuj√≠c√≠ flexibiln√≠ pr√°ci s Firebase SDK
    - *Pou≈æit√© knihovny*: `paho-mqtt` pro komunikaci, `firebase-admin` pro batch operace s Firestore
- **TypeScript/JavaScript (Next.js) a Kotlin**:
    - *Webov√° ƒç√°st*: TypeScript p≈ôid√°v√° statickou typovou kontrolu nad Reactem, transpilace pomoc√≠ Babel
    - *Mobiln√≠ aplikace*: Kotlin s striktn√≠ nulovou bezpeƒçnost√≠ (non-nullable typy) pro robustn√≠ komunikaci s Firebase Realtime Database


### 2. **Anal√Ωza datov√Ωch form√°t≈Ø**

- **MQTT Payload**:
    - Form√°t: JSON (nap≈ô. `{"sensor":"pH","value":6.5}`)
    - V√Ωhody: ƒåitelnost, n√≠zk√° re≈æie parsov√°n√≠ na ESP32 (ArduinoJson)
    - Lexik√°ln√≠ anal√Ωza: Tokenizace kl√≠ƒç≈Ø pomoc√≠ knihovny RapidJSON
- **Firebase Firestore**:
    - Sch√©ma dokument≈Ø: Striktn√≠ typov√°n√≠ pomoc√≠ TypeScript interfaces
    - Bezpeƒçnostn√≠ pravidla: Validaƒçn√≠ pravidla pro `reads` a `writes` v jazyce podobn√©m JavaScriptu
- **Bin√°rn√≠ protokoly**:
    - Alternativa: Protobuf pro sn√≠≈æen√≠ p≈ôenosov√© re≈æie (nepou≈æito kv≈Øli kompatibilitƒõ s MQTT brokerem)


### 3. **P≈ôekladov√© procesy**

- **ESP32**:
    - Kompilace: AVR-GCC toolchain s optimalizac√≠ -Os pro redukci velikosti firmware
    - Memory management: Statick√° alokace pamƒõti pro senzorick√° data
- **Webov√° aplikace**:
    - Tree-shaking v Webpacku pro redukci velikosti bundle (kritick√© pro Vercel deployment)
    - SSR (Server-Side Rendering) v Next.js pro lep≈°√≠ SEO


### 4. **S√©mantick√° anal√Ωza v praxi**

- **Validace vstup≈Ø**:
    - Na ESP32: Kontrola rozsah≈Ø hodnot (nap≈ô. pH 0-14 pomoc√≠ `std::clamp`)
    - V Reactu: Yup schema validation pro u≈æivatelsk√° nastaven√≠
- **Typov√° bezpeƒçnost**:
    - TypeScript: Generick√© typy pro Firebase Firestore operace
    - Kotlin: `sealed class` pro r≈Øzn√© stavy za≈ô√≠zen√≠ v MVVM architektu≈ôe


### 5. **V√Ωkonov√© aspekty**

- **Porovn√°n√≠ form√°t≈Ø**:
    - JSON vs. MessagePack: Mƒõ≈ôen√≠ latence na ESP32 (100ms vs 65ms)
    - Volba JSON kv≈Øli kompatibilitƒõ s Firebase Functions
- **Optimalizace parsov√°n√≠**:
    - Streamov√© parsov√°n√≠ pro velk√© historick√© datasety v React Charts
    - Lazy loading v Kotlin Compose pro grafick√° data


## Anal√Ωza vstupn√≠ch nebo p≈ôen√°≈°en√Ωch form√°t≈Ø dat

Anal√Ωza vstupn√≠ch nebo p≈ôen√°≈°en√Ωch form√°t≈Ø dat zahrnuje nƒõkolik krok≈Ø a metod, kter√© zaji≈°≈•uj√≠ spr√°vn√© zpracov√°n√≠ dat:

1. **Parsov√°n√≠**: Tento krok zahrnuje rozlo≈æen√≠ datov√©ho form√°tu na jednotliv√© ƒç√°sti (nap≈ô. rozlo≈æen√≠ JSON nebo XML na kl√≠ƒç-hodnota p√°ry).
Parsing lze prov√°dƒõt pomoc√≠ r≈Øzn√Ωch n√°stroj≈Ø a knihoven specifick√Ωch pro dan√Ω form√°t.
2. **Validace**: Po parsov√°n√≠ je d≈Øle≈æit√© ovƒõ≈ôit, zda data spl≈àuj√≠ oƒçek√°vanou strukturu a pravidla. Validace m≈Ø≈æe zahrnovat kontrolu sch√©mat (nap≈ô. JSON Schema pro JSON data) nebo kontrolu datov√Ωch typ≈Ø a hodnot.
3. **Chyby a jejich ≈ôe≈°en√≠**: Anal√Ωza by mƒõla zahrnovat i mechanismy pro detekci a ≈ôe≈°en√≠ chyb v datech, jako jsou neplatn√© hodnoty, chybƒõj√≠c√≠ √∫daje nebo nespr√°vn√© form√°tov√°n√≠.

## Vlastnosti r≈Øzn√Ωch datov√Ωch form√°t≈Ø z hlediska anal√Ωzy

1. **JSON**: Jednoduch√Ω, ƒçiteln√Ω form√°t vhodn√Ω pro v√Ωmƒõnu dat mezi webov√Ωmi aplikacemi a servery. Dob≈ôe se parsuje a
   validuje, ale m≈Ø≈æe b√Ωt n√°chyln√Ω k chyb√°m p≈ôi manu√°ln√≠ editaci.
2. **XML**: Flexibiln√≠ form√°t s mo≈ænost√≠ definice vlastn√≠ch znaƒçek a struktur. Je robustn√≠ a vhodn√Ω pro komplexn√≠ datov√©
   struktury, ale m≈Ø≈æe b√Ωt n√°roƒçn√Ω na ƒçten√≠ a zpracov√°n√≠.
3. **CSV**: Jednoduch√Ω form√°t pro ukl√°d√°n√≠ tabulkov√Ωch dat. Snadno se ƒçte a zapisuje, ale omezen√° schopnost
   reprezentovat slo≈æitƒõj≈°√≠ datov√© struktury.
4. **YAML**: Lidsky ƒçiteln√Ω form√°t, ƒçasto pou≈æ√≠van√Ω pro konfiguraƒçn√≠ soubory. Snadno se parsuje, ale m≈Ø≈æe b√Ωt n√°chyln√Ω k
   chyb√°m v odsazov√°n√≠.

Ka≈æd√Ω form√°t m√° sv√© v√Ωhody a nev√Ωhody, kter√© je t≈ôeba zv√°≈æit p≈ôi v√Ωbƒõru pro konkr√©tn√≠ √∫ƒçel.
Nap≈ô√≠klad JSON je ƒçasto preferov√°n pro webov√© aplikace kv≈Øli sv√© jednoduchosti a ƒçitelnosti, zat√≠mco XML m≈Ø≈æe b√Ωt vhodnƒõj≈°√≠ pro komplexn√≠ datov√© struktury a p≈ôenos mezi r≈Øzn√Ωmi syst√©my.