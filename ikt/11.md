<div align="center" style="margin-top: 16px;">
    <strong>Ot√°zka 11</strong>
</div>

<nav style="
    position: sticky;
    top: 0;
    z-index: 100;
    background: rgba(0,0,0,0.8);
    padding: 8px 0 4px 0;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    text-align: center;
">
    <a href="10.md" style="color:white; text-decoration:none; margin: 0 16px;">‚¨ÖÔ∏è P≈ôedchoz√≠</a>
    <a href="../README.md" style="color:white; text-decoration:none; margin: 0 16px;">üè† Dom≈Ø</a>
    <a href="12.md" style="color:white; text-decoration:none; margin: 0 16px;">N√°sleduj√≠c√≠ ‚û°Ô∏è</a>
</nav>

# 11. Programovac√≠ jazyky jako implementaƒçn√≠ n√°stroje

**Ot√°zka:** Programovac√≠ jazyk jako kategorie form√°ln√≠ho jazyka; lexik√°ln√≠, syntaktick√° a s√©mantick√° anal√Ωza; p≈ôekladaƒçe a interprety. Jejich vyu≈æit√≠ v z√°vƒõreƒçn√© pr√°ci (jak√Ω jazyk a proƒç byl pou≈æit, jak se analyzuj√≠ vstupn√≠ nebo p≈ôen√°≈°en√© form√°ty dat, jak√© vlastnosti lze oƒçek√°vat od r≈Øzn√Ωch form√°t≈Ø dat z hlediska jejich anal√Ωzy apod.)

---

#### Origin√°ln√≠ ot√°zka

Programovac√≠ jazyk jako kategorie form√°ln√≠ho jazyka; lexik√°ln√≠, syntaktick√° a s√©mantick√° anal√Ωza; p≈ôekladaƒçe a
interprety.
Jejich vyu≈æit√≠ v z√°vƒõreƒçn√© pr√°ci (jak√Ω jazyk a proƒç byl pou≈æit, jak se analyzuj√≠ vstupn√≠ nebo p≈ôen√°≈°en√© form√°ty dat,
jak√© vlastnosti lze oƒçek√°vat od r≈Øzn√Ωch form√°t≈Ø dat z hlediska jejich anal√Ωzy apod.)

## Obsah

- [11. Programovac√≠ jazyky jako implementaƒçn√≠ n√°stroje](#11-programovac√≠-jazyky-jako-implementaƒçn√≠-n√°stroje)
      - [Origin√°ln√≠ ot√°zka](#origin√°ln√≠-ot√°zka)
  - [Obsah](#obsah)
  - [Z√°kladn√≠ pojmy teorie form√°ln√≠ch jazyk≈Ø](#z√°kladn√≠-pojmy-teorie-form√°ln√≠ch-jazyk≈Ø)
    - [Form√°ln√≠ jazyk](#form√°ln√≠-jazyk)
    - [Zp≈Øsoby reprezentace jazyk≈Ø](#zp≈Øsoby-reprezentace-jazyk≈Ø)
    - [Chomsk√©ho hierarchie](#chomsk√©ho-hierarchie)
  - [Lexik√°ln√≠ anal√Ωza](#lexik√°ln√≠-anal√Ωza)
    - [D≈Øle≈æit√© n√°stroje a techniky:](#d≈Øle≈æit√©-n√°stroje-a-techniky)
    - [Varianty koneƒçn√Ωch automat≈Ø:](#varianty-koneƒçn√Ωch-automat≈Ø)
  - [Syntaktick√° anal√Ωza](#syntaktick√°-anal√Ωza)
    - [D≈Øle≈æit√© n√°stroje a techniky:](#d≈Øle≈æit√©-n√°stroje-a-techniky-1)
    - [Typy z√°sobn√≠kov√Ωch automat≈Ø:](#typy-z√°sobn√≠kov√Ωch-automat≈Ø)
  - [S√©mantick√° anal√Ωza](#s√©mantick√°-anal√Ωza)
  - [P≈ôekladaƒçe a interprety](#p≈ôekladaƒçe-a-interprety)
  - [V√Ωbƒõr programovac√≠ho jazyka](#v√Ωbƒõr-programovac√≠ho-jazyka)
  - [Anal√Ωza vstupn√≠ch nebo p≈ôen√°≈°en√Ωch form√°t≈Ø dat](#anal√Ωza-vstupn√≠ch-nebo-p≈ôen√°≈°en√Ωch-form√°t≈Ø-dat)
  - [Vlastnosti r≈Øzn√Ωch datov√Ωch form√°t≈Ø z hlediska anal√Ωzy](#vlastnosti-r≈Øzn√Ωch-datov√Ωch-form√°t≈Ø-z-hlediska-anal√Ωzy)

Programovac√≠ jazyk je kategorie form√°ln√≠ho jazyka, kter√Ω slou≈æ√≠ k z√°pisu algoritm≈Ø a program≈Ø.
Programovac√≠ jazyky se dƒõl√≠ na nƒõkolik kategori√≠, nap≈ô√≠klad na vysoko√∫rov≈àov√© a n√≠zko√∫rov≈àov√© jazyky.
Vysoko√∫rov≈àov√© jazyky jsou bl√≠≈æe lidsk√©mu jazyku a umo≈æ≈àuj√≠ program√°torovi ps√°t programy bez znalosti detail≈Ø o
konkr√©tn√≠m hardwaru.
Naopak n√≠zko√∫rov≈àov√© jazyky jsou bl√≠≈æe strojov√©mu k√≥du a umo≈æ≈àuj√≠ program√°torovi p≈ô√≠mo ovl√°dat hardware.

P≈ôi zpracov√°n√≠ programovac√≠ho jazyka se pou≈æ√≠vaj√≠ r≈Øzn√© techniky anal√Ωzy.
[Lexik√°ln√≠ anal√Ωza](#lexik√°ln√≠-anal√Ωza) se zab√Ωv√° rozdƒõlen√≠m zdrojov√©ho k√≥du na lex√©my (
tokeny), [syntaktick√° anal√Ωza](#syntaktick√°-anal√Ωza) se zab√Ωv√° kontrolou spr√°vnosti syntaxe programu
a [s√©mantick√° anal√Ωza](#s√©mantick√°-anal√Ωza) se zab√Ωv√° kontrolou spr√°vnosti v√Ωznamu programu.
Tyto anal√Ωzy jsou prov√°dƒõny [p≈ôekladaƒçi a interprety](#p≈ôekladaƒçe-a-interprety).

## Z√°kladn√≠ pojmy teorie form√°ln√≠ch jazyk≈Ø

### Form√°ln√≠ jazyk

*Form√°ln√≠ jazyk* je mno≈æina slov nad abecedou.<br>
*Abeceda* je koneƒçn√° mno≈æina symbol≈Ø.<br>
*Slovo (≈ôetƒõzec)* je koneƒçn√° posloupnost symbol≈Ø z abecedy.<br>

### Zp≈Øsoby reprezentace jazyk≈Ø

- **V√Ωƒçet v≈°ech ≈ôetƒõzc≈Ø** - pro koneƒçn√© jazyky mal√©ho rozsahu
- **Matematick√Ω z√°pis mno≈æiny** - pro jazyky s velmi jednoduchou strukturou
- **Form√°ln√≠ gramatika** - popis syntaxe jazyka pomoc√≠ mno≈æiny pravidel, kter√Ωmi lze dan√Ω jazyk generovat
    - **Derivace** - postupn√© nahrazov√°n√≠ netermin√°l≈Ø termin√°ly podle pravidel gramatiky (odvozov√°n√≠)
- **Automat** - za≈ô√≠zen√≠ (algoritmus), kter√© pro libovoln√Ω ≈ôetƒõzec rozhodne, zda pat≈ô√≠ do dan√©ho jazyka.
  Automat m≈Ø≈æe b√Ωt koneƒçn√Ω, z√°sobn√≠kov√Ω, Turing≈Øv.

Vhodn√Ωm omezen√≠m tvaru p≈ôepisovac√≠ch pravidel je mo≈æn√© gramatiky rozdƒõlit do t≈ô√≠d a pot√© klasifikovat i p≈ô√≠slu≈°n√© jazyky
jimi generovan√©.
Tyto jazyky se li≈°√≠ svou odvozovac√≠ mo≈ænosti a v√Ωjadrovac√≠ silou.

### Chomsk√©ho hierarchie

Chomsk√©ho hierarchie je klasifikace form√°ln√≠ch gramatik a jazyk≈Ø podle jejich v√Ωjadrovac√≠ s√≠ly.
Hierarchie se skl√°d√° ze ƒçty≈ô t≈ô√≠d:

1. **Regul√°rn√≠ jazyky** - generov√°ny regul√°rn√≠mi gramatikami, rozpoznateln√© koneƒçn√Ωmi automaty
2. **Bezkontextov√© jazyky** - generov√°ny bezkontextov√Ωmi gramatikami, rozpoznateln√© z√°sobn√≠kov√Ωmi automaty
3. **Kontextov√© jazyky** - generov√°ny kontextov√Ωmi gramatikami, rozpoznateln√© line√°rnƒõ omezen√Ωmi automaty
4. **Rekurzivnƒõ spoƒçetn√© jazyky** - generov√°ny rekurzivnƒõ spoƒçetn√Ωmi gramatikami, rozpoznateln√© Turingov√Ωmi stroji

![Chomsk√©ho hierarchie](https://media.geeksforgeeks.org/wp-content/cdn-uploads/20210407173848/12312.png)

## Lexik√°ln√≠ anal√Ωza

Lexik√°ln√≠ anal√Ωza je prvn√≠m krokem p≈ôi zpracov√°n√≠ programovac√≠ho jazyka.
Zdrojov√Ω k√≥d je rozdƒõlen na lex√©my, kter√© jsou z√°kladn√≠mi jednotkami jazyka (nap≈ô. kl√≠ƒçov√° slova, identifik√°tory,
liter√°ly).
Lexik√°ln√≠ anal√Ωza se obvykle prov√°d√≠ pomoc√≠ koneƒçn√©ho automatu nebo regul√°rn√≠ch v√Ωraz≈Ø.
V√Ωstupem lexik√°ln√≠ anal√Ωzy je posloupnost lex√©m≈Ø, kter√© jsou vstupem pro syntaktickou anal√Ωzu.
Lexik√°ln√≠ anal√Ωza m≈Ø≈æe odhalit chyby jako nezn√°m√© symboly (nap≈ô. 12YT).

### D≈Øle≈æit√© n√°stroje a techniky:

- **Regul√°rn√≠ v√Ωrazy**: Popisuj√≠ mno≈æinu ≈ôetƒõzc≈Ø pomoc√≠ jednoduch√Ωch pravidel.
- **Koneƒçn√Ω automat**: Abstraktn√≠ model, kter√Ω reprezentuje chov√°n√≠ lexik√°ln√≠ho analyz√°toru.

> Kleeneho vƒõta: Libovoln√Ω jazyk je regul√°rn√≠ pr√°vƒõ tehdy, kdy≈æ je rozpoznateln√Ω koneƒçn√Ωm automatem.

![ekvivalence_regular](img/11/ekvivalence_regular.png)

> Regul√°rn√≠ v√Ωrazy, koneƒçn√© automaty a regul√°rn√≠ gramatiky jsou ekvivalentn√≠, co≈æ znamen√°, ≈æe ka≈æd√Ω z nich m≈Ø≈æe b√Ωt
> p≈ôeveden na jeden z ostatn√≠ch.

### Varianty koneƒçn√Ωch automat≈Ø:

- **Deterministick√Ω koneƒçn√Ω automat**: Pro ka≈æd√Ω stav a vstupn√≠ symbol je definov√°na jednoznaƒçn√° p≈ôechodov√° funkce.
- **Nedeterministick√Ω koneƒçn√Ω automat**: Pro ka≈æd√Ω stav a vstupn√≠ symbol m≈Ø≈æe existovat v√≠ce mo≈æn√Ωch p≈ôechod≈Ø.
- **Zobecnƒõn√Ω nedeterministick√Ω koneƒçn√Ω automat**: Nedeterministick√Ω koneƒçn√Ω automat s mo≈ænost√≠ pr√°zdn√©ho p≈ôechodu (
  epsilon p≈ôechod).
- **Koneƒçn√Ω automat s tot√°ln√≠ p≈ôechodovou funkc√≠**: M√° definovan√Ω p≈ôechod pro ka≈æd√Ω stav a vstupn√≠ symbol, neboli v
  ka≈æd√©m stavu je schopen reagovat na v≈°echny vstupy.

## Syntaktick√° anal√Ωza

Syntaktick√° anal√Ωza se zab√Ωv√° kontrolou spr√°vnosti syntaxe programu.
Zkontroluje, zda je zdrojov√Ω k√≥d naps√°n podle pravidel dan√©ho programovac√≠ho jazyka.
Syntaktick√° anal√Ωza se obvykle prov√°d√≠ pomoc√≠ bezkontextov√Ωch gramatik a z√°sobn√≠kov√Ωch automat≈Ø.
V√Ωstupem syntaktick√© anal√Ωzy je obvykle syntaktick√Ω (derivaƒçn√≠) strom, kter√Ω reprezentuje strukturu programu.
Syntaktick√° anal√Ωza m≈Ø≈æe odhalit chyby jako chybƒõj√≠c√≠ st≈ôedn√≠k na konci ≈ô√°dku nebo neuzav≈ôen√© z√°vorky.

<div style="text-align: center;">
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/8/84/Syntakticky_strom.jpg/1062px-Syntakticky_strom.jpg?20110623131201" alt="Syntaktick√Ω-strom" width=400" height="400">
</div>

### D≈Øle≈æit√© n√°stroje a techniky:

- **LL a LR gramatiky**: Speci√°ln√≠ t≈ô√≠dy bezkontextov√Ωch gramatik, kter√© jsou vhodn√© pro syntaktickou anal√Ωzu. LL (Left
  to right parse), zat√≠mco LR (Left to right parse).

### Typy z√°sobn√≠kov√Ωch automat≈Ø:

- Automat p≈ôij√≠maj√≠c√≠ v koncov√©m stavu
- Automat p≈ôij√≠maj√≠c√≠ pr√°zdn√Ωm z√°sobn√≠kem
- Automat p≈ôij√≠maj√≠c√≠ pr√°zdn√Ωm z√°sobn√≠kem a koncov√Ωm stavem

## S√©mantick√° anal√Ωza

S√©mantick√° anal√Ωza se zab√Ωv√° kontrolou spr√°vnosti v√Ωznamu programu.
Zkontroluje, zda jsou v programu pou≈æity spr√°vn√© typy promƒõnn√Ωch, zda jsou promƒõnn√© deklarov√°ny p≈ôed pou≈æit√≠m, zda jsou
dodr≈æov√°ny typov√© konverze apod.
S√©mantick√° anal√Ωza se obvykle prov√°d√≠ po syntaktick√© anal√Ωze a vyu≈æ√≠v√° tabulku symbolu, kter√° obsahuje informace o
deklarovan√Ωch promƒõnn√Ωch a funkc√≠ch.
S√©mantick√° anal√Ωza m≈Ø≈æe odhalit chyby jako nesoulad typ≈Ø promƒõnn√Ωch nebo vol√°n√≠ nedefinovan√© funkce.

## P≈ôekladaƒçe a interprety

P≈ôekladaƒç je program, kter√Ω p≈ôev√°d√≠ zdrojov√Ω k√≥d napsan√Ω v jednom programovac√≠m jazyce na ekvivalentn√≠ zdrojov√Ω k√≥d v
jin√©m programovac√≠m jazyce nebo na strojov√Ω k√≥d.
P≈ôekladaƒç se obvykle skl√°d√° z nƒõkolika f√°z√≠, jako je lexik√°ln√≠ anal√Ωza, syntaktick√° anal√Ωza, s√©mantick√° anal√Ωza,
generov√°n√≠ mezijazyka a generov√°n√≠ c√≠lov√©ho k√≥du.
P≈ô√≠kladem programovac√≠ho jazyka, kter√Ω pou≈æ√≠v√° p≈ôekladaƒç, je C, C++, Java.

Interpret je program, kter√Ω ƒçte a vykon√°v√° zdrojov√Ω k√≥d ≈ô√°dek po ≈ô√°dce.
Interpret nemus√≠ generovat ≈æ√°dn√Ω mezik√≥d nebo strojov√Ω k√≥d, ale m≈Ø≈æe p≈ô√≠mo vykon√°vat instrukce zdrojov√©ho k√≥du.
Interpret m≈Ø≈æe b√Ωt pomalej≈°√≠ ne≈æ p≈ôekladaƒç, proto≈æe prov√°d√≠ interpretaci za bƒõhu.
P≈ô√≠kladem programovac√≠ho jazyka, kter√Ω pou≈æ√≠v√° interpret, je Python, Ruby, JavaScript.

## V√Ωbƒõr programovac√≠ho jazyka

V√Ωbƒõr programovac√≠ho jazyka z√°vis√≠ na konkr√©tn√≠ch po≈æadavc√≠ch projektu.
V z√°vƒõreƒçn√© pr√°ci m≈Ø≈æe b√Ωt zvolen jazyk na z√°kladƒõ jeho schopnosti efektivnƒõ ≈ôe≈°it dan√Ω probl√©m, dostupnosti knihoven a
n√°stroj≈Ø, osobn√≠ch preferenc√≠ program√°tora nebo specifick√Ωch vlastnost√≠ jazyka, jako je rychlost, bezpeƒçnost nebo
ƒçitelnost k√≥du.

Nap≈ô√≠klad pro pr√°ci s velk√Ωmi datov√Ωmi soubory a prov√°dƒõn√≠ slo≈æit√Ωch anal√Ωz m≈Ø≈æe b√Ωt vhodn√Ω jazyk Python d√≠ky sv√Ωm
rozs√°hl√Ωm knihovn√°m pro data science (nap≈ô. Pandas, NumPy, SciPy).
Na druhou stranu, pro implementaci syst√©m≈Ø s vysok√Ωm v√Ωkonem m≈Ø≈æe b√Ωt vhodn√Ω jazyk C++ d√≠ky sv√© rychlosti a efektivitƒõ.

## Anal√Ωza vstupn√≠ch nebo p≈ôen√°≈°en√Ωch form√°t≈Ø dat

Anal√Ωza vstupn√≠ch nebo p≈ôen√°≈°en√Ωch form√°t≈Ø dat zahrnuje nƒõkolik krok≈Ø a metod, kter√© zaji≈°≈•uj√≠ spr√°vn√© zpracov√°n√≠ dat:

1. **Parsov√°n√≠**: Tento krok zahrnuje rozlo≈æen√≠ datov√©ho form√°tu na jednotliv√© ƒç√°sti (nap≈ô. rozlo≈æen√≠ JSON nebo XML na
   kl√≠ƒç-hodnota p√°ry).
   Parsing lze prov√°dƒõt pomoc√≠ r≈Øzn√Ωch n√°stroj≈Ø a knihoven specifick√Ωch pro dan√Ω form√°t.
2. **Validace**: Po parsov√°n√≠ je d≈Øle≈æit√© ovƒõ≈ôit, zda data spl≈àuj√≠ oƒçek√°vanou strukturu a pravidla.
   Validace m≈Ø≈æe zahrnovat kontrolu sch√©mat (nap≈ô. JSON Schema pro JSON data) nebo kontrolu datov√Ωch typ≈Ø a hodnot.
3. **Chyby a jejich ≈ôe≈°en√≠**: Anal√Ωza by mƒõla zahrnovat i mechanismy pro detekci a ≈ôe≈°en√≠ chyb v datech, jako jsou
   neplatn√© hodnoty, chybƒõj√≠c√≠ √∫daje nebo nespr√°vn√© form√°tov√°n√≠.

## Vlastnosti r≈Øzn√Ωch datov√Ωch form√°t≈Ø z hlediska anal√Ωzy

1. **JSON**: Jednoduch√Ω, ƒçiteln√Ω form√°t vhodn√Ω pro v√Ωmƒõnu dat mezi webov√Ωmi aplikacemi a servery. Dob≈ôe se parsuje a
   validuje, ale m≈Ø≈æe b√Ωt n√°chyln√Ω k chyb√°m p≈ôi manu√°ln√≠ editaci.
2. **XML**: Flexibiln√≠ form√°t s mo≈ænost√≠ definice vlastn√≠ch znaƒçek a struktur. Je robustn√≠ a vhodn√Ω pro komplexn√≠ datov√©
   struktury, ale m≈Ø≈æe b√Ωt n√°roƒçn√Ω na ƒçten√≠ a zpracov√°n√≠.
3. **CSV**: Jednoduch√Ω form√°t pro ukl√°d√°n√≠ tabulkov√Ωch dat. Snadno se ƒçte a zapisuje, ale omezen√° schopnost
   reprezentovat slo≈æitƒõj≈°√≠ datov√© struktury.
4. **YAML**: Lidsky ƒçiteln√Ω form√°t, ƒçasto pou≈æ√≠van√Ω pro konfiguraƒçn√≠ soubory. Snadno se parsuje, ale m≈Ø≈æe b√Ωt n√°chyln√Ω k
   chyb√°m v odsazov√°n√≠.

Ka≈æd√Ω form√°t m√° sv√© v√Ωhody a nev√Ωhody, kter√© je t≈ôeba zv√°≈æit p≈ôi v√Ωbƒõru pro konkr√©tn√≠ √∫ƒçel.
Nap≈ô√≠klad JSON je ƒçasto preferov√°n pro webov√© aplikace kv≈Øli sv√© jednoduchosti a ƒçitelnosti, zat√≠mco XML m≈Ø≈æe b√Ωt
vhodnƒõj≈°√≠ pro komplexn√≠ datov√© struktury a p≈ôenos mezi r≈Øzn√Ωmi syst√©my.