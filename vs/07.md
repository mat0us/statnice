<div align="center" style="margin-top: 16px;">
    <strong>OtÃ¡zka 7</strong>
</div>

<nav style="
    position: sticky;
    top: 0;
    z-index: 100;
    background: rgba(0,0,0,0.8);
    padding: 8px 0 4px 0;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    text-align: center;
">
    <a href="06.md" style="color:white; text-decoration:none; margin: 0 16px;">â¬…ï¸ PÅ™edchozÃ­</a>
    <a href="../README.md" style="color:white; text-decoration:none; margin: 0 16px;">ğŸ  DomÅ¯</a>
    <a href="08.md" style="color:white; text-decoration:none; margin: 0 16px;">NÃ¡sledujÃ­cÃ­ â¡ï¸</a>
</nav>

# SprÃ¡va chybovÃ½ch stavÅ¯ aplikace v C++/JavÄ›

<div align="center">

[<kbd>ğŸŒ IT network</kbd>](https://www.itnetwork.cz/java/soubory/java-tutorial-vyjimky-try-catch-finally)  
[<kbd>ğŸŒ YouTube</kbd>](https://www.youtube.com/watch?v=_nmm0nZqIIY&pp=ygUTamF2YSBlcnJvciBoYW5kbGluZw%3D%3D)

</div>

---

> [!TIP]OtÃ¡zka
> PÅ™edchÃ¡zenÃ­ chybovÃ½m stavÅ¯m aplikace zejmÃ©na prostÅ™ednictvÃ­m vÃ½jimek; automatizovanÃ© testovÃ¡nÃ­ kÃ³du (smysl testÅ¯, jejich struktura, implementace); vhodnÃ¡ prÃ¡ce s pamÄ›tÃ­ v kontextu jazyka (napÅ™. garbage collecting, vyuÅ¾itÃ­ chytrÃ½ch ukazatelÅ¯ aj.)

---

## Chyby a chybovÃ© stavy [<kbd>Error Handling</kbd>](https://www.geeksforgeeks.org/errors-v-s-exceptions-in-java/)

SoftwarovÃ¡ chyba je chyba nebo nedostatek v poÄÃ­taÄovÃ©m programu, kterÃ¡ zpÅ¯sobuje, Å¾e program nebo systÃ©m produkuje
nesprÃ¡vnÃ© nebo neoÄekÃ¡vanÃ© vÃ½sledky nebo se chovÃ¡ neÅ¾Ã¡doucÃ­m zpÅ¯sobem.
SoftwarovÃ© chyby zahrnujÃ­ velmi Å¡irokÃ½ rozsah chovÃ¡nÃ­, jako jsou:

- vyprodukovÃ¡nÃ­ chybnÃ©ho vÃ½stupu,
- chovÃ¡nÃ­ v rozporu s uÅ¾ivatelskÃ½mi poÅ¾adavky nebo standardy,
- havÃ¡rie programu,
- zacyklenÃ­ programu,
- poÅ¡kozenÃ­, pÅ™epsÃ¡nÃ­ nebo nechtÄ›nÃ© smazÃ¡nÃ­ dat,
- naruÅ¡enÃ­ bezpeÄnosti programu nebo systÃ©mu,
- vyÄerpÃ¡nÃ­ prostÅ™edkÅ¯ systÃ©mu,
- ignorovÃ¡nÃ­ udÃ¡lostÃ­,
- selhÃ¡nÃ­ komunikace,
- nevyhovujÃ­cÃ­ rychlost nebo ovlÃ¡dÃ¡nÃ­ programu,
- nedostateÄnÃ¡ nebo matoucÃ­ komunikace programu s uÅ¾ivatelem,
- neadekvÃ¡tnÃ­ signalizace chyb nebo stavu programu
- ...

Mnoho softwarovÃ½ch chyb je zpÅ¯sobeno programÃ¡torskÃ½mi chybami, softwarovÃ© chyby vÅ¡ak mohou bÃ½t zpÅ¯sobeny i nevhodnÃ½m
pouÅ¾itÃ­m programu nebo jeho nasazenÃ­m v prostÅ™edÃ­, se kterÃ½m jeho pÅ¯vodnÃ­ nÃ¡vrh nepoÄÃ­tal.

## PÅ™edchÃ¡zenÃ­ chybovÃ½m stavÅ¯m [<kbd>Exceptions</kbd>](https://www.geeksforgeeks.org/exceptions-in-java/)

V JavÄ› je sprÃ¡va chybovÃ½ch stavÅ¯ Äasto Å™eÅ¡ena pomocÃ­ vÃ½jimek.
VÃ½jimky umoÅ¾ÅˆujÃ­ oddÄ›lit kÃ³d pro bÄ›Å¾nÃ© zpracovÃ¡nÃ­ od kÃ³du pro zpracovÃ¡nÃ­ chyb.
PoskytujÃ­ tak mechanismus pro signalizaci a zpracovÃ¡nÃ­ neoÄekÃ¡vanÃ½ch situacÃ­.
Jsou uÅ¾iteÄnÃ© pÅ™i ladÄ›nÃ­, protoÅ¾e podle typu vÃ½jimky mÅ¯Å¾eme poznat, co se v programu pÅ™ihodilo Å¡patnÄ›.

VÃ½jimky je moÅ¾nÃ© odchytÃ¡vat (tradiÄnÄ› za pomoci try-catch blokÅ¯).
PÅ™i odchytÃ¡vÃ¡nÃ­ vÃ½jimky nastavÃ­me, jakÃ½ druh vÃ½jimky se odchytÃ¡vÃ¡ pro danou ÄÃ¡st kÃ³du.
V pÅ™Ã­padÄ›, Å¾e k takovÃ© vÃ½jimce dojde, bude spuÅ¡tÄ›na programÃ¡torem definovanÃ¡ funkce, kterÃ¡ se o problÃ©m postarÃ¡.
JakÃ¡koliv nezachycenÃ¡ vÃ½jimka zpÅ¯sobÃ­ havÃ¡rii programu.

Java rozliÅ¡uje tÅ™i zÃ¡kladnÃ­ druhy vÃ½jimek: `Error`, `RuntimeException` a `Exception`.
ProgramÃ¡tora vÅ¡ak nutÃ­ k oÅ¡etÅ™enÃ­ pouze poslednÃ­ uvedenÃ© vÃ½jimky (tÅ™Ã­da `Exception`), oÅ¡etÅ™enÃ­ prvnÃ­ch dvou je
dobrovolnÃ©.
VÅ¡echny vÃ½jimky jsou potomky jednoho rozhranÃ­: `Throwable`.

![Hierarchie vÃ½jimek](img/exceptions.png)

S tÅ™Ã­dou `Throwable` se pÅ™Ã­mo nepracuje, poskytuje totiÅ¾ velmi obecnou informaci, Å¾e nastala nÄ›jakÃ¡ chyba.
TÅ™Ã­da `Error` reprezentuje chyby virtuÃ¡lnÃ­ho stroje (JVM), napÅ™. nedostatek pamÄ›ti â€“ `OutOfMemoryError` nebo pÅ™eteÄenÃ­
zÃ¡sobnÃ­ku â€“ `StackOverflowError`.
V programu se obvykle neoÅ¡etÅ™ujÃ­ (nÄ›kterÃ© ani nelze oÅ¡etÅ™it).

TÅ™Ã­da `Exception` a jejÃ­ potomci, mimo vÄ›tev `RuntimeException`, jsou vÃ½jimky, u kterÃ½ch pÅ™ekladaÄ kontroluje, zda je
oÅ¡etÅ™ujeme.
Mezi typickÃ© zÃ¡stupce patÅ™Ã­ chyby vzniklÃ© pÅ™i prÃ¡ci se vstupy a vÃ½stupy.
Na moÅ¾nost vÃ½skytu vÃ½jimky musÃ­me v kÃ³du nÄ›jak reagovat (viz dÃ¡le), jinak pÅ™ekladaÄ vypÃ­Å¡e upozornÄ›nÃ­ a kÃ³d nepÅ™eloÅ¾Ã­.

TÅ™Ã­da `RuntimeException` a jejÃ­ potomci reprezentujÃ­ chyby, na kterÃ© lze takÃ© ÃºspÄ›Å¡nÄ› reagovat, ale u kterÃ½ch nenÃ­
pÅ™ekladaÄem vyÅ¾adovÃ¡no jejich oÅ¡etÅ™enÃ­.
Jsou to napÅ™Ã­klad `ArithmeticException`, `ArrayOutOfBoundsException`, `NullPointerException`
nebo `NumberFormatException`.
V mnoha pÅ™Ã­padech mÅ¯Å¾e programÃ¡tor pÅ™edejÃ­t tÄ›mto vÃ½jimkÃ¡m testovÃ¡nÃ­m aplikace nebo peÄlivostÃ­ pÅ™i programovÃ¡nÃ­.

**Jak vyÅ™eÅ¡it vÃ½jimky**

1. `ZachycenÃ­ v bloku try-catch`: v try bloku provedeme vÅ¡echny operace a pokud vznikne vÃ½jimka, zachytÃ­me v catch bloku

```java
try {
    // hlÃ­danÃ½ blok
} catch(Exception1 ex1) {
    // oÅ¡etÅ™enÃ­ vÃ½jimky 1
} catch(Exception2 ex2) {
    // oÅ¡etÅ™enÃ­ vÃ½jimky 2
} finally {
    // kÃ³d uvedenÃ½ zde se provede vÅ¾dy
}
``` 

2. `PÅ™edÃ¡nÃ­ vÃ½jimky volajÃ­cÃ­ metodÄ›`: Å™ekneme, Å¾e naÅ¡e metoda mÅ¯Å¾e vyvolat vÃ½jimku, a ten kdo bude volat naÅ¡i metodu
   musÃ­ vyÅ™eÅ¡it zpracovÃ¡nÃ­ tÃ©to vÃ½jimky

```java
public void openFile() throws IOException {} 
```

## AutomatizovanÃ© testy   [<kbd>Automated Testing</kbd>](https://www.geeksforgeeks.org/automation-testing-software-testing/)

AutomatizovanÃ© testy jsou softwarovÃ½m nÃ¡strojem, kterÃ½ umoÅ¾Åˆuje provÃ¡dÄ›t opakovanÃ© kontroly toho, jestli testovanÃ¡
aplikace funguje poÅ¾adovanÃ½m zpÅ¯sobem.
DÃ­ky testÅ¯m je moÅ¾nÃ© jiÅ¾ hotovou aplikaci rozÅ¡iÅ™ovat Äi mÄ›nit aniÅ¾ by se vÃ½vojÃ¡Å™ musel bÃ¡t, Å¾e zmÄ›nami rozbije jiÅ¾
sprÃ¡vnÄ› fungujÃ­ ÄÃ¡sti aplikace.
Testy kontrolujÃ­, Å¾e struktury, kterÃ© v aplikaci existujÃ­, se chovajÃ­ pÅ™esnÄ› tak jak majÃ­.
Pojmem â€testâ€œ se rozumÃ­ testovacÃ­ metoda, kterÃ¡ slouÅ¾Ã­ k testovÃ¡nÃ­ nÄ›jakÃ© metody programu.

Existuje vÃ­ce druhÅ¯ testÅ¯:

- `unit testy`: tzv. atomickÃ½ testy, ovÄ›Å™ujÃ­cÃ­ jednu funkcionalitu
- `integration testy`: testujÃ­ spoluprÃ¡ci mezi rÅ¯znÃ½mi komponentami aplikace
- `system testy`: testujÃ­ celÃ½ systÃ©m jako celek.
- `UI testy`: testy simulujÃ­cÃ­ bÄ›h aplikace, vykreslenÃ­ UI a uÅ¾ivatelskÃ© interakce

V JavÄ› se pro automatizovanÃ© testovÃ¡nÃ­ Äasto pouÅ¾Ã­vÃ¡ knihovna [JUnit](https://www.geeksforgeeks.org/introduction-of-junit/).
Struktura konkrÃ©tnÃ­ho testu zÃ¡visÃ­ na jeho typu.
ObecnÄ› vÅ¡ak platÃ­, Å¾e by test mÄ›l obsahovat volÃ¡nÃ­ metody, kterou testuje a kontrolu jejÃ­ho vÃ½sledku.
Kontrola vÃ½sledkÅ¯ se provÃ¡dÃ­ pomocÃ­ tzv. `assert` metod.
Tyto metody provÃ¡dÄ›jÃ­ porovnÃ¡nÃ­ oÄekÃ¡vanÃ½ch hodnot se skuteÄnÃ½mi.
Pokud jsou vyhodnoceny nepravdivÄ› jako *false*, zpÅ¯sobÃ­ selhÃ¡nÃ­ testu.

V pÅ™Ã­padÄ› jednotkovÃ½ch testÅ¯ je dobrou zÃ¡sadou netestovat pouze kladnÃ½ vÃ½sledek.
Velmi vhodnÃ© je vytvÃ¡Å™et testy na okrajovÃ© hodnoty, pÅ™i kterÃ½ch se mÅ¯Å¾e testovanÃ¡ metoda chovat Å¡patnÄ›.
TÃ­m zajistÃ­me kontrolu toho, jestli se umÃ­ metoda vyrovnat s jakÃ½mkoliv vstupem uÅ¾ivatele.

TestovÃ¡nÃ­ je na tolik dÅ¯leÅ¾itÃ¡ ÄÃ¡st vÃ½voje, Å¾e existuje i postup Å™Ã­zenÃ­ vÃ½voje zaloÅ¾enÃ½ primÃ¡rnÄ› na testech.
Jmenuje se **TDD** neboli **Test-Driven-Development**.
Tento styl vÃ½voje je zaloÅ¾en na tom, Å¾e si vÃ½vojÃ¡Å™ nejprve vymyslÃ­ a napÃ­Å¡e testy na metodu, kterou mÃ¡ implementovat.
Po sepsÃ¡nÃ­ vÅ¡ech testÅ¯ provÃ¡dÃ­ implementaci a ovÄ›Å™uje sprÃ¡vnost pomocÃ­ jiÅ¾ existujÃ­cÃ­ch testÅ¯.

## PrÃ¡ce s pamÄ›tÃ­

KaÅ¾dÃ½ program pÅ™i pÅ™evodu na proces zÃ­skÃ¡vÃ¡ mÃ­sto v pamÄ›ti. Tento pamÄ›Å¥ovÃ½ prostor se sklÃ¡dÃ¡ z dvou hlavnÃ­ch ÄÃ¡stÃ­, ve kterÃ½ch je moÅ¾nÃ© uklÃ¡dat promÄ›nnÃ©:

| Oblast                | Vlastnosti            | Co obsahuje                                 |
|-----------------------|----------------------|---------------------------------------------|
| **Stack** (zÃ¡sobnÃ­k)  | MenÅ¡Ã­, velmi rychlÃ½  | LokÃ¡lnÃ­ promÄ›nnÃ©, parametry metod, reference na objekty, primitivnÃ­ typy |
| **Heap** (halda)      | VÄ›tÅ¡Ã­, pomalejÅ¡Ã­     | VÅ¡echny objekty a instance tÅ™Ã­d             |

![PamÄ›Å¥ procesu](img/memory.png)

### Java vs. C++: SprÃ¡va pamÄ›ti

Java a C++ pÅ™edstavujÃ­ dva odliÅ¡nÃ© pÅ™Ã­stupy ke sprÃ¡vÄ› pamÄ›ti:

- **Java**  
  VyuÅ¾Ã­vÃ¡ automatickÃ½ garbage collector (GC), kterÃ½ na pozadÃ­ sleduje a uvolÅˆuje pamÄ›Å¥ obsazenou objekty, na kterÃ© uÅ¾ neexistuje Å¾Ã¡dnÃ¡ silnÃ¡ reference. VÃ½vojÃ¡Å™ se nemusÃ­ starat o explicitnÃ­ uvolÅˆovÃ¡nÃ­ pamÄ›ti, coÅ¾ sniÅ¾uje riziko memory leaks a visÃ­cÃ­ch ukazatelÅ¯ (dangling pointers)[1][3][5].

- **C++**  
  NabÃ­zÃ­ manuÃ¡lnÃ­ a detailnÃ­ kontrolu nad pamÄ›tÃ­. ProgramÃ¡tor musÃ­ sÃ¡m alokovat (`new`) a uvolnit (`delete`) pamÄ›Å¥. To umoÅ¾Åˆuje optimalizovat vÃ½kon a vyuÅ¾itÃ­ pamÄ›ti, ale zÃ¡roveÅˆ zvyÅ¡uje riziko chyb, jako jsou memory leaks nebo dangling pointers.

### Jak funguje sprÃ¡va pamÄ›ti v JavÄ›

Java automaticky spravuje pamÄ›Å¥ pomocÃ­ **garbage collectoru (GC)**, kterÃ½ bÄ›Å¾Ã­ na pozadÃ­ a uvolÅˆuje objekty, na kterÃ© jiÅ¾ neexistujÃ­ Å¾Ã¡dnÃ© silnÃ© reference. DÃ­ky tomu se programÃ¡tor nemusÃ­ starat o explicitnÃ­ dealokaci pamÄ›ti, coÅ¾ sniÅ¾uje riziko **memory leaks** nebo **dangling pointers**.

---

#### KlÃ­ÄovÃ© body sprÃ¡vy pamÄ›ti:

- **Alokace objektÅ¯:**  
  VÅ¡echny objekty jsou alokovÃ¡ny na **heapu**. LokÃ¡lnÃ­ promÄ›nnÃ© a reference na objekty jsou uloÅ¾eny na **stacku**.  
  Stack obsahuje takÃ© primitivnÃ­ datovÃ© typy pouÅ¾Ã­vanÃ© v metodÃ¡ch.

- **Å½ivotnÃ­ cyklus metody a stacku:**  
  PÅ™i volÃ¡nÃ­ metody se lokÃ¡lnÃ­ promÄ›nnÃ© uklÃ¡dajÃ­ na stack a po skonÄenÃ­ metody jsou automaticky odstranÄ›ny.  
  RekurzivnÃ­ volÃ¡nÃ­ mÅ¯Å¾e vyÄerpat mÃ­sto ve stacku, coÅ¾ vede ke stack overflow.

- **Garbage Collector:**  
  BÄ›Å¾Ã­ automaticky a uvolÅˆuje z heapu objekty, na kterÃ© neexistuje Å¾Ã¡dnÃ¡ silnÃ¡ reference.  
  Algoritmy GC sledujÃ­ objekty a jejich reference.

- **Reference v JavÄ›:**  
  - *SilnÃ¡ reference* â€“ bÄ›Å¾nÃ¡ reference, kterÃ¡ drÅ¾Ã­ objekt â€Å¾ivÃ½â€œ.  
  - *SlabÃ¡ reference* â€“ umoÅ¾Åˆuje GC uvolnit objekt, pokud na nÄ›j neexistujÃ­ Å¾Ã¡dnÃ© silnÃ© reference (uÅ¾iteÄnÃ© napÅ™Ã­klad pro cache).  
  Java nemÃ¡ chytrÃ© ukazatele jako C++ â€“ sprÃ¡va je kompletnÄ› zaloÅ¾enÃ¡ na GC a typech referencÃ­.

---

#### PÅ™Ã­klad kÃ³du a Å¾ivotnÃ­ cyklus objektu:

```java
public class MyClass {
    public static void main(String[] args) {
        MyClass obj = new MyClass(); // Objekt alokovÃ¡n na heapu, reference na stacku
        obj = null;                  // Reference zanikÃ¡, objekt je kandidÃ¡t na GC
        // Garbage Collector objekt uvolnÃ­ automaticky nÄ›kdy pozdÄ›ji
    }
}
```

#### Jak funguje sprÃ¡va pamÄ›ti v C++

SprÃ¡va pamÄ›ti v C++ je na rozdÃ­l od Javy **manuÃ¡lnÃ­** â€“ programÃ¡tor musÃ­ sÃ¡m rozhodovat, kdy pamÄ›Å¥ alokovat a kdy ji uvolnit. Od C++11 ale existujÃ­ **chytrÃ© ukazatele**, kterÃ© pomÃ¡hajÃ­ sprÃ¡vu automatizovat a minimalizujÃ­ riziko chyb jako jsou memory leaks nebo dangling pointers.

---

#### ğŸ§  ZÃ¡kladnÃ­ principy

* **ManuÃ¡lnÃ­ sprÃ¡va pamÄ›ti**

  * Alokace pomocÃ­ `new`, uvolnÄ›nÃ­ pomocÃ­ `delete`.
  * VyÅ¾aduje peÄlivÃ© plÃ¡novÃ¡nÃ­, jinak hrozÃ­:

    * **Memory leak** â€“ zapomenutÃ© `delete`, pamÄ›Å¥ se neuvolnÃ­.
    * **Dangling pointer** â€“ pÅ™Ã­stup k pamÄ›ti, kterÃ¡ uÅ¾ byla uvolnÄ›na.

```cpp
int* ptr = new int(42); // alokace na heapu
delete ptr;             // ruÄnÃ­ dealokace
ptr = nullptr;          // prevence dangling pointeru
```

---

#### ChytrÃ© ukazatele

ChytrÃ© ukazatele ze standardnÃ­ knihovny (`<memory>`) Å™eÅ¡Ã­ automatickou sprÃ¡vu pamÄ›ti pomocÃ­ principu vlastnictvÃ­.

* `std::unique_ptr<T>`

  * ExkluzivnÃ­ vlastnictvÃ­ objektu.
  * Nelze kopÃ­rovat, pouze pÅ™esunout (move semantics).
  * UvolnÃ­ objekt pÅ™i zÃ¡niku.

```cpp
#include <memory>
std::unique_ptr<int> uptr = std::make_unique<int>(5);
```

* `std::shared_ptr<T>`

  * SdÃ­lenÃ© vlastnictvÃ­ (vÃ­ce ukazatelÅ¯ mÅ¯Å¾e sdÃ­let objekt).
  * UvolnÄ›nÃ­ probÄ›hne automaticky, jakmile zanikne poslednÃ­ reference.

```cpp
#include <memory>
std::shared_ptr<int> sp1 = std::make_shared<int>(10);
std::shared_ptr<int> sp2 = sp1; // sdÃ­lenÃ­ vlastnictvÃ­
```

* `std::weak_ptr<T>`

  * SlabÃ¡ reference â€“ nespoÄÃ­tÃ¡vÃ¡ se do vlastnictvÃ­.
  * PouÅ¾Ã­vÃ¡ se k rozbitÃ­ cyklickÃ½ch zÃ¡vislostÃ­ u `shared_ptr`.

```cpp
#include <memory>
std::shared_ptr<int> sp = std::make_shared<int>(100);
std::weak_ptr<int> wp = sp; // slabÃ¡ reference
```

---

#### ShrnutÃ­

| Ukazatel      | VlastnictvÃ­ | UvolnÄ›nÃ­ pamÄ›ti         | VhodnÃ© pouÅ¾itÃ­                       |
| ------------- | ----------- | ----------------------- | ------------------------------------ |
| `raw pointer` | manuÃ¡lnÃ­    | ruÄnÄ› pomocÃ­ `delete`   | nÃ­zkoÃºrovÅˆovÃ½ kÃ³d, speciÃ¡lnÃ­ pÅ™Ã­pady |
| `unique_ptr`  | exkluzivnÃ­  | automaticky pÅ™i zÃ¡niku  | bÄ›Å¾nÃ© pÅ™Ã­pady s jednÃ­m vlastnÃ­kem    |
| `shared_ptr`  | sdÃ­lenÃ©     | po zÃ¡niku poslednÃ­ho    | vÃ­ce vlastnÃ­kÅ¯                       |
| `weak_ptr`    | Å¾Ã¡dnÃ©       | zÃ¡vislÃ© na `shared_ptr` | rozbÃ­jenÃ­ cyklickÃ½ch zÃ¡vislostÃ­      |

---

### PorovnÃ¡nÃ­ sprÃ¡vy pamÄ›ti v JavÄ› a C++

`S Garbage Collection`

- **VÃ½hody**:
    - *ZjednoduÅ¡enÃ¡ sprÃ¡va pamÄ›ti*: Java vÃ½vojÃ¡Å™i nemusÃ­ ruÄnÄ› spravovat alokaci a dealokaci pamÄ›ti, coÅ¾ sniÅ¾uje
      kognitivnÃ­ zÃ¡tÄ›Å¾ a sniÅ¾uje riziko memory leakÅ¯.
    - *AutomatickÃ© uvolÅˆovÃ¡nÃ­ pamÄ›ti*: Garbage collector automaticky uvolÅˆuje pamÄ›Å¥, kterÃ¡ jiÅ¾ nenÃ­ vyuÅ¾Ã­vÃ¡na, coÅ¾
      pomÃ¡hÃ¡ pÅ™edchÃ¡zet overflow a zajiÅ¡Å¥uje efektivnÃ­ vyuÅ¾itÃ­ zdrojÅ¯.
    - *BezpeÄnost*: AutomatickÃ¡ sprÃ¡va pamÄ›ti v JavÄ› pomÃ¡hÃ¡ pÅ™edchÃ¡zet bÄ›Å¾nÃ½m programovacÃ­m chybÃ¡m, jako jsou dangling
      pointers a dvojitÃ© uvolnÄ›nÃ­, kterÃ© mohou bÃ½t potenciÃ¡lnÃ­mi bezpeÄnostnÃ­mi riziky.
- **NevÃ½hody**:
    - *VÃ½konnostnÃ­ reÅ¾ie*: Garbage collector mÅ¯Å¾e spotÅ™ebovÃ¡vat hodnÄ› vÃ½konu. NaÄasovÃ¡nÃ­ garbage collection je
      nepÅ™edvÃ­datelnÃ©, coÅ¾ mÅ¯Å¾e vÃ©st k pauzÃ¡m v provÃ¡dÄ›nÃ­ programu, coÅ¾ ovlivÅˆuje vÃ½kon, zejmÃ©na v aplikacÃ­ch v reÃ¡lnÃ©m
      Äase.
    - *MenÅ¡Ã­ kontrola*: VÃ½vojÃ¡Å™i majÃ­ omezenou kontrolu nad naÄasovÃ¡nÃ­m a provozem garbage collectoru, coÅ¾ mÅ¯Å¾e bÃ½t
      nevÃ½hodou ve scÃ©nÃ¡Å™Ã­ch, kde je vyÅ¾adovÃ¡na pÅ™esnÃ¡ sprÃ¡va pamÄ›ti a je to horÅ¡Ã­ pro optimalizovÃ¡nÃ­.

`Bez Garbage Collection`

- **VÃ½hody**:
    - *VÄ›tÅ¡Ã­ kontrola*: ProgramÃ¡toÅ™i v C++ majÃ­ explicitnÃ­ kontrolu nad alokacÃ­ a dealokacÃ­ pamÄ›ti, coÅ¾ umoÅ¾Åˆuje
      optimalizovat vyuÅ¾itÃ­ pamÄ›ti a vÃ½kon pro konkrÃ©tnÃ­ potÅ™eby. (Doom optimalizace)
    - *VÃ½kon*: DÃ­ky ruÄnÃ­ sprÃ¡vÄ› pamÄ›ti mÅ¯Å¾e C++ dosÃ¡hnout vyÅ¡Å¡Ã­ho vÃ½konu tÃ­m, Å¾e se vyhne reÅ¾ii spojenÃ© s garbage
      collection, coÅ¾ je zÃ¡sadnÃ­ pro systÃ©my, kde jsou klÃ­ÄovÃ© vÃ½kon a nÃ­zkÃ¡ latence.

- **NevÃ½hody**:
    - *ZvÃ½Å¡enÃ¡ sloÅ¾itost*: PoÅ¾adavek na ruÄnÃ­ sprÃ¡vu pamÄ›ti zvyÅ¡uje sloÅ¾itost kÃ³du a vyÅ¾aduje vyÅ¡Å¡Ã­ ÃºroveÅˆ pozornosti od
      vÃ½vojÃ¡Å™Å¯, coÅ¾ mÅ¯Å¾e vÃ©st k chybÃ¡m.
    - *Riziko ÃºnikÅ¯ pamÄ›ti a chyb*: RuÄnÃ­ sprÃ¡va pamÄ›ti pÅ™inÃ¡Å¡Ã­ riziko ÃºnikÅ¯ pamÄ›ti, visÃ­cÃ­ch ukazatelÅ¯ a dalÅ¡Ã­ch
      souvisejÃ­cÃ­ch chyb, pokud nenÃ­ sprÃ¡vnÄ› zvlÃ¡dnuta, coÅ¾ mÅ¯Å¾e zpÅ¯sobit pÃ¡d aplikace nebo nepÅ™edvÃ­datelnÃ© chovÃ¡nÃ­.