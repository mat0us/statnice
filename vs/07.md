<div align="center" style="margin-top: 16px;">
    <strong>OtÃ¡zka 6</strong>
</div>

<nav style="
    position: sticky;
    top: 0;
    z-index: 100;
    background: rgba(0,0,0,0.8);
    padding: 8px 0 4px 0;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    text-align: center;
">
    <a href="06.md" style="color:white; text-decoration:none; margin: 0 16px;">â¬…ï¸ PÅ™edchozÃ­</a>
    <a href="../README.md" style="color:white; text-decoration:none; margin: 0 16px;">ğŸ  DomÅ¯</a>
    <a href="08.md" style="color:white; text-decoration:none; margin: 0 16px;">NÃ¡sledujÃ­cÃ­ â¡ï¸</a>
</nav>

# 7 SprÃ¡va chybovÃ½ch stavÅ¯ aplikace v C++/JavÄ›

**OtÃ¡zka:** PÅ™edchÃ¡zenÃ­ chybovÃ½m stavÅ¯m aplikace zejmÃ©na prostÅ™ednictvÃ­m vÃ½jimek; automatizovanÃ© testovÃ¡nÃ­ kÃ³du (smysl testÅ¯, jejich struktura, implementace); vhodnÃ¡ prÃ¡ce s pamÄ›tÃ­ v kontextu jazyka (napÅ™. garbage collecting, vyuÅ¾itÃ­ chytrÃ½ch
ukazatelÅ¯ aj.)

---

### Chyby a chybovÃ© stavy

SoftwarovÃ¡ chyba je chyba nebo nedostatek v poÄÃ­taÄovÃ©m programu, kterÃ¡ zpÅ¯sobuje, Å¾e program nebo systÃ©m produkuje
nesprÃ¡vnÃ© nebo neoÄekÃ¡vanÃ© vÃ½sledky nebo se chovÃ¡ neÅ¾Ã¡doucÃ­m zpÅ¯sobem.
SoftwarovÃ© chyby zahrnujÃ­ velmi Å¡irokÃ½ rozsah chovÃ¡nÃ­, jako jsou:

- vyprodukovÃ¡nÃ­ chybnÃ©ho vÃ½stupu,
- chovÃ¡nÃ­ v rozporu s uÅ¾ivatelskÃ½mi poÅ¾adavky nebo standardy,
- havÃ¡rie programu,
- zacyklenÃ­ programu,
- poÅ¡kozenÃ­, pÅ™epsÃ¡nÃ­ nebo nechtÄ›nÃ© smazÃ¡nÃ­ dat,
- naruÅ¡enÃ­ bezpeÄnosti programu nebo systÃ©mu,
- vyÄerpÃ¡nÃ­ prostÅ™edkÅ¯ systÃ©mu,
- ignorovÃ¡nÃ­ udÃ¡lostÃ­,
- selhÃ¡nÃ­ komunikace,
- nevyhovujÃ­cÃ­ rychlost nebo ovlÃ¡dÃ¡nÃ­ programu,
- nedostateÄnÃ¡ nebo matoucÃ­ komunikace programu s uÅ¾ivatelem,
- neadekvÃ¡tnÃ­ signalizace chyb nebo stavu programu
- ...

Mnoho softwarovÃ½ch chyb je zpÅ¯sobeno programÃ¡torskÃ½mi chybami, softwarovÃ© chyby vÅ¡ak mohou bÃ½t zpÅ¯sobeny i nevhodnÃ½m
pouÅ¾itÃ­m programu nebo jeho nasazenÃ­m v prostÅ™edÃ­, se kterÃ½m jeho pÅ¯vodnÃ­ nÃ¡vrh nepoÄÃ­tal.

### PÅ™edchÃ¡zenÃ­ chybovÃ½m stavÅ¯m

V JavÄ› je sprÃ¡va chybovÃ½ch stavÅ¯ Äasto Å™eÅ¡ena pomocÃ­ vÃ½jimek.
VÃ½jimky umoÅ¾ÅˆujÃ­ oddÄ›lit kÃ³d pro bÄ›Å¾nÃ© zpracovÃ¡nÃ­ od kÃ³du pro zpracovÃ¡nÃ­ chyb.
PoskytujÃ­ tak mechanismus pro signalizaci a zpracovÃ¡nÃ­ neoÄekÃ¡vanÃ½ch situacÃ­.
Jsou uÅ¾iteÄnÃ© pÅ™i ladÄ›nÃ­, protoÅ¾e podle typu vÃ½jimky mÅ¯Å¾eme poznat, co se v programu pÅ™ihodilo Å¡patnÄ›.

VÃ½jimky je moÅ¾nÃ© odchytÃ¡vat (tradiÄnÄ› za pomoci try-catch blokÅ¯).
PÅ™i odchytÃ¡vÃ¡nÃ­ vÃ½jimky nastavÃ­me, jakÃ½ druh vÃ½jimky se odchytÃ¡vÃ¡ pro danou ÄÃ¡st kÃ³du.
V pÅ™Ã­padÄ›, Å¾e k takovÃ© vÃ½jimce dojde, bude spuÅ¡tÄ›na programÃ¡torem definovanÃ¡ funkce, kterÃ¡ se o problÃ©m postarÃ¡.
JakÃ¡koliv nezachycenÃ¡ vÃ½jimka zpÅ¯sobÃ­ havÃ¡rii programu.

Java rozliÅ¡uje tÅ™i zÃ¡kladnÃ­ druhy vÃ½jimek: `Error`, `RuntimeException` a `Exception`.
ProgramÃ¡tora vÅ¡ak nutÃ­ k oÅ¡etÅ™enÃ­ pouze poslednÃ­ uvedenÃ© vÃ½jimky (tÅ™Ã­da `Exception`), oÅ¡etÅ™enÃ­ prvnÃ­ch dvou je
dobrovolnÃ©.
VÅ¡echny vÃ½jimky jsou potomky jednoho rozhranÃ­: `Throwable`.

![Hierarchie vÃ½jimek](img/exceptions.png)

S tÅ™Ã­dou `Throwable` se pÅ™Ã­mo nepracuje, poskytuje totiÅ¾ velmi obecnou informaci, Å¾e nastala nÄ›jakÃ¡ chyba.
TÅ™Ã­da `Error` reprezentuje chyby virtuÃ¡lnÃ­ho stroje (JVM), napÅ™. nedostatek pamÄ›ti â€“ `OutOfMemoryError` nebo pÅ™eteÄenÃ­
zÃ¡sobnÃ­ku â€“ `StackOverflowError`.
V programu se obvykle neoÅ¡etÅ™ujÃ­ (nÄ›kterÃ© ani nelze oÅ¡etÅ™it).

TÅ™Ã­da `Exception` a jejÃ­ potomci, mimo vÄ›tev `RuntimeException`, jsou vÃ½jimky, u kterÃ½ch pÅ™ekladaÄ kontroluje, zda je
oÅ¡etÅ™ujeme.
Mezi typickÃ© zÃ¡stupce patÅ™Ã­ chyby vzniklÃ© pÅ™i prÃ¡ci se vstupy a vÃ½stupy.
Na moÅ¾nost vÃ½skytu vÃ½jimky musÃ­me v kÃ³du nÄ›jak reagovat (viz dÃ¡le), jinak pÅ™ekladaÄ vypÃ­Å¡e upozornÄ›nÃ­ a kÃ³d nepÅ™eloÅ¾Ã­.

TÅ™Ã­da `RuntimeException` a jejÃ­ potomci reprezentujÃ­ chyby, na kterÃ© lze takÃ© ÃºspÄ›Å¡nÄ› reagovat, ale u kterÃ½ch nenÃ­
pÅ™ekladaÄem vyÅ¾adovÃ¡no jejich oÅ¡etÅ™enÃ­.
Jsou to napÅ™Ã­klad `ArithmeticException`, `ArrayOutOfBoundsException`, `NullPointerException`
nebo `NumberFormatException`.
V mnoha pÅ™Ã­padech mÅ¯Å¾e programÃ¡tor pÅ™edejÃ­t tÄ›mto vÃ½jimkÃ¡m testovÃ¡nÃ­m aplikace nebo peÄlivostÃ­ pÅ™i programovÃ¡nÃ­.

**Jak vyÅ™eÅ¡it vÃ½jimky**

1. `ZachycenÃ­ v bloku try-catch`: v try bloku provedeme vÅ¡echny operace a pokud vznikne vÃ½jimka, zachytÃ­me v catch bloku

```java
try {
    // hlÃ­danÃ½ blok
} catch(Exception1 ex1) {
    // oÅ¡etÅ™enÃ­ vÃ½jimky 1
} catch(Exception2 ex2) {
    // oÅ¡etÅ™enÃ­ vÃ½jimky 2
} finally {
    // kÃ³d uvedenÃ½ zde se provede vÅ¾dy
}
``` 

2. `PÅ™edÃ¡nÃ­ vÃ½jimky volajÃ­cÃ­ metodÄ›`: Å™ekneme, Å¾e naÅ¡e metoda mÅ¯Å¾e vyvolat vÃ½jimku, a ten kdo bude volat naÅ¡i metodu
   musÃ­ vyÅ™eÅ¡it zpracovÃ¡nÃ­ tÃ©to vÃ½jimky

```java
public void openFile() throws IOException {} 
```

### AutomatizovanÃ© testy

AutomatizovanÃ© testy jsou softwarovÃ½m nÃ¡strojem, kterÃ½ umoÅ¾Åˆuje provÃ¡dÄ›t opakovanÃ© kontroly toho, jestli testovanÃ¡
aplikace funguje poÅ¾adovanÃ½m zpÅ¯sobem.
DÃ­ky testÅ¯m je moÅ¾nÃ© jiÅ¾ hotovou aplikaci rozÅ¡iÅ™ovat Äi mÄ›nit aniÅ¾ by se vÃ½vojÃ¡Å™ musel bÃ¡t, Å¾e zmÄ›nami rozbije jiÅ¾
sprÃ¡vnÄ› fungujÃ­ ÄÃ¡sti aplikace.
Testy kontrolujÃ­, Å¾e struktury, kterÃ© v aplikaci existujÃ­, se chovajÃ­ pÅ™esnÄ› tak jak majÃ­.
Pojmem â€testâ€œ se rozumÃ­ testovacÃ­ metoda, kterÃ¡ slouÅ¾Ã­ k testovÃ¡nÃ­ nÄ›jakÃ© metody programu.

Existuje vÃ­ce druhÅ¯ testÅ¯:

- `unit testy`: tzv. atomickÃ½ testy, ovÄ›Å™ujÃ­cÃ­ jednu funkcionalitu
- `integration testy`: testujÃ­ spoluprÃ¡ci mezi rÅ¯znÃ½mi komponentami aplikace
- `system testy`: testujÃ­ celÃ½ systÃ©m jako celek.
- `UI testy`: testy simulujÃ­cÃ­ bÄ›h aplikace, vykreslenÃ­ UI a uÅ¾ivatelskÃ© interakce

V JavÄ› se pro automatizovanÃ© testovÃ¡nÃ­ Äasto pouÅ¾Ã­vÃ¡ knihovna JUnit.
Struktura konkrÃ©tnÃ­ho testu zÃ¡visÃ­ na jeho typu.
ObecnÄ› vÅ¡ak platÃ­, Å¾e by test mÄ›l obsahovat volÃ¡nÃ­ metody, kterou testuje a kontrolu jejÃ­ho vÃ½sledku.
Kontrola vÃ½sledkÅ¯ se provÃ¡dÃ­ pomocÃ­ tzv. `assert` metod.
Tyto metody provÃ¡dÄ›jÃ­ porovnÃ¡nÃ­ oÄekÃ¡vanÃ½ch hodnot se skuteÄnÃ½mi.
Pokud jsou vyhodnoceny nepravdivÄ› jako *false*, zpÅ¯sobÃ­ selhÃ¡nÃ­ testu.

V pÅ™Ã­padÄ› jednotkovÃ½ch testÅ¯ je dobrou zÃ¡sadou netestovat pouze kladnÃ½ vÃ½sledek.
Velmi vhodnÃ© je vytvÃ¡Å™et testy na okrajovÃ© hodnoty, pÅ™i kterÃ½ch se mÅ¯Å¾e testovanÃ¡ metoda chovat Å¡patnÄ›.
TÃ­m zajistÃ­me kontrolu toho, jestli se umÃ­ metoda vyrovnat s jakÃ½mkoliv vstupem uÅ¾ivatele.

TestovÃ¡nÃ­ je na tolik dÅ¯leÅ¾itÃ¡ ÄÃ¡st vÃ½voje, Å¾e existuje i postup Å™Ã­zenÃ­ vÃ½voje zaloÅ¾enÃ½ primÃ¡rnÄ› na testech.
Jmenuje se **TDD** neboli **Test-Driven-Development**.
Tento styl vÃ½voje je zaloÅ¾en na tom, Å¾e si vÃ½vojÃ¡Å™ nejprve vymyslÃ­ a napÃ­Å¡e testy na metodu, kterou mÃ¡ implementovat.
Po sepsÃ¡nÃ­ vÅ¡ech testÅ¯ provÃ¡dÃ­ implementaci a ovÄ›Å™uje sprÃ¡vnost pomocÃ­ jiÅ¾ existujÃ­cÃ­ch testÅ¯.

### PrÃ¡ce s pamÄ›tÃ­

KaÅ¾dÃ½ program pÅ™i pÅ™evodu na proces zÃ­skÃ¡vÃ¡ mÃ­sto v pamÄ›ti.
Tento pamÄ›Å¥ovÃ½ prostor se sklÃ¡dÃ¡ z dvou hlavnÃ­ch ÄÃ¡stÃ­, ve kterÃ½ch je moÅ¾nÃ© uklÃ¡dat promÄ›nnÃ©:

- stack - zÃ¡sobnÃ­k, menÅ¡Ã­ a rychlejÅ¡Ã­
- heap - halda, vÄ›tÅ¡Ã­ a pomalejÅ¡Ã­

![PamÄ›Å¥ procesu](img/memory.png)

Podle toho, jakÃ½ programovacÃ­ jazyk se pouÅ¾Ã­vÃ¡, se s touto pÅ™idÄ›lenou pamÄ›tÃ­ pracuje.
Java a C++ pÅ™edstavujÃ­ dva rÅ¯znÃ© pÅ™Ã­stupy k sprÃ¡vÄ› pamÄ›ti.
Java pouÅ¾Ã­vÃ¡ automatickÃ½ garbage collector a C++ nabÃ­zÃ­ manuÃ¡lnÃ­ a detailnÃ­ kontrolu nad pamÄ›tÃ­.

Java mÃ¡ vestavÄ›nÃ½ garbage collector, kterÃ½ automaticky spravuje pamÄ›Å¥ a uvolÅˆuje objekty, kterÃ© jiÅ¾ nejsou pouÅ¾ity.
To sniÅ¾uje riziko memory leaks a dangling pointers.
Garbage collector bÄ›Å¾Ã­ na pozadÃ­ a pouÅ¾Ã­vÃ¡ rÅ¯znÃ© algoritmy ke sledovÃ¡nÃ­ a uvolÅˆovÃ¡nÃ­ nepouÅ¾Ã­vanÃ© pamÄ›ti.
DÃ­ky garbage collectoru se programÃ¡tor nemusÃ­ explicitnÄ› starat o alokaci a dealokaci pamÄ›ti.

Objekty jsou alokovÃ¡ny na heapu a referenÄnÃ­ promÄ›nnÃ© jsou spravovÃ¡ny na stacku.
Stack neobsahuje pouze referenÄÃ­ promÄ›nnÃ©, ale takÃ© i ostatnÃ­ promÄ›nnÃ© s primitivnÃ­mi datovÃ½mi typy.
PÅ™i volÃ¡nÃ­ metody jsou Äasto vnitÅ™nÃ­ promÄ›nnÃ© metody uloÅ¾eny prÃ¡vÄ› zde.
Po skonÄenÃ­ danÃ© metody se ze stacku automaticky maÅ¾ou.
Pokud volÃ¡me metodu rekurzivnÄ›, zÅ¯stÃ¡vajÃ­ vÅ¡echny zdroje alokovanÃ© a mÅ¯Å¾e tak postupnÄ› dojÃ­t k vyÄerpÃ¡nÃ­ mÃ­sta ve stacku.

Java nemÃ¡ podporu pro chytrÃ© ukazatele jako C++, protoÅ¾e sprÃ¡va pamÄ›ti je Å™eÅ¡ena garbage collectorem.
MÃ­sto toho Java pouÅ¾Ã­vÃ¡ silnÃ© a slabÃ© reference.
Ty mohou bÃ½t uÅ¾iteÄnÃ© v pÅ™Ã­padÄ›, Å¾e chceme, aby garbage collector mohl uvolnit objekt, pokud na nÄ›j neexistuje silnÃ¡
reference.

V C++ mÃ¡ programÃ¡tor plnou kontrolu nad alokacÃ­ a dealokacÃ­ pamÄ›ti pomocÃ­ operÃ¡torÅ¯ `new` a `delete`.
ManuÃ¡lnÃ­ sprÃ¡va pamÄ›ti je vÃ½konnÄ›jÅ¡Ã­, ale nese s sebou rizika memory leaks a dangling pointers.
C++ 11 a novÄ›jÅ¡Ã­ verze poskytujÃ­ chytrÃ© ukazatele (smart pointers) jako:

- `std::unique_ptr`: jeden ukazatel na objekt v celÃ© aplikaci (dÃ­ky tomu se zvÄ›tÅ¡uje bezpeÄnost. TÃ­m Å¾e se napÅ™Ã­klad
  jednÃ© tÅ™Ã­dÄ› pÅ™edÃ¡vajÃ­ v parametru ukazatele, tak s tÄ›mi objekty mÅ¯Å¾e pracovat jen ta tÅ™Ã­da)
- `std::shared_ptr`: slouÅ¾Ã­ k automatickÃ©mu mazÃ¡nÃ­ - v podstatÄ› je to stejnÃ© jako Garbage collector - jakmile zanikne
  poslednÃ­ shared pointer na objekt, tak se automaticky smaÅ¾e z heapu
- `std::weak_ptr`: pouÅ¾Ã­vÃ¡ se v kombinaci se shared pointer. Po smazÃ¡nÃ­ vÅ¡ech shared pointerÅ¯ se smaÅ¾e objekt, ale
  weak pointer zÅ¯stÃ¡vÃ¡ - ukazuje na prÃ¡zdnÃ© mÃ­sto v pamÄ›ti. To proÄ se weak pointer pouÅ¾Ã­vÃ¡ je ten, Å¾e kdyÅ¾ pouÅ¾ijeme
  unique nebo shared, tak uÅ¾ nemÅ¯Å¾eme pouÅ¾Ã­t klasickÃ½ ukazatel.

Tyto chytrÃ© ukazatele pomÃ¡hajÃ­ automatizovat sprÃ¡vu pamÄ›ti a minimalizujÃ­ chyby spojenÃ© s ruÄnÃ­ sprÃ¡vou pamÄ›ti.

#### PorovnÃ¡nÃ­ stylÅ¯ sprÃ¡vy pamÄ›ti

`S Garbage Collection`

- **VÃ½hody**:
    - *ZjednoduÅ¡enÃ¡ sprÃ¡va pamÄ›ti*: Java vÃ½vojÃ¡Å™i nemusÃ­ ruÄnÄ› spravovat alokaci a dealokaci pamÄ›ti, coÅ¾ sniÅ¾uje
      kognitivnÃ­ zÃ¡tÄ›Å¾ a sniÅ¾uje riziko memory leakÅ¯.
    - *AutomatickÃ© uvolÅˆovÃ¡nÃ­ pamÄ›ti*: Garbage collector automaticky uvolÅˆuje pamÄ›Å¥, kterÃ¡ jiÅ¾ nenÃ­ vyuÅ¾Ã­vÃ¡na, coÅ¾
      pomÃ¡hÃ¡ pÅ™edchÃ¡zet overflow a zajiÅ¡Å¥uje efektivnÃ­ vyuÅ¾itÃ­ zdrojÅ¯.
    - *BezpeÄnost*: AutomatickÃ¡ sprÃ¡va pamÄ›ti v JavÄ› pomÃ¡hÃ¡ pÅ™edchÃ¡zet bÄ›Å¾nÃ½m programovacÃ­m chybÃ¡m, jako jsou dangling
      pointers a dvojitÃ© uvolnÄ›nÃ­, kterÃ© mohou bÃ½t potenciÃ¡lnÃ­mi bezpeÄnostnÃ­mi riziky.
- **NevÃ½hody**:
    - *VÃ½konnostnÃ­ reÅ¾ie*: Garbage collector mÅ¯Å¾e spotÅ™ebovÃ¡vat hodnÄ› vÃ½konu. NaÄasovÃ¡nÃ­ garbage collection je
      nepÅ™edvÃ­datelnÃ©, coÅ¾ mÅ¯Å¾e vÃ©st k pauzÃ¡m v provÃ¡dÄ›nÃ­ programu, coÅ¾ ovlivÅˆuje vÃ½kon, zejmÃ©na v aplikacÃ­ch v reÃ¡lnÃ©m
      Äase.
    - *MenÅ¡Ã­ kontrola*: VÃ½vojÃ¡Å™i majÃ­ omezenou kontrolu nad naÄasovÃ¡nÃ­m a provozem garbage collectoru, coÅ¾ mÅ¯Å¾e bÃ½t
      nevÃ½hodou ve scÃ©nÃ¡Å™Ã­ch, kde je vyÅ¾adovÃ¡na pÅ™esnÃ¡ sprÃ¡va pamÄ›ti a je to horÅ¡Ã­ pro optimalizovÃ¡nÃ­.

`Bez Garbage Collection`

- **VÃ½hody**:
    - *VÄ›tÅ¡Ã­ kontrola*: ProgramÃ¡toÅ™i v C++ majÃ­ explicitnÃ­ kontrolu nad alokacÃ­ a dealokacÃ­ pamÄ›ti, coÅ¾ umoÅ¾Åˆuje
      optimalizovat vyuÅ¾itÃ­ pamÄ›ti a vÃ½kon pro konkrÃ©tnÃ­ potÅ™eby. (Doom optimalizace)
    - *VÃ½kon*: DÃ­ky ruÄnÃ­ sprÃ¡vÄ› pamÄ›ti mÅ¯Å¾e C++ dosÃ¡hnout vyÅ¡Å¡Ã­ho vÃ½konu tÃ­m, Å¾e se vyhne reÅ¾ii spojenÃ© s garbage
      collection, coÅ¾ je zÃ¡sadnÃ­ pro systÃ©my, kde jsou klÃ­ÄovÃ© vÃ½kon a nÃ­zkÃ¡ latence.

- **NevÃ½hody**:
    - *ZvÃ½Å¡enÃ¡ sloÅ¾itost*: PoÅ¾adavek na ruÄnÃ­ sprÃ¡vu pamÄ›ti zvyÅ¡uje sloÅ¾itost kÃ³du a vyÅ¾aduje vyÅ¡Å¡Ã­ ÃºroveÅˆ pozornosti od
      vÃ½vojÃ¡Å™Å¯, coÅ¾ mÅ¯Å¾e vÃ©st k chybÃ¡m.
    - *Riziko ÃºnikÅ¯ pamÄ›ti a chyb*: RuÄnÃ­ sprÃ¡va pamÄ›ti pÅ™inÃ¡Å¡Ã­ riziko ÃºnikÅ¯ pamÄ›ti, visÃ­cÃ­ch ukazatelÅ¯ a dalÅ¡Ã­ch
      souvisejÃ­cÃ­ch chyb, pokud nenÃ­ sprÃ¡vnÄ› zvlÃ¡dnuta, coÅ¾ mÅ¯Å¾e zpÅ¯sobit pÃ¡d aplikace nebo nepÅ™edvÃ­datelnÃ© chovÃ¡nÃ­.
