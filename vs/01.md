<div align="center" style="margin-top: 16px;">
    <strong>Ot치zka 1</strong>
</div>

<nav style="
    position: sticky;
    top: 0;
    z-index: 100;
    background: rgba(0,0,0,0.8);
    padding: 8px 0 4px 0;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    text-align: center;
">
    <a href="12.md" style="color:white; text-decoration:none; margin: 0 16px;">拘勇 P콏edchoz칤</a>
    <a href="../README.md" style="color:white; text-decoration:none; margin: 0 16px;">游 Dom콢</a>
</nav>

# Algoritmy a jejich implementace, typy dat

<span style="background:#fffde7; color:#f9a825; padding:2px 8px; border-radius:4px; font-weight:bold;">游리 D콢le쬴t치 ot치zka 5</span>  

> [!TIP]Ot치zka
> Realizace algoritm콢 v r치mci z치v캩re캜n칠 pr치ce, pou쬴t칠 algoritmy a alternativy jejich implementace; n치vrh a zpracov치n칤 dat r콢zn칳ch typ콢 v r치mci z치v캩re캜n칠 pr치ce a souvisej칤c칤 konverze dat; programov칠 moduly a jejich pou쬴t칤.

---

## Slo쬴tost
Vyjad콏uje n치ro캜nost algoritmu na v칳po캜etn칤 prost콏edky po캜칤ta캜e v z치vislosti na d칠lce vstupn칤ch dat

### 캛asov치 slo쬴tost
Ud치v치 jak se doba b캩hu algoritmu m캩n칤 s velikost칤 vstupn칤ch dat
Z칤sk치v치 se anal칳zou algoritm콢, jejim v칳sledkem je 캜asov치 slo쬴tost
Zna캜칤me pomoc칤 **O()**

#### 1. Konstantn칤
- O(1)
- Doba b캩hu nezav칤s칤 na velikosti vstupu
```Python
def get_first_element(elements):
    return elements[0] if elements else None
```


#### 2. Logaritmick치
- O(log n)
- Doba b캩hu roste logaritmicky s velikost칤 vstupu
```Python
def binary_search(arr, target):
    low, high = 0, len(arr) - 1
    while low <= high:
        mid = (low + high) // 2
        if arr[mid] < target:
            low = mid + 1
        elif arr[mid] > target:
            high = mid - 1
        else:
            return mid
    return -1
```

#### 3. Line치rn칤
- O(n)
- Doba b캩hu roste line치rn캩 s velikost칤 vstupu
```Python
def find_max(arr):
    max_value = arr[0]
    for num in arr:
        if num > max_value:
            max_value = num
    return max_value
```

#### 4. Line치rn캩-logaritmick치
- O(n*log n)
- Doba b캩hu roste podle n*log n
```Python
def sort_array(arr):
    return sorted(arr)
```

#### 5. Kvadratick치
- O(n<sup>2</sup>)
- Doba b캩hu roste kvadraticky s velikostn칤 vstupu
```Python
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
    return arr
```

#### 6. Exponenci치ln칤
- O(2<sup>n</sup>)
- Doba b캩hu roste exponenci치ln캩
```Python
def fibonacci(n):
    if n <= 1:
        return n
    else:
        return fibonacci(n-1) + fibonacci(n-2)
```

<img src="img/o_complexity.png" alt="o_complexity_diagram" width="450">

Obecn캩 rozli코ujeme 캜asovou slo쬴tost v nejlep코칤m, nejhor코칤m a pr콢m캩rn칠m p콏칤pad캩
**P콏칤klad:**
- **Nejlep코칤 p콏칤pad**
  - O(1)
  - Hledan칳 prvek je na prvn칤m m칤st캩 v poli
- **Nejhor코칤 p콏칤pad**
  - O(n)
  - Prvek se nach치z칤 na posledn칤m m칤st캩 v poli nebo se nenach치z칤 v콢bec
- **Pr콢m캩rn치**
  - O(n/2)
  - asymptoticky O(n)
```Java
static int find(int[] arr, int x) {
  for (int i = 0; i < arr.length; i++) {
    if (x==arr[i]) return i;
  return -1;
  }
}
```

### Prostorov치 slo쬴tost
Ud치v치 kolik pam캩ti algoritmus pot콏ebuje vzhledem k velikosti vstupn칤ch dat

#### 1. Konstantn칤
- O(1)
- Pot콏ebuje konstantn칤 mno쬽tv칤 pam캩tu

#### 2. Line치rn칤
- O(n)
- Pot콏ebuje pam캩콘 칰m캩rnou velikost칤 vstupu

#### 3. Kvadratick치
- O(n<sup>2</sup>)
- Pot콏ebuje pam캩t 칰m캩rnou druh칠 mocnin캩 velikosti vstupu

## Standardn칤 algoritmy

### 콎ad칤c칤 algoritmy

#### 1. Bubble Sort
- Opakovan칠 proch치z칤 seznam, porovn치v치 sousedn칤 prvky a vym캩켿uje je, pokud nejsou ve spr치vnem po콏ad칤
- Slo쬴tost O(n<sup>2</sup>)
<img src="img/bubble_sort.png" alt="bubble_sort" width="450">

#### 2. Quick Sort
- Rozd캩l칤 seznam na dv캩 캜치sti podle pivotn칤ho prvku a rekurzivn캩 t콏칤d칤 ob캩 캜치sti
- Pivot se m콢쬰 volit n치hodn캩, prost콏edn칤 prvek v seznamu, posledn칤 prvek nebo prvn칤 prvek
- Slo쬴tost O(n*log n), nejh콢콏e O(n<sup>2</sup>)
<img src="img/quick_sort.png" alt="quick_sort" width="450">

#### 3. Merge Sort
- Rekurzivn캩 rozd캩luje seznam na poloviny a pot칠 je vlo쮂 do se콏azen칠ho seznamu
- Slo쬴tost O(n*log n)
<img src="img/merge_sort.png" alt="merge_sort" width="450">

#### 4. Selection Sort
- Rozd캩l칤 si pole na dv캩 캜치st칤 (set콏칤d캩n치 a neset콏칤d캩n치)
- Opakovan캩 hled치 nejmen코칤 prvek v neset콏칤d캩n칠 캜치sti a p콏esouv치 ho na spr치vnou pozici v set콏칤d캩n칠 캜치sti
- Slo쬴tost O(n<sup>2</sup>)
<img src="img/selection_sort.jpg" alt="selection_sort" width="450">

#### 5. Insertion Sort
- Postupn캩 se vytv치콏칤 set콏칤d캩n치 캜치st a p콏id치v치 do n칤 prvky jeden po druh칠m a umis콘uje je na spr치vn칠 m칤sto
- Prvek je porovn치n s p콏edchoz칤mi prvky a p콏esunut na spr치vnou pozici
- Slo쬴tost O(n) v nejlep코칤m p콏칤pad캩, O(n<sup>2</sup>) v nejhor코칤m a pr콢m캩rn칠m
<img src="img/insertion_sort.png" alt="insertion_sort" width="450">

### Hledac칤 algoritmy

#### 1. Sekven캜n칤
- Proch치z칤 v코echny prvky, dokud nenalezne hledan칳 prvek
- Slo쬴tost O(n)
<img src="img/linear_search.png" alt="linear_search" width="450">

#### 2. Bin치rn칤
- Funguje pouze na se콏azen칠m poli
- D캩l칤 seznam na poloviny a rozhoduje, ve kter칠 캜치sti hled치t d치l
- Slo쬴tost O(n*log n)
<img src="img/binary_search.png" alt="binary_search" width="450">

### Grafov칠 algoritmy

#### 1. Hled치n칤 do hloubky (DFS)
- Proch치z칤 graf do hloubky
- Pou쮂셨치 se z치sobn칤k nebo rekurze
- Slo쬴tost O(V+E), V - po캜et vrchol콢, E - po캜et hran

#### 2. Hled치n칤 do 코칤콏ky (BFS)
- Proch치z칤 graf do 코칤콏ky
- Pou쮂셨치 se fronta
- Slo쬴tost O(V+E)

<img src="img/bfs_dfs.png" alt="bfs_dfs" width="450">

## Programov칠 moduly
Programov칠 moduly umo쮄갓j칤 rozd캩len칤 k칩du do mal칳ch, snadno spraviteln칳ch a znovupou쬴teln칳ch 캜치st칤.
Jsou 캜asto poskytov치ny ve form캩 knihoven nebo framework콢, kter칠 poskytuj칤 p콏eddefinovan칠 funkce a slu쬭y.

### Vlastnosti
- **Modularita**
  - Rozd캩len칤 velk칳ch program콢 na men코칤 캜치sti
  - Ka쬯칳 modul je samostatn치 jednotka, kter치 implementuje specifickou 캜치st aplikace

- **Zapouzd콏en칤**
  - Moduly skr칳vaj칤 svou intern칤 implementaci a posyktuj칤 ve콏ejn칠 rozhran칤 (API)
  - Zvy코uje bezpe캜nost

- **Opakovan치 pou쬴telnost**
  - Pokud je modul napsan칳 obecn캩, m콢쬰me ho pou쮂셦 ve v칤ce projektech bez nutnosti zm캩ny k칩du

- **Testovatelnost**
  - Testov치n칤 jednotliv칳ch 캜치st칤 aplikace nez치visle na zbytku syst칠mu

### Pou쬴t칤
- **Modul치rn칤 architektura**
  - Rozd캩len칤 funk캜nosti aplikace do mal칳ch mod콢lu, kter칠 spravuj칤 jednu 캜치st
  - Usnad켿uje 코k치lov치n칤 a spr치vu
  - Moduly umo쮄갓j칤 rozd캩lit v칳voj mezi jednotlivce, kte콏칤 budou pracovat jen na dan칠m modulu

- **Knihovna**
  - Knihovny jsou soubory p콏edem definovan칠ho k칩du, kter칠 poskytuj칤 sady funkc칤
  - M콢쬰me je jednodu코e vlo쬴t do projektu
  - V캩t코칤nou jsou voln칠 p콏칤stupn칠 a m콢쬰me se pod칤let na jejich vylep코en칤ch (nap콏. kdy reportneme bug)
  - **P콏칤klady:**
    - **Python**
     ```python
     import numpy as np # Knihovna pro pr치ci s vektory a maticemi

     # Vytvo콏en칤 pole
     a = np.array([1, 2, 3, 4, 5])
     print("Pole a:", a)

     # V칳po캜et pr콢m캩ru
     mean = np.mean(a)
     print("Pr콢m캩r:", mean)
     ```

    - **Java**
    ```Java
     import java.util.Random; // Import generov치n칤 pseudon치hodn칳ch 캜칤sel

     public class Main {
         public static void main(String[] args) {
             Random random = new Random();

             // Generov치n칤 n치hodn칠ho cel칠ho 캜칤sla
             int randomInt = random.nextInt(100); // n치hodn칠 캜칤slo mezi 0 (v캜etn캩) a 100
             System.out.println("N치hodn칠 cel칠 캜칤slo: " + randomInt);
        }
     }
    ```

    - **C++**
    ```C++
     #include <iostream>
     #include <vector> // Import vektoru - pole, kter칠 m콢쬰me zv캩t코ovat a zmen코ovat
     #include <algorithm> // Import standardn칤ch algoritm콢

     int main() {
         std::vector<int> vec = {5, 2, 8, 1, 3};

         // Se콏azen칤 vektoru
         std::sort(vec.begin(), vec.end());
         std::cout << "Se콏azen칳 vektor: ";
         for(int n : vec) {
             std::cout << n << " ";
         }
         std::cout << std::endl;

         return 0;
     }
    ```

- **Framework**
  - Framework je struktorovan칠 prost콏ed칤, kter칠 poskytuje n치stroje pro v칳voj softw치rov칳ch aplikac칤
  - Obsahuj칤 sadu p콏edp콏ipraven칳ch modul콢
  - **P콏칤klady**
    - **Flask**
      - Framework pro webov칠 aplikace v Pythonu
      - Vhodn칳 pro mal칠 a st콏edn칤 webov칠 aplikace
      ```Python
      # Vytv치콏칤 jednoduchou web aplikaci, kter치 na localhost:5000 zobraz칤 "Hello World!"
      from flask import Flask

      app = Flask(__name__)

      @app.route('/')
      def hello_world():
        return 'Hello World!'

      if __name__ == '__main__':
        app.run(debug=True)
      ```

    - **Spring**
      - Framework pro v칳voj backendu v Java
      ```Java
      // Vytvo콏칤 web aplikaci, kter치 na localhost:8080 zobraz칤 text "Hello World!"
      import org.springframework.boot.SpringApplication;
      import org.springframework.boot.autoconfigure.SpringBootApplication;
      import org.springframework.web.bind.annotation.GetMapping;
      import org.springframework.web.bind.annotation.RestController;

      @SpringBootApplication
      public class DemoApplication {

        public static void main(String[] args) {
          SpringApplication.run(DemoApplication.class, args);
        }
      }

      @RestController
      class HelloController {
        @GetMapping("/")
          public String hello() {
            return "Hello World!";
          }
      }
      ```

    - **React**
      - Framework pro tvorbu u쬴vatelsk칠ho rozhran칤 (front-end)
      ```javascript
      // Na str치nce se zobraz칤 "Hello World!"
      import React from 'react';
      import ReactDOM from 'react-dom';

      function App() {
        return (
          <div>
            <h1>Hello World!</h1>
          </div>
        );
      }

      ReactDOM.render(<App />, document.getElementById('root'));
      ```



 
