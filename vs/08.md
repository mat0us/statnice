<div align="center" style="margin-top: 16px;">
    <strong>OtÃ¡zka 8</strong>
</div>

<nav style="
    position: sticky;
    top: 0;
    z-index: 100;
    background: rgba(0,0,0,0.8);
    padding: 8px 0 4px 0;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    text-align: center;
">
    <a href="07.md" style="color:white; text-decoration:none; margin: 0 16px;">â¬…ï¸ PÅ™edchozÃ­</a>
    <a href="../README.md" style="color:white; text-decoration:none; margin: 0 16px;">ğŸ  DomÅ¯</a>
    <a href="09.md" style="color:white; text-decoration:none; margin: 0 16px;">NÃ¡sledujÃ­cÃ­ â¡ï¸</a>
</nav>

# PÅ™enositelnÃ½ nÃ¡vrh v jazyce C#

> [!TIP]OtÃ¡zka
> Implementace mechanismÅ¯ zvyÅ¡ujÃ­cÃ­ch pÅ™enositelnost kÃ³du a zvyÅ¡ujÃ­cÃ­ch obecnost kÃ³du: rozhranÃ­ (existujÃ­cÃ­ v .NET), genericita, delegÃ¡ti, abstraktnÃ­ tÅ™Ã­dy

---

## Co je to pÅ™enositelnÃ½ a obecnÃ½ kÃ³d?

PÅ™edstavte si, Å¾e jste programÃ¡tor, kterÃ½ prÃ¡vÄ› dokonÄil aplikaci pro sprÃ¡vu knihovny. VaÅ¡e aplikace umoÅ¾Åˆuje evidovat knihy, sledovat jejich dostupnost a spravovat vÃ½pÅ¯jÄky. VÅ¡echno funguje skvÄ›le, dokud za vÃ¡mi nepÅ™ijde klient s poÅ¾adavkem: "PotÅ™ebujeme podobnÃ½ systÃ©m, ale pro sprÃ¡vu DVD a her." 

Najednou se ocitÃ¡te pÅ™ed otÃ¡zkou: MusÃ­te vÅ¡echno pÅ™epsat znovu? Nebo existuje zpÅ¯sob, jak vyuÅ¾Ã­t vÄ›tÅ¡inu pÅ¯vodnÃ­ho kÃ³du i pro novÃ© ÃºÄely? 

**Jak toho dosÃ¡hneme?**

MÃ¡me ÄtyÅ™i hlavnÃ­ nÃ¡stroje: abstraktnÃ­ tÅ™Ã­dy, rozhranÃ­, genericitu a delegovÃ¡nÃ­. KaÅ¾dÃ½ Å™eÅ¡Ã­ jinÃ½ typ problÃ©mu.

**HlavnÃ­ cÃ­le:**

- **ZnovupouÅ¾itelnost** - napsat jednou, pouÅ¾Ã­t vÃ­cekrÃ¡t
- **ÃšdrÅ¾bovatelnost** - zmÄ›ny na jednom mÃ­stÄ› se projevÃ­ vÅ¡ude
- **RozÅ¡iÅ™itelnost** - snadno pÅ™idat novÃ© funkcionality
- **Flexibilita** - pÅ™izpÅ¯sobit se rÅ¯znÃ½m poÅ¾adavkÅ¯m

## AbstraktnÃ­ tÅ™Ã­dy [<kbd>Link</kbd>](https://www.geeksforgeeks.org/abstract-classes-in-java/)

AbstraktnÃ­ tÅ™Ã­da je typ tÅ™Ã­dy, kterÃ½ neumoÅ¾Åˆuje vytvÃ¡Å™et objekty (instance). SlouÅ¾Ã­ jako pÅ™edpis pro dalÅ¡Ã­ podtÅ™Ã­dy odvozenÃ© pomocÃ­ dÄ›diÄnosti. Lze tedy Å™Ã­ci, Å¾e se jednÃ¡ o Å¡ablonu pro vytvÃ¡Å™enÃ­ specifickÃ© skupiny tÅ™Ã­d.

AbstraktnÃ­ tÅ™Ã­da mÅ¯Å¾e obsahovat jak abstraktnÃ­ metody (definuje se pouze hlaviÄka â€“ nÃ¡vratovÃ½ typ, nÃ¡zev, parametry), tak i obyÄejnÃ©. Pouze obyÄejnÃ© metody smÃ­ mÃ­t tÄ›lo. U abstraktnÃ­ch se tÄ›lo definuje aÅ¾ u potomka. AbstraktnÃ­ metoda je v jistÃ©m smyslu opakem metody finÃ¡lnÃ­.
NejenÅ¾e je moÅ¾nÃ© ji v odvozenÃ© tÅ™Ã­dÄ› pÅ™ekrÃ½t, je to dokonce nutnÃ© (pokud tato podtÅ™Ã­da nenÃ­ takÃ© abstraktnÃ­).
Jinak se program nepÅ™eloÅ¾Ã­. Takto mÅ¯Å¾eme programÃ¡tora pÅ™inutit, aby pÅ™i pouÅ¾itÃ­ naÅ¡Ã­ tÅ™Ã­dy jako rodiÄovskÃ© naprogramoval urÄenÃ© metody.

Pro oznaÄenÃ­ abstraktnÃ­ metody nebo tÅ™Ã­dy slouÅ¾Ã­ klÃ­ÄovÃ© slovo `abstract`. JakÃ¡koliv podtÅ™Ã­da smÃ­ najednou dÄ›dit pouze z jednÃ© abstraktnÃ­ tÅ™Ã­dy.

### PÅ™Ã­klad abstraktnÃ­ tÅ™Ã­dy a jejÃ­ podtÅ™Ã­dy Java:

```java
// abstraktnÃ­ tÅ™Ã­da
public abstract class Animal {
    private int weight;

    public Animal(int kg) {
        this.weight = kg;
    }

    public abstract String animalSound();

    public int neededFood() {
        return weight * 2;
    }
}
```

```java
// konkrÃ©tnÃ­ tÅ™Ã­da (podtÅ™Ã­da dÄ›dÃ­cÃ­ z abstraktnÃ­ tÅ™Ã­dy)
public class Parrot extends Animal {
    public Parrot() {
        super(10);
    }

    @Override
    public String animalSound() {
        return "Kra?";
    }
}
```

### PÅ™Ã­klad abstraktnÃ­ tÅ™Ã­dy a jejÃ­ podtÅ™Ã­dy C++:
``` cpp
#include <iostream>
#include <string>

// AbstraktnÃ­ tÅ™Ã­da
class Animal {
protected:
    int weight;

public:
    Animal(int kg) : weight(kg) {}

    // ÄŒistÄ› virtuÃ¡lnÃ­ metoda = abstraktnÃ­ metoda
    virtual std::string animalSound() const = 0;

    int neededFood() const {
        return weight * 2;
    }

    // VirtuÃ¡lnÃ­ destruktor pro sprÃ¡vnÃ© mazÃ¡nÃ­ odvozenÃ½ch objektÅ¯ pÅ™es ukazatel na zÃ¡kladnÃ­ tÅ™Ã­du
    virtual ~Animal() = default;
};
```

``` cpp
// KonkrÃ©tnÃ­ tÅ™Ã­da dÄ›dÃ­cÃ­ z abstraktnÃ­ tÅ™Ã­dy
class Parrot : public Animal {
public:
    Parrot() : Animal(10) {}

    std::string animalSound() const override {
        return "Kra?";
    }
};
```

## RozhranÃ­ [<kbd>Link</kbd>](https://www.geeksforgeeks.org/interfaces-in-java/)

RozhranÃ­ je souhrn informacÃ­, kterÃ½mi tÅ™Ã­da specifikuje, co by o nÃ­ okolÃ­ mÄ›lo vÄ›dÄ›t a jakÃ½m zpÅ¯sobem je moÅ¾nÃ© s nÃ­
komunikovat. Pro rozhranÃ­ je v jazyce Java zavedena speciÃ¡lnÃ­ konstrukce â€“ `interface`. RozhranÃ­ definuje soubor metod, kterÃ© v nÄ›m ale nejsou implementovÃ¡ny, tj. v deklaraci je pouze hlaviÄka metody, stejnÄ› jako je to u abstraktnÃ­ metody. TÅ™Ã­da, kterÃ¡ toto rozhranÃ­ implementuje (tj. jakoby dÄ›dÃ­), musÃ­ implementovat (tj. jakoby pÅ™ekrÃ½t) vÅ¡echny jeho metody. TÅ™Ã­da mÅ¯Å¾e implementovat neomezenÃ© mnoÅ¾stvÃ­ rozhranÃ­.

RozhranÃ­ je vhodnÃ© pouÅ¾Ã­vat jako datovÃ½ typ parametrÅ¯ metod a pÅ™i deklaraci promÄ›nnÃ½ch. Potom vÅ¡ude tam, kde je uvedeno rozhranÃ­ jako datovÃ½ typ, je oÄekÃ¡vÃ¡na instance jakÃ©koliv tÅ™Ã­dy implementujÃ­cÃ­ toto rozhranÃ­.

RozhranÃ­ pouÅ¾ijeme, kdyÅ¾ potÅ™ebujeme definovat spoleÄnÃ© chovÃ¡nÃ­ pro rÅ¯znÃ© tÅ™Ã­dy, kterÃ© nemajÃ­ spoleÄnÃ©ho pÅ™edka. To mÅ¯Å¾e nastat v nÃ¡sledujÃ­cÃ­ch pÅ™Ã­padech:

- **ObtÃ­Å¾nost zaÄlenÄ›nÃ­**: TÅ™Ã­dy majÃ­ podobnÃ© chovÃ¡nÃ­, ale jejich zaÄlenÄ›nÃ­ do spoleÄnÃ©ho pÅ™edka by bylo umÄ›lÃ© nebo nevhodnÃ©.
- **NemoÅ¾nost dÄ›diÄnosti**: TÅ™Ã­dy jiÅ¾ dÄ›dÃ­ z knihovnÃ­ch tÅ™Ã­d, kterÃ© nemÅ¯Å¾eme upravit, a proto nemÅ¯Å¾eme vytvoÅ™it spoleÄnÃ©ho pÅ™edka.

Od Javy 8 mohou rozhranÃ­ obsahovat i vÃ½chozÃ­ (default) metody, kterÃ© obsahujÃ­cÃ­ implementaci, ne jen hlaviÄku.
TÅ™Ã­da, kterÃ¡ implementuje toto rozhranÃ­, tak zÃ­skÃ¡ i tuto funkcionalitu â€“ jednÃ¡ se tak v podstatÄ› o vÃ­cenÃ¡sobnou
dÄ›diÄnost.

```java
// Interface for shape
public interface Shape {
    double calculateArea();
    double calculatePerimeter();
}

// Interface for rectangular types
public interface Rectangular {
    default String getType() {
        return "Rectangular shape";
    }
}
```

```java
// Square class implementing Shape and Rectangular
public class Square implements Shape, Rectangular {
    private double side;

    public Square(double side) {
        this.side = side;
    }

    @Override
    public double calculateArea() {
        return side * side;
    }

    @Override
    public double calculatePerimeter() {
        return 4 * side;
    }
}

// Circle class implementing only Shape
public class Circle implements Shape {
    private double radius;

    public Circle(double radius) {
        this.radius = radius;
    }

    @Override
    public double calculateArea() {
        return Math.PI * radius * radius;
    }

    @Override
    public double calculatePerimeter() {
        return 2 * Math.PI * radius;
    }

    @Override
    public String toString() {
        return "Circle with radius " + radius;
    }
}
```
### PÅ™Ã­klad rozhranÃ­ a jeho implementace v C++:
```cpp
#include <iostream>
#include <cmath>
#include <string>

// Abstract base class representing a Shape
class Shape {
public:
    virtual double calculateArea() const = 0;
    virtual double calculatePerimeter() const = 0;
    virtual ~Shape() = default;
};

// Interface-like base class for Rectangular types
class Rectangular {
public:
    virtual std::string getType() const {
        return "Rectangular shape";
    }

    virtual ~Rectangular() = default;
};
```

```cpp
// Square implements Shape and Rectangular
class Square : public Shape, public Rectangular {
private:
    double side;

public:
    Square(double side) : side(side) {}

    double calculateArea() const override {
        return side * side;
    }

    double calculatePerimeter() const override {
        return 4 * side;
    }
};

// Circle implements only Shape
class Circle : public Shape {
private:
    double radius;

public:
    Circle(double radius) : radius(radius) {}

    double calculateArea() const override {
        return M_PI * radius * radius;
    }

    double calculatePerimeter() const override {
        return 2 * M_PI * radius;
    }

    std::string toString() const {
        return "Circle with radius " + std::to_string(radius);
    }
};
```

## DelegÃ¡ti

DelegovÃ¡nÃ­ je nÃ¡vrhovÃ½ vzor, kterÃ½ se pouÅ¾Ã­vÃ¡ jako nÃ¡hrada dÄ›diÄnosti. Pokud pracujeme s objektovÄ›-orientovanÃ½m softwarem a pouÅ¾Ã­vÃ¡me cizÃ­ (ne nÃ¡mi napsanÃ©) knihovny, dost Äasto se stÃ¡vÃ¡, Å¾e potÅ™ebujeme vyuÅ¾Ã­t tÅ™Ã­dy a objekty z tÃ©to knihovny. To nÃ¡s svÃ¡dÃ­ k tomu pouÅ¾Ã­t dÄ›diÄnost, podÄ›dit z knihovnÃ­ tÅ™Ã­dy a uspoÅ™it tak spoustu kÃ³du.
Tento postup je vÅ¡ak obecnÄ› oznaÄovÃ¡n za nevhodnÃ½ a Å¡patnÃ½.

DÄ›diÄnost bychom mÄ›li pouÅ¾Ã­vat pouze mezi tÅ™Ã­dami, nad kterÃ½mi mÃ¡me plnou kontrolu. Pokud nÄ›kdo zÃ¡sadnÃ­m zpÅ¯sobem zmÄ›nÃ­ tÅ™Ã­du, ze kterÃ© dÄ›dÃ­me a upravÃ­ modifikÃ¡tory viditelnosti tÃ©to tÅ™Ã­dy, mÅ¯Å¾eme pÅ™ijÃ­t o klÃ­Äovou metodu naÅ¡Ã­ tÅ™Ã­dy, kterou jiÅ¾ opakovanÄ› pouÅ¾Ã­vÃ¡me vÅ¡ude v aplikaci. Abychom tomuto zamezili a nemuseli pak pÅ™episovat kÃ³d celÃ© aplikace, pouÅ¾ijeme delegovÃ¡nÃ­.

PÅ™i delegovÃ¡nÃ­ mÃ¡me vÅ¾dy dvÄ› tÅ™Ã­dy:

- **naÅ¡i hlavnÃ­ tÅ™Ã­du**, kterÃ¡ pÅ™ijÃ­mÃ¡ poÅ¾adavky,
- **delegÃ¡te**, kterÃ½ poÅ¾adavky vyÅ™izuje.

Implementace delegovÃ¡nÃ­ tedy vypadÃ¡ tak, Å¾e mÃ¡me naÅ¡i vlastnÃ­ tÅ™Ã­du. Tato tÅ™Ã­da pomocÃ­ vazby kompozice obsahuje delegÃ¡ta. VÅ¡echny metody delegÃ¡ta jsou volÃ¡ny metodami naÅ¡Ã­ tÅ™Ã­dy. TÅ™Ã­da tedy mÃ¡ stejnÄ› pojmenovanÃ© metody se stejnÃ½mi hlaviÄkami a pouze v nich provolÃ¡vÃ¡ metody delegÃ¡ta.

Pokud dojde ke zmÄ›nÄ› delegÃ¡te, mÅ¯Å¾eme metodu pÅ™eimplementovat sami nebo mÅ¯Å¾eme zvolit jinÃ©ho delegÃ¡ta.

NÄ›kterÃ© programovacÃ­ jazyky (Kotlin, C#) majÃ­ podporu delegÃ¡tÅ¯ pÅ™Ã­mo ve standardnÃ­ knihovnÄ›. C# pÅ™Ã­mo obsahuje klÃ­ÄovÃ© slovo `delegate` a Kotlin mÃ¡ zase klÃ­ÄovÃ© slovo `by`. Implementace pomocÃ­ klÃ­ÄovÃ©ho slova `by` za nÃ¡s vytvoÅ™Ã­ vÅ¡echny potÅ™ebnÃ© metody a jejich provolÃ¡nÃ­ pÅ™es delegÃ¡ta, kterÃ© bychom jinak museli vytvoÅ™it ruÄnÄ› (v JavÄ› to musÃ­me udÄ›lat ruÄnÄ›.)

### PÅ™Ã­klad delegovÃ¡nÃ­ v Kotlinu:

```kotlin
// ukÃ¡zka delegace v Kotlinu
interface Base {
    fun print()
}

class BaseImpl(val x: Int) : Base {
    override fun print() {
        print(x)
    }
}

class Derived(b: Base) : Base by b

fun main() {
    val base = BaseImpl(10)
    Derived(base).print()
}
```

### PÅ™Ã­klad v JavÄ›

V JavÄ› musÃ­me delegovÃ¡nÃ­ implementovat manuÃ¡lnÄ› pomocÃ­ kompozice a explicitnÃ­ho provolÃ¡vÃ¡nÃ­ metod delegÃ¡ta:

```java
// KnihovnÃ­ tÅ™Ã­da, kterou nechceme dÄ›dit (mÅ¯Å¾e se zmÄ›nit)
class StringFormater {
    public String format(String text) {
        return text.toUpperCase();
    }
    
    public String addPrefix(String text, String prefix) {
        return prefix + text;
    }
    
    public int getLength(String text) {
        return text.length();
    }
}

// NaÅ¡e hlavnÃ­ tÅ™Ã­da, kterÃ¡ pouÅ¾Ã­vÃ¡ delegovÃ¡nÃ­
class CustomFormater {
    // DelegÃ¡t - instance knihovnÃ­ tÅ™Ã­dy
    private StringFormater delegate;
    
    public CustomFormater() {
        this.delegate = new StringFormater();
    }
    
    // Metody, kterÃ© provolÃ¡vajÃ­ delegÃ¡ta
    public String format(String text) {
        return delegate.format(text);
    }
    
    public String addPrefix(String text, String prefix) {
        return delegate.addPrefix(text, prefix);
    }
    
    public int getLength(String text) {
        return delegate.getLength(text);
    }
    
    // MÅ¯Å¾eme pÅ™idat vlastnÃ­ funkcionalitu
    public String formatWithTimestamp(String text) {
        String formatted = delegate.format(text);
        return "[" + System.currentTimeMillis() + "] " + formatted;
    }
    
    // MoÅ¾nost zmÄ›nit delegÃ¡ta za bÄ›hu
    public void setDelegate(StringFormater newDelegate) {
        this.delegate = newDelegate;
    }
}

// PouÅ¾itÃ­
public class DelegationExample {
    public static void main(String[] args) {
        CustomFormater formater = new CustomFormater();
        
        String text = "Hello World";
        System.out.println(formater.format(text));
        System.out.println(formater.addPrefix(text, ">>> "));
        System.out.println(formater.formatWithTimestamp(text));
        
        // ZmÄ›na delegÃ¡ta za bÄ›hu
        formater.setDelegate(new StringFormater() {
            @Override
            public String format(String text) {
                return text.toLowerCase();
            }
        });
        
        System.out.println(formater.format(text));
    }
}
```

### PÅ™Ã­klad v C++

V C++ pouÅ¾Ã­vÃ¡me podobnÃ½ pÅ™Ã­stup s kompozicÃ­ a smart pointery pro lepÅ¡Ã­ sprÃ¡vu pamÄ›ti:

```cpp
#include <iostream>
#include <memory>
#include <string>

// KnihovnÃ­ tÅ™Ã­da, kterou nechceme dÄ›dit (mÅ¯Å¾e se zmÄ›nit)
class FileProcessor {
public:
    std::string readFile(const std::string& filename) {
        return "Content of " + filename;
    }
    
    void writeFile(const std::string& filename, const std::string& content) {
        std::cout << "Writing to " << filename << ": " << content << std::endl;
    }
    
    bool fileExists(const std::string& filename) {
        return !filename.empty();
    }
    
    size_t getFileSize(const std::string& filename) {
        return filename.length() * 10; // simulace
    }
};

// NaÅ¡e hlavnÃ­ tÅ™Ã­da, kterÃ¡ pouÅ¾Ã­vÃ¡ delegovÃ¡nÃ­
class DocumentManager {
private:
    // DelegÃ¡t - instance knihovnÃ­ tÅ™Ã­dy
    std::unique_ptr<FileProcessor> delegate;
    
public:
    DocumentManager() : delegate(std::make_unique<FileProcessor>()) {}
    
    // ExplicitnÃ­ konstruktor s vlastnÃ­m delegÃ¡tem
    DocumentManager(std::unique_ptr<FileProcessor> processor) 
        : delegate(std::move(processor)) {}
    
    // Metody, kterÃ© provolÃ¡vajÃ­ delegÃ¡ta
    std::string readDocument(const std::string& filename) {
        return delegate->readFile(filename);
    }
    
    void saveDocument(const std::string& filename, const std::string& content) {
        delegate->writeFile(filename, content);
    }
    
    bool documentExists(const std::string& filename) {
        return delegate->fileExists(filename);
    }
    
    size_t getDocumentSize(const std::string& filename) {
        return delegate->getFileSize(filename);
    }
    
    // VlastnÃ­ funkcionalita nad delegÃ¡tem
    std::string readDocumentWithBackup(const std::string& filename) {
        if (delegate->fileExists(filename)) {
            std::string content = delegate->readFile(filename);
            // VytvoÅ™Ã­me zÃ¡lohu
            delegate->writeFile(filename + ".backup", content);
            return content;
        }
        return "File not found";
    }
    
    // MoÅ¾nost zmÄ›nit delegÃ¡ta za bÄ›hu
    void setProcessor(std::unique_ptr<FileProcessor> newProcessor) {
        delegate = std::move(newProcessor);
    }
    
    // Hybrid operace kombinujÃ­cÃ­ vÃ­ce volÃ¡nÃ­ delegÃ¡ta
    void processDocument(const std::string& filename) {
        if (delegate->fileExists(filename)) {
            std::string content = delegate->readFile(filename);
            size_t size = delegate->getFileSize(filename);
            
            std::cout << "Processing document: " << filename << std::endl;
            std::cout << "Size: " << size << " bytes" << std::endl;
            std::cout << "Content preview: " << content.substr(0, 50) << std::endl;
            
            // VlastnÃ­ logika
            delegate->writeFile(filename + ".processed", 
                               "PROCESSED: " + content);
        }
    }
};

// SpecializovanÃ½ delegÃ¡t pro demonstraci vÃ½mÄ›ny
class CompressedFileProcessor : public FileProcessor {
public:
    std::string readFile(const std::string& filename) override {
        return "COMPRESSED[" + FileProcessor::readFile(filename) + "]";
    }
    
    void writeFile(const std::string& filename, const std::string& content) override {
        std::cout << "Compressed writing to " << filename << ": " 
                  << content.substr(0, 20) << "..." << std::endl;
    }
};

// PouÅ¾itÃ­
int main() {
    // ZÃ¡kladnÃ­ pouÅ¾itÃ­ s vÃ½chozÃ­m delegÃ¡tem
    DocumentManager manager;
    
    std::cout << "=== ZÃ¡kladnÃ­ operace ===" << std::endl;
    std::cout << manager.readDocument("test.txt") << std::endl;
    manager.saveDocument("output.txt", "Hello World");
    manager.processDocument("test.txt");
    
    std::cout << "\n=== ZmÄ›na delegÃ¡ta ===" << std::endl;
    // ZmÄ›na delegÃ¡ta za bÄ›hu
    manager.setProcessor(std::make_unique<CompressedFileProcessor>());
    
    std::cout << manager.readDocument("test.txt") << std::endl;
    manager.saveDocument("compressed.txt", "This will be compressed");
    
    return 0;
}
```

## Genericita Java [<kbd>otÃ¡zka 5</kbd>](05.md)

Genericita (Generics) je jednou z nejdÅ¯leÅ¾itÄ›jÅ¡Ã­ch funkcionalit pÅ™idanÃ½ch do jazyka Java ve verzi 5.0, kterÃ¡ vÃ½raznÄ› zlepÅ¡uje typovou bezpeÄnost a umoÅ¾Åˆuje vytvÃ¡Å™enÃ­ opakovanÄ› pouÅ¾itelnÃ©ho kÃ³du . GenerickÃ¡ programovÃ¡nÃ­ umoÅ¾Åˆuje tvoÅ™it tÅ™Ã­dy, rozhranÃ­ a metody, kterÃ© mohou pracovat s rÅ¯znÃ½mi datovÃ½mi typy, pÅ™iÄemÅ¾ zachovÃ¡vajÃ­ typovou kontrolu v dobÄ› kompilace

Genericity vyuÅ¾Ã­vajÃ­ typovÃ© parametry oznaÄovanÃ© ÃºhlovÃ½mi zÃ¡vorkami <> pro definovÃ¡nÃ­ obecnÃ½ch typÅ¯, kterÃ© jsou pÅ™i pouÅ¾itÃ­ nahrazeny konkrÃ©tnÃ­mi typy . TÃ­mto zpÅ¯sobem lze vytvoÅ™it jednu implementaci, kterÃ¡ funguje s mnoha rÅ¯znÃ½mi datovÃ½mi typy, aniÅ¾ by bylo nutnÃ© obÄ›tovat typovou bezpeÄnost.

NejÄastÄ›ji pouÅ¾Ã­vanÃ© konvence pro typovÃ© parametry zahrnujÃ­ **T pro obecnÃ½ typ**, **E pro element v kolekcÃ­ch**, **K a V pro klÃ­Äe a hodnoty v mapÃ¡ch**, **a N pro ÄÃ­selnÃ© typy**. Tyto konvence zlepÅ¡ujÃ­ Äitelnost kÃ³du a usnadÅˆujÃ­ pochopenÃ­ ÃºÄelu jednotlivÃ½ch typovÃ½ch parametrÅ¯.

### PÅ™Ã­klad generickÃ© tÅ™Ã­dy v JavÄ›:

```java
public class Box<T> {
    private T value;
    
    public Box(T value) {
        this.value = value;
    }
    
    public T getValue() {
        return value;
    }
    
    public void setValue(T value) {
        this.value = value;
    }
}
```

PouÅ¾itÃ­ takovÃ© tÅ™Ã­dy je intuitivnÃ­ a poskytuje plnou typovou kontrolu 

```java
Box<String> stringBox = new Box<>("Ahoj svÄ›te!");
Box<Integer> intBox = new Box<>(42);
```

### GenerickÃ© tÅ™Ã­dy s vÃ­ce parametry

Pro sloÅ¾itÄ›jÅ¡Ã­ datovÃ© struktury lze definovat tÅ™Ã­dy s vÃ­ce typovÃ½mi parametry. TypickÃ½m pÅ™Ã­kladem je tÅ™Ã­da Pair<K, V> pro reprezentaci pÃ¡rÅ¯ klÃ­Ä-hodnota.

```java
public class Pair<K, V> {
    private final K key;
    private final V value;
    
    public Pair(K key, V value) {
        this.key = key;
        this.value = value;
    }
    
    public K getKey() { return key; }
    public V getValue() { return value; }
}
```
### BoundovanÃ© generickÃ© parametry

BoundovanÃ© typovÃ© parametry umoÅ¾ÅˆujÃ­ omezit typy, kterÃ© mohou bÃ½t pouÅ¾ity jako argumenty generickÃ½ch typÅ¯. Toto omezenÃ­ se definuje pomocÃ­ klÃ­ÄovÃ©ho slova `extends` a umoÅ¾Åˆuje volÃ¡nÃ­ metod definovanÃ½ch v bÃ¡zovÃ© tÅ™Ã­dÄ› nebo rozhranÃ­.

#### Upper bounded parametry

Upper bounded parametry omezujÃ­ typovÃ½ parametr na podtypy urÄitÃ© tÅ™Ã­dy nebo implementace rozhranÃ­. Syntaxe <T extends Type> zaruÄuje, Å¾e T je podtypem Type.

```java
public class NumberBox<T extends Number> {
    private T number;
    
    public NumberBox(T number) {
        this.number = number;
    }
    
    public double getDoubleValue() {
        return number.doubleValue(); // metoda z Number
    }
    
    public boolean isPositive() {
        return number.doubleValue() > 0;
    }
}
```
#### VÃ­cenÃ¡sobnÃ© bounds
Java umoÅ¾Åˆuje definovat vÃ­cenÃ¡sobnÃ© bounds pomocÃ­ operÃ¡toru `&`. TypovÃ½ parametr pak musÃ­ implementovat vÅ¡echny specifikovanÃ© typy.

```java
public class BoundedClass<T extends Number & Comparable<T>> {
    // T musÃ­ dÄ›dit z Number A implementovat Comparable
}
```

### GenerickÃ© metody
GenerickÃ© metody umoÅ¾ÅˆujÃ­ definovat typovÃ© parametry na Ãºrovni jednotlivÃ½ch metod nezÃ¡visle na tÅ™Ã­dÄ›, ve kterÃ© jsou definovÃ¡ny. TypovÃ© parametry se deklarujÃ­ pÅ™ed nÃ¡vratovÃ½m typem metody.

```java
public static <T> void swap(T[] array, int i, int j) {
    T temp = array[i];
    array[i] = array[j];
    array[j] = temp;
}

public static <T extends Comparable<T>> T findMax(T[] array) {
    T max = array[0];
    for (int i = 1; i < array.length; i++) {
        if (array[i].compareTo(max) > 0) {
            max = array[i];
        }
    }
    return max;
}
```