<div align="center" style="margin-top: 16px;">
    <strong>OtÃ¡zka 6</strong>
</div>

<nav style="
    position: sticky;
    top: 0;
    z-index: 100;
    background: rgba(0,0,0,0.8);
    padding: 8px 0 4px 0;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    text-align: center;
">
    <a href="07.md" style="color:white; text-decoration:none; margin: 0 16px;">â¬…ï¸ PÅ™edchozÃ­</a>
    <a href="../README.md" style="color:white; text-decoration:none; margin: 0 16px;">ğŸ  DomÅ¯</a>
    <a href="09.md" style="color:white; text-decoration:none; margin: 0 16px;">NÃ¡sledujÃ­cÃ­ â¡ï¸</a>
</nav>

# PÅ™enositelnÃ½ nÃ¡vrh v jazyce C#

**OtÃ¡zka:** Implementace mechanismÅ¯ zvyÅ¡ujÃ­cÃ­ch pÅ™enositelnost kÃ³du a zvyÅ¡ujÃ­cÃ­ch obecnost kÃ³du: rozhranÃ­ (existujÃ­cÃ­ v .NET), genericita, delegÃ¡ti, abstraktnÃ­ tÅ™Ã­dy

---

### AbstraktnÃ­ tÅ™Ã­dy

AbstraktnÃ­ tÅ™Ã­da je typ tÅ™Ã­dy, kterÃ½ neumoÅ¾Åˆuje vytvÃ¡Å™et objekty (instance).
SlouÅ¾Ã­ jako pÅ™edpis pro dalÅ¡Ã­ podtÅ™Ã­dy odvozenÃ© pomocÃ­ dÄ›diÄnosti.
Lze tedy Å™Ã­ci, Å¾e se jednÃ¡ o Å¡ablonu pro vytvÃ¡Å™enÃ­ specifickÃ© skupiny tÅ™Ã­d.

AbstraktnÃ­ tÅ™Ã­da mÅ¯Å¾e obsahovat jak abstraktnÃ­ metody (definuje se pouze hlaviÄka â€“ nÃ¡vratovÃ½ typ, nÃ¡zev, parametry),
tak i obyÄejnÃ©.
Pouze obyÄejnÃ© metody smÃ­ mÃ­t tÄ›lo.
U abstraktnÃ­ch se tÄ›lo definuje aÅ¾ u potomka.
AbstraktnÃ­ metoda je v jistÃ©m smyslu opakem metody finÃ¡lnÃ­.
NejenÅ¾e je moÅ¾nÃ© ji v odvozenÃ© tÅ™Ã­dÄ› pÅ™ekrÃ½t, je to dokonce nutnÃ© (pokud tato podtÅ™Ã­da nenÃ­ takÃ© abstraktnÃ­).
Jinak se program nepÅ™eloÅ¾Ã­.
Takto mÅ¯Å¾eme programÃ¡tora pÅ™inutit, aby pÅ™i pouÅ¾itÃ­ naÅ¡Ã­ tÅ™Ã­dy jako rodiÄovskÃ© naprogramoval
urÄenÃ© metody.

Pro oznaÄenÃ­ abstraktnÃ­ metody nebo tÅ™Ã­dy slouÅ¾Ã­ klÃ­ÄovÃ© slovo `abstract`.
JakÃ¡koliv podtÅ™Ã­da smÃ­ najednou dÄ›dit pouze z jednÃ© abstraktnÃ­ tÅ™Ã­dy.

```java
// abstraktnÃ­ tÅ™Ã­da
public abstract class Animal {
    private int weight;

    public Animal(int kg) {
        this.weight = kg;
    }

    public abstract String animalSound();

    public int neededFood() {
        return weight * 2;
    }
}

// konkrÃ©tnÃ­ tÅ™Ã­da (podtÅ™Ã­da dÄ›dÃ­cÃ­ z abstraktnÃ­ tÅ™Ã­dy)
public class Parrot extends Animal {
    public Parrot() {
        super(10);
    }

    @Override
    public String animalSound() {
        return "Kra?";
    }
}
```

### RozhranÃ­

RozhranÃ­ je souhrn informacÃ­, kterÃ½mi tÅ™Ã­da specifikuje, co by o nÃ­ okolÃ­ mÄ›lo vÄ›dÄ›t a jakÃ½m zpÅ¯sobem je moÅ¾nÃ© s nÃ­
komunikovat.
Pro rozhranÃ­ je v jazyce Java zavedena speciÃ¡lnÃ­ konstrukce â€“ `interface`.
RozhranÃ­ definuje soubor metod, kterÃ© v nÄ›m ale nejsou implementovÃ¡ny, tj. v deklaraci je pouze hlaviÄka metody, stejnÄ›
jako je to u abstraktnÃ­ metody.
TÅ™Ã­da, kterÃ¡ toto rozhranÃ­ implementuje (tj. jakoby dÄ›dÃ­), musÃ­ implementovat (tj. jakoby pÅ™ekrÃ½t) vÅ¡echny jeho metody.
TÅ™Ã­da mÅ¯Å¾e implementovat neomezenÃ© mnoÅ¾stvÃ­ rozhranÃ­.

RozhranÃ­ je vhodnÃ© pouÅ¾Ã­vat jako datovÃ½ typ parametrÅ¯ metod a pÅ™i deklaraci promÄ›nnÃ½ch.
Potom vÅ¡ude tam, kde je uvedeno rozhranÃ­ jako datovÃ½ typ, je oÄekÃ¡vÃ¡na instance jakÃ©koliv tÅ™Ã­dy implementujÃ­cÃ­ toto
rozhranÃ­.

RozhranÃ­ pouÅ¾ijeme, kdyÅ¾ vidÃ­me zcela jednoznaÄnÃ© podobnosti v jednotlivÃ½ch tÅ™Ã­dÃ¡ch, ale jejich zaÄlenÄ›nÃ­ do spoleÄnÃ©ho
pÅ™edka

- mÅ¯Å¾e bÃ½t obtÃ­Å¾nÃ©, protoÅ¾e by byl evidentnÄ› vykonstruovanÃ½, nebo
- mÅ¯Å¾e bÃ½t nemoÅ¾nÃ©, pokud naÅ¡e tÅ™Ã­dy vznikly dÄ›dÄ›nÃ­m z knihovnÃ­ch (tedy nÃ¡mi neovlivnitelnÃ½ch) tÅ™Ã­d.

Od Javy 8 mohou rozhranÃ­ obsahovat i vÃ½chozÃ­ (default) metody, kterÃ© obsahujÃ­cÃ­ implementaci, ne jen hlaviÄku.
TÅ™Ã­da, kterÃ¡ implementuje toto rozhranÃ­, tak zÃ­skÃ¡ i tuto funkcionalitu â€“ jednÃ¡ se tak v podstatÄ› o vÃ­cenÃ¡sobnou
dÄ›diÄnost.

```java
public interface Carnivore {
    void eatMeat(String type);

    boolean hunt();
}

public interface LandAnimal {
    String walk();
}

public class Cat extends Animal implements Carnivore, LandAnimal {
    private boolean fullBelly;

    public Cat(int kg) {
        super(kg);
    }

    @Override
    public String animalSound() {
        return "Meow";
    }

    @Override
    public void eatMeat(String type) {
        fullBelly = type.equals("mouse");
    }

    @Override
    public boolean hunt() {
        return !fullBelly;
    }

    @Override
    public String walk() {
        return "Walking";
    }
}
```

### DelegÃ¡ti

DelegovÃ¡nÃ­ je nÃ¡vrhovÃ½ vzor, kterÃ½ se pouÅ¾Ã­vÃ¡ jako nÃ¡hrada dÄ›diÄnosti.
Pokud pracujeme s objektovÄ›-orientovanÃ½m softwarem a pouÅ¾Ã­vÃ¡me cizÃ­ (ne nÃ¡mi napsanÃ©) knihovny, dost Äasto se stÃ¡vÃ¡, Å¾e
potÅ™ebujeme vyuÅ¾Ã­t tÅ™Ã­dy a objekty z tÃ©to knihovny.
To nÃ¡s svÃ¡dÃ­ k tomu pouÅ¾Ã­t dÄ›diÄnost, podÄ›dit z knihovnÃ­ tÅ™Ã­dy a uspoÅ™it tak spoustu kÃ³du.
Tento postup je vÅ¡ak obecnÄ› oznaÄovÃ¡n za nevhodnÃ½ a Å¡patnÃ½.

DÄ›diÄnost bychom mÄ›li pouÅ¾Ã­vat pouze mezi tÅ™Ã­dami, nad kterÃ½mi mÃ¡me plnou kontrolu.
Pokud nÄ›kdo zÃ¡sadnÃ­m zpÅ¯sobem zmÄ›nÃ­ tÅ™Ã­du, ze kterÃ© dÄ›dÃ­me a upravÃ­ modifikÃ¡tory viditelnosti tÃ©to tÅ™Ã­dy, mÅ¯Å¾eme pÅ™ijÃ­t
o klÃ­Äovou metodu naÅ¡Ã­ tÅ™Ã­dy, kterou jiÅ¾ opakovanÄ› pouÅ¾Ã­vÃ¡me vÅ¡ude v aplikaci.
Abychom tomuto zamezili a nemuseli pak pÅ™episovat kÃ³d celÃ© aplikace, pouÅ¾ijeme delegovÃ¡nÃ­.

PÅ™i delegovÃ¡nÃ­ mÃ¡me vÅ¾dy dvÄ› tÅ™Ã­dy:

- naÅ¡i hlavnÃ­ tÅ™Ã­du, kterÃ¡ pÅ™ijÃ­mÃ¡ poÅ¾adavky,
- delegÃ¡te, kterÃ½ poÅ¾adavky vyÅ™izuje.

Implementace delegovÃ¡nÃ­ tedy vypadÃ¡ tak, Å¾e mÃ¡me naÅ¡i vlastnÃ­ tÅ™Ã­du.
Tato tÅ™Ã­da pomocÃ­ vazby kompozice obsahuje delegÃ¡ta.
VÅ¡echny metody delegÃ¡ta jsou volÃ¡ny metodami naÅ¡Ã­ tÅ™Ã­dy.
TÅ™Ã­da tedy mÃ¡ stejnÄ› pojmenovanÃ© metody se stejnÃ½mi hlaviÄkami a pouze v nich provolÃ¡vÃ¡ metody delegÃ¡ta.

Pokud dojde ke zmÄ›nÄ› delegÃ¡te, mÅ¯Å¾eme metodu pÅ™eimplementovat sami nebo mÅ¯Å¾eme zvolit jinÃ©ho delegÃ¡ta.

NÄ›kterÃ© programovacÃ­ jazyky (Kotlin, C#) majÃ­ podporu delegÃ¡tÅ¯ pÅ™Ã­mo ve standardnÃ­ knihovnÄ›.
C# pÅ™Ã­mo obsahuje klÃ­ÄovÃ© slovo `delegate` a Kotlin mÃ¡ zase klÃ­ÄovÃ© slovo `by`.
Implementace pomocÃ­ klÃ­ÄovÃ©ho slova `by` za nÃ¡s vytvoÅ™Ã­ vÅ¡echny potÅ™ebnÃ© metody a jejich provolÃ¡nÃ­ pÅ™es delegÃ¡ta,
kterÃ© bychom jinak museli vytvoÅ™it ruÄnÄ› (v JavÄ› to musÃ­me udÄ›lat ruÄnÄ›.)
```kotlin
// ukÃ¡zka delegace v Kotlinu
interface Base {
    fun print()
}

class BaseImpl(val x: Int) : Base {
    override fun print() {
        print(x)
    }
}

class Derived(b: Base) : Base by b

fun main() {
    val base = BaseImpl(10)
    Derived(base).print()
}
```

### Genericita
Viz [otÃ¡zka 5](05.md) kapitola "GenerickÃ© programovÃ¡nÃ­".