<div align="center" style="margin-top: 16px;">
    <strong>Ot√°zka 6</strong>
</div>

<nav style="
    position: sticky;
    top: 0;
    z-index: 100;
    background: rgba(0,0,0,0.8);
    padding: 8px 0 4px 0;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    text-align: center;
">
    <a href="05.md" style="color:white; text-decoration:none; margin: 0 16px;">‚¨ÖÔ∏è P≈ôedchoz√≠</a>
    <a href="../README.md" style="color:white; text-decoration:none; margin: 0 16px;">üè† Dom≈Ø</a>
    <a href="07.md" style="color:white; text-decoration:none; margin: 0 16px;">N√°sleduj√≠c√≠ ‚û°Ô∏è</a>
</nav>

> [!WARNING]
> Z d≈Øvodu absence vyuƒçov√°n√≠ p≈ôedmƒõtu C# je v≈°e vysvƒõtleno na programovac√≠m jazyce Java.

# Kolekce v jazyce ~~C#~~ Java

<div align="center">

[<kbd>üåê Vizualizace (EN)</kbd>](https://visualgo.net/en)  

</div>


> [!TIP]Ot√°zka
> Vyu≈æit√≠ datov√Ωch kolekc√≠ (t≈ô√≠dy reprezentuj√≠c√≠ dynamick√© seznamy a jejich vnit≈ôn√≠ implementace, List, SortedList, Dictionary, Queue, Stack), rozd√≠l mezi generick√Ωmi a negenerick√Ωmi strukturami, mo≈ænosti u≈æit√≠ pro ≈ôe≈°en√≠ parci√°ln√≠ch probl√©m≈Ø v bakal√°≈ôsk√© pr√°ci

---

Kolekce jsou kontejnery slou≈æ√≠c√≠ k ukl√°d√°n√≠ objekt≈Ø.Jsou dynamick√Ωmi alternativami k pol√≠m, oproti nim≈æ maj√≠ ≈ôadu v√Ωhod, nap≈ô.:

- promƒõnnou velikost,
- p≈ô√≠stup nejen podle ƒç√≠seln√©ho indexu,
- mo≈ænost manipulace s objekty (≈ôazen√≠, zji≈°≈•ov√°n√≠ p≈ô√≠tomnosti prvku apod.).

Vƒõt≈°inou se pou≈æ√≠vaj√≠ kontejnery hotov√©, vestavƒõn√©, tj. ty, je≈æ jsou souƒç√°sti standardn√≠ knihovny Java Core API. Kontejnerov√© t≈ô√≠dy najdeme v bal√≠ku `java.util`.

Prim√°rnƒõ existuj√≠ t≈ôi typy kontejner≈Ø:

- **Mno≈æiny** (implementuj√≠ rozhran√≠ `Set`)
- **Seznamy** (implementuj√≠ rozhran√≠ `List`)
- **Mapy** (implementuj√≠ rozhran√≠ `Map`)

Mno≈æiny a seznamy implementuj√≠ rozhran√≠ `Collection` a ≈ôad√≠ se tak mezi tzv. kolekce.
Rozhran√≠ kolekce popisuje velmi obecn√Ω kontejner, disponuj√≠c√≠ operacemi: p≈ôid√°v√°n√≠, ru≈°en√≠ prvku, z√≠sk√°n√≠ iter√°toru,
zji≈°≈•ov√°n√≠ pr√°zdnosti atd.

![s10530705302025](https://a.okmd.dev/md/683971f57a5ad.png)

V≈°echny kolekce v diagramu jsou dnes ji≈æ generick√© a mƒõly by se tak i pou≈æ√≠vat.
D≈ô√≠ve, p≈ôed verz√≠ Java SE05, ne≈æ byla zavedena genericita, exitovaly i negenerick√© kolekce.
I dnes je mo≈æn√© je st√°le pou≈æ√≠t.
Ty ov≈°em pracuj√≠ pouze s datov√Ωm typem `Object` a je nevhodn√© je pou≈æ√≠vat.
I p≈ôekladaƒç jazyka n√°s bude varovat a nad√°vat n√°m, pokud pou≈æijeme negenerick√© kolekce.

## Mno≈æiny [<kbd>Set</kbd>](https://www.geeksforgeeks.org/set-in-java/)

![alt text](image.png)

Jsou struktury standardnƒõ bez uspo≈ô√°d√°n√≠ prvk≈Ø (ale existuj√≠ i uspo≈ô√°dan√©, viz n√≠≈æe).
Implementuj√≠ rozhran√≠ `Set` (co≈æ je roz≈°√≠≈ôen√≠ Collection).
C√≠lem mno≈æin je m√≠t mo≈ænost rychle prov√°dƒõt atomick√© operace:

- vkl√°d√°n√≠ prvku,
- odeb√≠r√°n√≠ prvku,
- dotaz na p≈ô√≠tomnost prvku.

### HashSet [<kbd>Link</kbd>](https://www.geeksforgeeks.org/hashset-in-java/)

Neuspo≈ô√°dan√° mno≈æina.
Implementaƒçnƒõ provedena pomoc√≠ struktury **ha≈°ovac√≠ tabulky**.

### TreeSet [<kbd>Link</kbd>](https://www.geeksforgeeks.org/treeset-in-java-with-examples/)

Implementuje rozhran√≠ `SortedSet`. V TreeSet se pr≈Øbƒõ≈ænƒõ udr≈æuj√≠ prvky se≈ôazen√© (vyu≈æ√≠v√° stromovou strukturu). Ji≈æ v okam≈æiku vlo≈æen√≠ se vkl√°dan√Ω prvek za≈ôad√≠ do odpov√≠daj√≠c√≠ho po≈ôad√≠ vzhledem ke st√°vaj√≠c√≠m prvk≈Øm. Vkl√°d√°n√≠ do TreeSet je tak pomalej≈°√≠, ne≈æ do HashSet. Kupodivu pomalej≈°√≠ je i jak√°koliv dal≈°√≠ pr√°ce s TreeSet, kromƒõ vyhled√°v√°n√≠ prvku (kde v≈°ak rozd√≠l rychlost√≠ nen√≠ v√Ωznamn√Ω).

Jednotliv√© prvky lze tedy iter√°torem proch√°zet v p≈ôesnƒõ definovan√©m po≈ôad√≠ ‚Äì uspo≈ô√°d√°n√≠ podle hodnot prvk≈Ø.

Uspo≈ô√°d√°n√≠ je d√°no buƒèto:

- standardn√≠m chov√°n√≠m metody `compareTo()` vkl√°dan√Ωch objekt≈Ø, pokud implementuj√≠ rozhran√≠ `Comperable`
- nebo je mo≈æn√© uspo≈ô√°d√°n√≠ definovat pomoc√≠ tzv. kompar√°toru (rozhran√≠ `Comparator`) poskytnut√©ho p≈ôi tvorbƒõ mno≈æiny

## Seznamy [<kbd>List</kbd>](https://www.geeksforgeeks.org/list-interface-java-examples/)

Jedn√° se o line√°rn√≠ struktury. Implementuj√≠ rozhran√≠ `List`. Prvky seznam≈Ø lze adresovat pomoc√≠ ƒç√≠seln√©ho indexu. Seznamy poskytuj√≠ mo≈ænost z√≠skat dop≈ôedn√Ω i zpƒõtn√Ω iter√°tor. Lze pracovat i s podseznamy pomoc√≠ metody `sublist()`. Nejpou≈æ√≠vanƒõj≈°√≠m seznamem je t≈ô√≠da `ArrayList`.

### LinkedList [<kbd>Link</kbd>](https://www.geeksforgeeks.org/linked-list-in-java/)

T≈ô√≠da LinkedList p≈ôedstavuje spojov√Ω seznam prvk≈Ø s mo≈ænost√≠ p≈ôid√°vat/odeb√≠rat prvky na zaƒç√°tku nebo konci seznamu.
V Javƒõ je tato t≈ô√≠da implementov√°na jako **obousmƒõrnƒõ z≈ôetƒõzen√Ω line√°rn√≠ seznam**.
Implementace pomoc√≠ dvojitƒõ z≈ôetƒõzen√©ho seznam umo≈æ≈àuje rychl√© vkl√°d√°n√≠ a maz√°n√≠, ale pomal√Ω n√°hodn√Ω p≈ô√≠stup.

#### P≈ô√≠klad pou≈æit√≠

``` java
// Java program to add elements to a LinkedList
import java.util.LinkedList;

public class Geeks {

    // Main driver method
    public static void main(String[] args) {
        // Creating a LinkedList
        LinkedList<String> l = new LinkedList<String>();

        // Adding elements to the LinkedList using add() method
        l.add("One");
        l.add("Two");
        l.add("Three");
        l.add("Four");
        l.add("Five");

        // Printing the LinkedList
        System.out.println(l);
    }
}
```

##### V√Ωstup programu:
```
[One, Two, Three, Four, Five]
```

### Vector [<kbd>Link</kbd>](https://www.geeksforgeeks.org/java-util-vector-class-java/)

T≈ô√≠da Vector je souƒç√°st√≠ standardn√≠ knihovny ji≈æ od verze 1.0 jazyka. Dnes se m√≠sto nƒõj pou≈æ√≠v√° ArrayList. M√° podt≈ô√≠du `Stack` reprezentuj√≠c√≠ z√°sobn√≠k (strukturu typu LIFO) s metodami `push()`, `pop()` a `empty()`. Vector je vl√°knovƒõ bezpeƒçn√° datov√° struktura. Tato jej√≠ vlastnost ov≈°em sni≈æuje jej√≠ v√Ωkon, je pomalej≈°√≠ a proto je preferovanƒõj≈°√≠ ArrayList.


### P≈ô√≠klad pou≈æit√≠

``` java
*// Java Program Implementing Vector
import java.util.Vector;

public class Geeks
{
    public static void main(String[] args) 
    {
        // Create a new vector
        Vector<Integer> v = new Vector<>(3, 2);

        // Add elements to the vector
        v.addElement(1);
        v.addElement(2);
        v.addElement(3);

        // Insert an element at index 1
        v.insertElementAt(0, 1);

        // Remove the element at index 2
        v.removeElementAt(2);

        // Print the elements of the vector
        for (int i : v) {
            System.out.println(i);
        }
    }
}*
```

#### V√Ωstup programu:
```
1
0
3
```

### ArrayList [<kbd>Link</kbd>](https://www.geeksforgeeks.org/arraylist-in-java/)

P≈ôipom√≠n√° klasick√© pole, ov≈°em s promƒõnnou d√©lkou.
Pro p≈ô√≠stup k jednotliv√Ωm prvk≈Øm lze pou≈æ√≠vat indexy, proto≈æe prvky jsou udr≈æov√°ny v urƒçit√©m po≈ôad√≠. M≈Ø≈æe obsahovat stejn√© (duplicitn√≠) prvky.

Vnit≈ônƒõ je implementov√°n jako **pole** s v√Ωchoz√≠ velikost√≠ 10. Jakmile v poli dojde m√≠sto, zvƒõt≈°√≠ seznam svoji velikosti vytvo≈ôen√≠m nov√©ho pole, kter√© m√° o 50 % vƒõt≈°√≠ velikost. V≈°echny prvky ze star√©ho pole jsou p≈ôem√≠stƒõny do nov√©ho pole.

ArrayList je vhodn√Ω pro rychl√© ƒçten√≠. Kv≈Øli realokaci vnit≈ônƒõ pou≈æit√©ho pole je ov≈°em nevhodn√Ω pro ƒçast√© vkl√°d√°n√≠ a odeb√≠r√°n√≠ prvk≈Ø.

#### P≈ô√≠klad pou≈æit√≠

``` java
// Java Program to demonstrate ArrayList
import java.util.ArrayList;

class Main {
    public static void main (String[] args) {
        
      	// Creating an ArrayList
      	ArrayList<Integer> a = new ArrayList<Integer>();
      	
      	// Adding Element in ArrayList
      	a.add(1);
      	a.add(2);
      	a.add(3);
      
      	// Printing ArrayList
      	System.out.println(a);
      	
    }
}
```

#### V√Ωstup programu:
```
[1, 2, 3]
```

### PriorityQueue [<kbd>Link</kbd>](https://www.geeksforgeeks.org/priority-queue-in-java/)

PriorityQueue je fronta s prioritami, kde prvky maj√≠ p≈ôirozen√© po≈ôad√≠ nebo po≈ôad√≠ definovan√© porovn√°vac√≠m objektem (Comparator). Fronta je implementov√°na pomoc√≠ datov√© struktury halda (heap).

#### P≈ô√≠klad pou≈æit√≠

``` java
// Java Program for PriorityQueue
import java.util.PriorityQueue;

public class Geeks 
{
    public static void main(String[] args) 
    {
      	// Priority Queue Min Type
        PriorityQueue<Integer> p = new PriorityQueue<>();

        // Add elements to the queue
        p.add(3);
        p.add(10);
        p.add(7);
        p.add(2);

        // Print the head of the queue
        System.out.println("Head of Queue: " + p.peek());

    }
}
```

#### V√Ωstup programu:
```
Head of Queue: 2
```

## Mapy [<kbd>Map</kbd>](https://www.geeksforgeeks.org/map-interface-java-examples/)

![alt text](image-1.png)

Mapy (asociativn√≠ pole, nep≈ôesnƒõ tak√© ha≈°ovac√≠ tabulky nebo ha≈°e) funguj√≠ v podstatƒõ na stejn√Ωch principech a
po≈æadavc√≠ch jako Set.
Ukl√°daj√≠ ov≈°em dvojice (kl√≠ƒç, hodnota) a umo≈æ≈àuj√≠ rychl√© vyhled√°n√≠ dvojice podle hodnoty kl√≠ƒçe.
Pomoc√≠ kl√≠ƒçe, kter√Ω je nemƒõnn√Ω a unik√°tn√≠, se vyhled√°v√° hodnota.
Hodnota je promƒõnn√° a m≈Ø≈æe b√Ωt duplicitn√≠, tj. dva r≈Øzn√© kl√≠ƒçe mohou m√≠t stejnou hodnotu.
Nejpou≈æ√≠vanƒõj≈°√≠ t≈ô√≠dou je zde HashMap.
Mo≈æn√© operace jsou:

- vlo≈æen√≠ prvku
- odstranƒõn√≠ prvku podle hodnoty kl√≠ƒçe
- dotaz na p≈ô√≠tomnost kl√≠ƒçe v mapƒõ
- dotaz na p≈ô√≠tomnost hodnoty v mapƒõ
- v√Ωbƒõr hodnoty odpov√≠daj√≠c√≠ zadan√©mu kl√≠ƒçi

### HashMap

`HashMap` je jedna z nejƒçastƒõji pou≈æ√≠van√Ωch implementac√≠ rozhran√≠ `Map`. Slou≈æ√≠ k ukl√°d√°n√≠ dvojic **kl√≠ƒç ‚Äì hodnota** a je zalo≈æena na **ha≈°ovac√≠ tabulce**.

---

#### Z√°kladn√≠ vlastnosti

- Ukl√°d√° **p√°ry (kl√≠ƒç ‚Äì hodnota)**.
- **Kl√≠ƒçe mus√≠ b√Ωt jedineƒçn√©**, hodnoty mohou b√Ωt duplicitn√≠.
- Nezaruƒçuje ≈æ√°dn√© **po≈ôad√≠** prvk≈Ø.
- Umo≈æ≈àuje **jeden `null` kl√≠ƒç** a v√≠ce `null` hodnot.
- Internƒõ vyu≈æ√≠v√° **ha≈°ovac√≠ funkci** a **pole bucket≈Ø**.

---

#### Jak funguje

- Kl√≠ƒç je p≈ôepoƒç√≠t√°n pomoc√≠ `hashCode()` na index do vnit≈ôn√≠ho pole.
- Pokud dojde ke kolizi (stejn√Ω index pro v√≠ce kl√≠ƒç≈Ø):
  - d≈ô√≠ve: **Linked List**
  - od Javy 8: **Tree (vyv√°≈æen√Ω bin√°rn√≠ strom)**, pokud je v bucketu v√≠ce ne≈æ 8 polo≈æek
- Typick√° slo≈æitost operac√≠ je `O(1)` v ide√°ln√≠m p≈ô√≠padƒõ.

---

#### P≈ô√≠klad pou≈æit√≠

```java
import java.util.HashMap;
import java.util.Map;

public class Main {
    public static void main(String[] args) {
        Map<String, Integer> map = new HashMap<>();

        // P≈ôid√°n√≠ prvk≈Ø
        map.put("Jablko", 10);
        map.put("Hru≈°ka", 5);
        map.put("Ban√°n", 7);
        map.put("Jablko", 12); // p≈ôep√≠≈°e hodnotu

        System.out.println("Obsah mapy: " + map);
        System.out.println("Poƒçet ban√°n≈Ø: " + map.get("Ban√°n"));

        if (map.containsKey("Hru≈°ka")) {
            System.out.println("Hru≈°ka je v mapƒõ.");
        }

        map.remove("Ban√°n");
        System.out.println("Po odebr√°n√≠ ban√°nu: " + map);
    }
}
```

#### V√Ωstup programu:
```
Obsah mapy: {Jablko=12, Hru≈°ka=5, Ban√°n=7}
Poƒçet ban√°n≈Ø: 7
Hru≈°ka je v mapƒõ.
Po odebr√°n√≠ ban√°nu: {Jablko=12, Hru≈°ka=5}
```

### EnumMap

`EnumMap` je speci√°ln√≠ implementace rozhran√≠ `Map`, kter√° pou≈æ√≠v√° **enum jako kl√≠ƒç**. Je velmi efektivn√≠, proto≈æe internƒõ pou≈æ√≠v√° pole indexovan√© ordinal hodnotou enumu.

---

#### Z√°kladn√≠ vlastnosti

- Pou≈æ√≠v√° se **v√Ωhradnƒõ s enum typy jako kl√≠ƒçem**.
- Je **typovƒõ bezpeƒçn√°** a **v√Ωkonnƒõj≈°√≠ ne≈æ `HashMap`**, pokud pou≈æ√≠v√°≈° enum jako kl√≠ƒç.
- Zachov√°v√° **po≈ôad√≠ deklarace enum konstant**.
- **Nepovoluje `null` jako kl√≠ƒç**.
- Hodnoty `null` jsou povoleny.

---

#### Jak funguje

- Vnit≈ônƒõ vyu≈æ√≠v√° pole, kde indexem je `ordinal()` hodnota enumu.
- D√≠ky tomu jsou operace jako `get()`, `put()` a `remove()` velmi rychl√© ‚Äì **konstantn√≠ ƒças `O(1)`**.

---

#### P≈ô√≠klad pou≈æit√≠

```java
import java.util.EnumMap;

enum Ovoce {
    JABLKO, HRUSKA, BANAN
}

public class Main {
    public static void main(String[] args) {
        EnumMap<Ovoce, Integer> map = new EnumMap<>(Ovoce.class);

        map.put(Ovoce.JABLKO, 10);
        map.put(Ovoce.HRUSKA, 5);
        map.put(Ovoce.BANAN, 7);

        System.out.println("Obsah mapy: " + map);
    }
}
```

#### V√Ωstup programu:
```
Obsah mapy: {JABLKO=10, HRUSKA=5, BANAN=7}
```

### TreeMap

`TreeMap` je implementace rozhran√≠ `Map`, kter√° udr≈æuje prvky **se≈ôazen√© podle kl√≠ƒçe**.

---

#### Z√°kladn√≠ vlastnosti

- Kl√≠ƒçe jsou **se≈ôazen√© p≈ôirozen√Ωm zp≈Øsobem** (`Comparable`) nebo pomoc√≠ zadan√©ho `Comparator`.
- **Neumo≈æ≈àuje `null` kl√≠ƒç**, ale hodnoty `null` jsou povoleny.
- Implementov√°na pomoc√≠ **vyv√°≈æen√©ho bin√°rn√≠ho stromu (Red-Black Tree)**.
- Typick√° slo≈æitost operac√≠: **`O(log n)`**.

---

#### Jak funguje

- Ka≈æd√Ω nov√Ω kl√≠ƒç je um√≠stƒõn do stromu podle srovn√°n√≠ s ostatn√≠mi kl√≠ƒçi.
- D√≠ky tomu je mo≈æn√© efektivnƒõ hledat, p≈ôid√°vat a mazat, ale operace jsou pomalej≈°√≠ ne≈æ u `HashMap`.

---

#### P≈ô√≠klad pou≈æit√≠

```java
import java.util.TreeMap;

public class Main {
    public static void main(String[] args) {
        TreeMap<String, Integer> map = new TreeMap<>();

        map.put("Jablko", 10);
        map.put("Hru≈°ka", 5);
        map.put("Ban√°n", 7);

        System.out.println("Obsah mapy: " + map);
    }
}
```
#### V√Ωstup programu:
```
Obsah mapy: {Ban√°n=7, Hru≈°ka=5, Jablko=10}
```
_Pozn√°mka: V√Ωstup je se≈ôazen√Ω abecednƒõ podle kl√≠ƒç≈Ø._

V TreeMap jsou jednotliv√© prvky se≈ôazeny podle hodnoty kl√≠ƒçe.
TreeMap se pou≈æ√≠v√° (stejnƒõ jako TreeSet) m√©nƒõ, kdy≈æ pot≈ôebujeme m√≠t prvky se≈ôazen√©.
Se≈ôazen√≠ kl√≠ƒç≈Ø je nezbytn√© v tom p≈ô√≠padƒõ, kdy pot≈ôebujeme z√≠skat z mapy:

- nejvƒõt≈°√≠ ƒçi nejmen≈°√≠ kl√≠ƒç,
- ‚Äûpodmapu‚Äú v z√°vislosti na hodnotƒõ kl√≠ƒçe.

TreeMap podporuje v≈°echny operace ze t≈ô√≠dy HashMap a p≈ôid√°v√° k nim je≈°tƒõ:

- z√≠sk√°n√≠ nejmen≈°√≠ho kl√≠ƒçe
- z√≠sk√°n√≠ nejvƒõt≈°√≠ho kl√≠ƒçe