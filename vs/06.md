<div align="center" style="margin-top: 16px;">
    <strong>OtÃ¡zka 6</strong>
</div>

<nav style="
    position: sticky;
    top: 0;
    z-index: 100;
    background: rgba(0,0,0,0.8);
    padding: 8px 0 4px 0;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    text-align: center;
">
    <a href="05.md" style="color:white; text-decoration:none; margin: 0 16px;">â¬…ï¸ PÅ™edchozÃ­</a>
    <a href="../README.md" style="color:white; text-decoration:none; margin: 0 16px;">ğŸ  DomÅ¯</a>
    <a href="07.md" style="color:white; text-decoration:none; margin: 0 16px;">NÃ¡sledujÃ­cÃ­ â¡ï¸</a>
</nav>

> [!WARNING]
> Z dÅ¯vodu absence vyuÄovÃ¡nÃ­ pÅ™edmÄ›tu C# je vÅ¡e vysvÄ›tleno na programovacÃ­m jazyce Java.

# Kolekce v jazyce ~~C#~~ Java

<div align="center">

[<kbd>ğŸŒ Vizualizace (EN)</kbd>](https://visualgo.net/en)  

</div>


> [!TIP]OtÃ¡zka
> VyuÅ¾itÃ­ datovÃ½ch kolekcÃ­ (tÅ™Ã­dy reprezentujÃ­cÃ­ dynamickÃ© seznamy a jejich vnitÅ™nÃ­ implementace, List, SortedList, Dictionary, Queue, Stack), rozdÃ­l mezi generickÃ½mi a negenerickÃ½mi strukturami, moÅ¾nosti uÅ¾itÃ­ pro Å™eÅ¡enÃ­ parciÃ¡lnÃ­ch problÃ©mÅ¯ v bakalÃ¡Å™skÃ© prÃ¡ci

---

Kolekce jsou kontejnery slouÅ¾Ã­cÃ­ k uklÃ¡dÃ¡nÃ­ objektÅ¯.Jsou dynamickÃ½mi alternativami k polÃ­m, oproti nimÅ¾ majÃ­ Å™adu vÃ½hod, napÅ™.:

- promÄ›nnou velikost,
- pÅ™Ã­stup nejen podle ÄÃ­selnÃ©ho indexu,
- moÅ¾nost manipulace s objekty (Å™azenÃ­, zjiÅ¡Å¥ovÃ¡nÃ­ pÅ™Ã­tomnosti prvku apod.).

VÄ›tÅ¡inou se pouÅ¾Ã­vajÃ­ kontejnery hotovÃ©, vestavÄ›nÃ©, tj. ty, jeÅ¾ jsou souÄÃ¡sti standardnÃ­ knihovny Java Core API. KontejnerovÃ© tÅ™Ã­dy najdeme v balÃ­ku `java.util`.

PrimÃ¡rnÄ› existujÃ­ tÅ™i typy kontejnerÅ¯:

- **MnoÅ¾iny** (implementujÃ­ rozhranÃ­ `Set`)
- **Seznamy** (implementujÃ­ rozhranÃ­ `List`)
- **Mapy** (implementujÃ­ rozhranÃ­ `Map`)

MnoÅ¾iny a seznamy implementujÃ­ rozhranÃ­ `Collection` a Å™adÃ­ se tak mezi tzv. kolekce.
RozhranÃ­ kolekce popisuje velmi obecnÃ½ kontejner, disponujÃ­cÃ­ operacemi: pÅ™idÃ¡vÃ¡nÃ­, ruÅ¡enÃ­ prvku, zÃ­skÃ¡nÃ­ iterÃ¡toru,
zjiÅ¡Å¥ovÃ¡nÃ­ prÃ¡zdnosti atd.

![s10530705302025](https://a.okmd.dev/md/683971f57a5ad.png)

VÅ¡echny kolekce v diagramu jsou dnes jiÅ¾ generickÃ© a mÄ›ly by se tak i pouÅ¾Ã­vat.
DÅ™Ã­ve, pÅ™ed verzÃ­ Java SE05, neÅ¾ byla zavedena genericita, exitovaly i negenerickÃ© kolekce.
I dnes je moÅ¾nÃ© je stÃ¡le pouÅ¾Ã­t.
Ty ovÅ¡em pracujÃ­ pouze s datovÃ½m typem `Object` a je nevhodnÃ© je pouÅ¾Ã­vat.
I pÅ™ekladaÄ jazyka nÃ¡s bude varovat a nadÃ¡vat nÃ¡m, pokud pouÅ¾ijeme negenerickÃ© kolekce.

## MnoÅ¾iny [<kbd>Set</kbd>](https://www.geeksforgeeks.org/set-in-java/)

![alt text](image.png)

Jsou struktury standardnÄ› bez uspoÅ™Ã¡dÃ¡nÃ­ prvkÅ¯ (ale existujÃ­ i uspoÅ™Ã¡danÃ©, viz nÃ­Å¾e).
ImplementujÃ­ rozhranÃ­ `Set` (coÅ¾ je rozÅ¡Ã­Å™enÃ­ Collection).
CÃ­lem mnoÅ¾in je mÃ­t moÅ¾nost rychle provÃ¡dÄ›t atomickÃ© operace:

- vklÃ¡dÃ¡nÃ­ prvku,
- odebÃ­rÃ¡nÃ­ prvku,
- dotaz na pÅ™Ã­tomnost prvku.

### HashSet [<kbd>Link</kbd>](https://www.geeksforgeeks.org/hashset-in-java/)

NeuspoÅ™Ã¡danÃ¡ mnoÅ¾ina.
ImplementaÄnÄ› provedena pomocÃ­ struktury **haÅ¡ovacÃ­ tabulky**.

### TreeSet [<kbd>Link</kbd>](https://www.geeksforgeeks.org/treeset-in-java-with-examples/)

Implementuje rozhranÃ­ `SortedSet`. V TreeSet se prÅ¯bÄ›Å¾nÄ› udrÅ¾ujÃ­ prvky seÅ™azenÃ© (vyuÅ¾Ã­vÃ¡ stromovou strukturu). JiÅ¾ v okamÅ¾iku vloÅ¾enÃ­ se vklÃ¡danÃ½ prvek zaÅ™adÃ­ do odpovÃ­dajÃ­cÃ­ho poÅ™adÃ­ vzhledem ke stÃ¡vajÃ­cÃ­m prvkÅ¯m. VklÃ¡dÃ¡nÃ­ do TreeSet je tak pomalejÅ¡Ã­, neÅ¾ do HashSet. Kupodivu pomalejÅ¡Ã­ je i jakÃ¡koliv dalÅ¡Ã­ prÃ¡ce s TreeSet, kromÄ› vyhledÃ¡vÃ¡nÃ­ prvku (kde vÅ¡ak rozdÃ­l rychlostÃ­ nenÃ­ vÃ½znamnÃ½).

JednotlivÃ© prvky lze tedy iterÃ¡torem prochÃ¡zet v pÅ™esnÄ› definovanÃ©m poÅ™adÃ­ â€“ uspoÅ™Ã¡dÃ¡nÃ­ podle hodnot prvkÅ¯.

UspoÅ™Ã¡dÃ¡nÃ­ je dÃ¡no buÄto:

- standardnÃ­m chovÃ¡nÃ­m metody `compareTo()` vklÃ¡danÃ½ch objektÅ¯, pokud implementujÃ­ rozhranÃ­ `Comperable`
- nebo je moÅ¾nÃ© uspoÅ™Ã¡dÃ¡nÃ­ definovat pomocÃ­ tzv. komparÃ¡toru (rozhranÃ­ `Comparator`) poskytnutÃ©ho pÅ™i tvorbÄ› mnoÅ¾iny

## Seznamy [<kbd>List</kbd>](https://www.geeksforgeeks.org/list-interface-java-examples/)

JednÃ¡ se o lineÃ¡rnÃ­ struktury. ImplementujÃ­ rozhranÃ­ `List`. Prvky seznamÅ¯ lze adresovat pomocÃ­ ÄÃ­selnÃ©ho indexu. Seznamy poskytujÃ­ moÅ¾nost zÃ­skat dopÅ™ednÃ½ i zpÄ›tnÃ½ iterÃ¡tor. Lze pracovat i s podseznamy pomocÃ­ metody `sublist()`. NejpouÅ¾Ã­vanÄ›jÅ¡Ã­m seznamem je tÅ™Ã­da `ArrayList`.

### LinkedList [<kbd>Link</kbd>](https://www.geeksforgeeks.org/linked-list-in-java/)

TÅ™Ã­da LinkedList pÅ™edstavuje spojovÃ½ seznam prvkÅ¯ s moÅ¾nostÃ­ pÅ™idÃ¡vat/odebÃ­rat prvky na zaÄÃ¡tku nebo konci seznamu.
V JavÄ› je tato tÅ™Ã­da implementovÃ¡na jako **obousmÄ›rnÄ› zÅ™etÄ›zenÃ½ lineÃ¡rnÃ­ seznam**.
Implementace pomocÃ­ dvojitÄ› zÅ™etÄ›zenÃ©ho seznam umoÅ¾Åˆuje rychlÃ© vklÃ¡dÃ¡nÃ­ a mazÃ¡nÃ­, ale pomalÃ½ nÃ¡hodnÃ½ pÅ™Ã­stup.

#### PÅ™Ã­klad pouÅ¾itÃ­

``` java
// Java program to add elements to a LinkedList
import java.util.LinkedList;

public class Geeks {

    // Main driver method
    public static void main(String[] args) {
        // Creating a LinkedList
        LinkedList<String> l = new LinkedList<String>();

        // Adding elements to the LinkedList using add() method
        l.add("One");
        l.add("Two");
        l.add("Three");
        l.add("Four");
        l.add("Five");

        // Printing the LinkedList
        System.out.println(l);
    }
}
```

##### VÃ½stup programu:
```
[One, Two, Three, Four, Five]
```

### Vector [<kbd>Link</kbd>](https://www.geeksforgeeks.org/java-util-vector-class-java/)

TÅ™Ã­da Vector je souÄÃ¡stÃ­ standardnÃ­ knihovny jiÅ¾ od verze 1.0 jazyka. Dnes se mÃ­sto nÄ›j pouÅ¾Ã­vÃ¡ ArrayList. MÃ¡ podtÅ™Ã­du `Stack` reprezentujÃ­cÃ­ zÃ¡sobnÃ­k (strukturu typu LIFO) s metodami `push()`, `pop()` a `empty()`. Vector je vlÃ¡knovÄ› bezpeÄnÃ¡ datovÃ¡ struktura. Tato jejÃ­ vlastnost ovÅ¡em sniÅ¾uje jejÃ­ vÃ½kon, je pomalejÅ¡Ã­ a proto je preferovanÄ›jÅ¡Ã­ ArrayList.


### PÅ™Ã­klad pouÅ¾itÃ­

``` java
*// Java Program Implementing Vector
import java.util.Vector;

public class Geeks
{
    public static void main(String[] args) 
    {
        // Create a new vector
        Vector<Integer> v = new Vector<>(3, 2);

        // Add elements to the vector
        v.addElement(1);
        v.addElement(2);
        v.addElement(3);

        // Insert an element at index 1
        v.insertElementAt(0, 1);

        // Remove the element at index 2
        v.removeElementAt(2);

        // Print the elements of the vector
        for (int i : v) {
            System.out.println(i);
        }
    }
}*
```

#### VÃ½stup programu:
```
1
0
3
```

### ArrayList [<kbd>Link</kbd>](https://www.geeksforgeeks.org/arraylist-in-java/)

PÅ™ipomÃ­nÃ¡ klasickÃ© pole, ovÅ¡em s promÄ›nnou dÃ©lkou.
Pro pÅ™Ã­stup k jednotlivÃ½m prvkÅ¯m lze pouÅ¾Ã­vat indexy, protoÅ¾e prvky jsou udrÅ¾ovÃ¡ny v urÄitÃ©m poÅ™adÃ­. MÅ¯Å¾e obsahovat stejnÃ© (duplicitnÃ­) prvky.

VnitÅ™nÄ› je implementovÃ¡n jako **pole** s vÃ½chozÃ­ velikostÃ­ 10. Jakmile v poli dojde mÃ­sto, zvÄ›tÅ¡Ã­ seznam svoji velikosti vytvoÅ™enÃ­m novÃ©ho pole, kterÃ© mÃ¡ o 50 % vÄ›tÅ¡Ã­ velikost. VÅ¡echny prvky ze starÃ©ho pole jsou pÅ™emÃ­stÄ›ny do novÃ©ho pole.

ArrayList je vhodnÃ½ pro rychlÃ© ÄtenÃ­. KvÅ¯li realokaci vnitÅ™nÄ› pouÅ¾itÃ©ho pole je ovÅ¡em nevhodnÃ½ pro ÄastÃ© vklÃ¡dÃ¡nÃ­ a odebÃ­rÃ¡nÃ­ prvkÅ¯.

#### PÅ™Ã­klad pouÅ¾itÃ­

``` java
// Java Program to demonstrate ArrayList
import java.util.ArrayList;

class Main {
    public static void main (String[] args) {
        
      	// Creating an ArrayList
      	ArrayList<Integer> a = new ArrayList<Integer>();
      	
      	// Adding Element in ArrayList
      	a.add(1);
      	a.add(2);
      	a.add(3);
      
      	// Printing ArrayList
      	System.out.println(a);
      	
    }
}
```

#### VÃ½stup programu:
```
[1, 2, 3]
```

### PriorityQueue [<kbd>Link</kbd>](https://www.geeksforgeeks.org/priority-queue-in-java/)

PriorityQueue je fronta s prioritami, kde prvky majÃ­ pÅ™irozenÃ© poÅ™adÃ­ nebo poÅ™adÃ­ definovanÃ© porovnÃ¡vacÃ­m objektem (Comparator). Fronta je implementovÃ¡na pomocÃ­ datovÃ© struktury halda (heap).

#### PÅ™Ã­klad pouÅ¾itÃ­

``` java
// Java Program for PriorityQueue
import java.util.PriorityQueue;

public class Geeks 
{
    public static void main(String[] args) 
    {
      	// Priority Queue Min Type
        PriorityQueue<Integer> p = new PriorityQueue<>();

        // Add elements to the queue
        p.add(3);
        p.add(10);
        p.add(7);
        p.add(2);

        // Print the head of the queue
        System.out.println("Head of Queue: " + p.peek());

    }
}
```

#### VÃ½stup programu:
```
Head of Queue: 2
```

## Mapy [<kbd>Map</kbd>](https://www.geeksforgeeks.org/map-interface-java-examples/)

![alt text](image-1.png)

Mapy (asociativnÃ­ pole, nepÅ™esnÄ› takÃ© haÅ¡ovacÃ­ tabulky nebo haÅ¡e) fungujÃ­ v podstatÄ› na stejnÃ½ch principech a
poÅ¾adavcÃ­ch jako Set.
UklÃ¡dajÃ­ ovÅ¡em dvojice (klÃ­Ä, hodnota) a umoÅ¾ÅˆujÃ­ rychlÃ© vyhledÃ¡nÃ­ dvojice podle hodnoty klÃ­Äe.
PomocÃ­ klÃ­Äe, kterÃ½ je nemÄ›nnÃ½ a unikÃ¡tnÃ­, se vyhledÃ¡vÃ¡ hodnota.
Hodnota je promÄ›nnÃ¡ a mÅ¯Å¾e bÃ½t duplicitnÃ­, tj. dva rÅ¯znÃ© klÃ­Äe mohou mÃ­t stejnou hodnotu.
NejpouÅ¾Ã­vanÄ›jÅ¡Ã­ tÅ™Ã­dou je zde HashMap.
MoÅ¾nÃ© operace jsou:

- vloÅ¾enÃ­ prvku
- odstranÄ›nÃ­ prvku podle hodnoty klÃ­Äe
- dotaz na pÅ™Ã­tomnost klÃ­Äe v mapÄ›
- dotaz na pÅ™Ã­tomnost hodnoty v mapÄ›
- vÃ½bÄ›r hodnoty odpovÃ­dajÃ­cÃ­ zadanÃ©mu klÃ­Äi

### HashMap

`HashMap` je jedna z nejÄastÄ›ji pouÅ¾Ã­vanÃ½ch implementacÃ­ rozhranÃ­ `Map`. SlouÅ¾Ã­ k uklÃ¡dÃ¡nÃ­ dvojic **klÃ­Ä â€“ hodnota** a je zaloÅ¾ena na **haÅ¡ovacÃ­ tabulce**.

---

#### ZÃ¡kladnÃ­ vlastnosti

- UklÃ¡dÃ¡ **pÃ¡ry (klÃ­Ä â€“ hodnota)**.
- **KlÃ­Äe musÃ­ bÃ½t jedineÄnÃ©**, hodnoty mohou bÃ½t duplicitnÃ­.
- NezaruÄuje Å¾Ã¡dnÃ© **poÅ™adÃ­** prvkÅ¯.
- UmoÅ¾Åˆuje **jeden `null` klÃ­Ä** a vÃ­ce `null` hodnot.
- InternÄ› vyuÅ¾Ã­vÃ¡ **haÅ¡ovacÃ­ funkci** a **pole bucketÅ¯**.

---

#### Jak funguje

- KlÃ­Ä je pÅ™epoÄÃ­tÃ¡n pomocÃ­ `hashCode()` na index do vnitÅ™nÃ­ho pole.
- Pokud dojde ke kolizi (stejnÃ½ index pro vÃ­ce klÃ­ÄÅ¯):
  - dÅ™Ã­ve: **Linked List**
  - od Javy 8: **Tree (vyvÃ¡Å¾enÃ½ binÃ¡rnÃ­ strom)**, pokud je v bucketu vÃ­ce neÅ¾ 8 poloÅ¾ek
- TypickÃ¡ sloÅ¾itost operacÃ­ je `O(1)` v ideÃ¡lnÃ­m pÅ™Ã­padÄ›.

---

#### PÅ™Ã­klad pouÅ¾itÃ­

```java
import java.util.HashMap;
import java.util.Map;

public class Main {
    public static void main(String[] args) {
        Map<String, Integer> map = new HashMap<>();

        // PÅ™idÃ¡nÃ­ prvkÅ¯
        map.put("Jablko", 10);
        map.put("HruÅ¡ka", 5);
        map.put("BanÃ¡n", 7);
        map.put("Jablko", 12); // pÅ™epÃ­Å¡e hodnotu

        System.out.println("Obsah mapy: " + map);
        System.out.println("PoÄet banÃ¡nÅ¯: " + map.get("BanÃ¡n"));

        if (map.containsKey("HruÅ¡ka")) {
            System.out.println("HruÅ¡ka je v mapÄ›.");
        }

        map.remove("BanÃ¡n");
        System.out.println("Po odebrÃ¡nÃ­ banÃ¡nu: " + map);
    }
}
```

#### VÃ½stup programu:
```
Obsah mapy: {Jablko=12, HruÅ¡ka=5, BanÃ¡n=7}
PoÄet banÃ¡nÅ¯: 7
HruÅ¡ka je v mapÄ›.
Po odebrÃ¡nÃ­ banÃ¡nu: {Jablko=12, HruÅ¡ka=5}
```

### EnumMap

`EnumMap` je speciÃ¡lnÃ­ implementace rozhranÃ­ `Map`, kterÃ¡ pouÅ¾Ã­vÃ¡ **enum jako klÃ­Ä**. Je velmi efektivnÃ­, protoÅ¾e internÄ› pouÅ¾Ã­vÃ¡ pole indexovanÃ© ordinal hodnotou enumu.

---

#### ZÃ¡kladnÃ­ vlastnosti

- PouÅ¾Ã­vÃ¡ se **vÃ½hradnÄ› s enum typy jako klÃ­Äem**.
- Je **typovÄ› bezpeÄnÃ¡** a **vÃ½konnÄ›jÅ¡Ã­ neÅ¾ `HashMap`**, pokud pouÅ¾Ã­vÃ¡Å¡ enum jako klÃ­Ä.
- ZachovÃ¡vÃ¡ **poÅ™adÃ­ deklarace enum konstant**.
- **Nepovoluje `null` jako klÃ­Ä**.
- Hodnoty `null` jsou povoleny.

---

#### Jak funguje

- VnitÅ™nÄ› vyuÅ¾Ã­vÃ¡ pole, kde indexem je `ordinal()` hodnota enumu.
- DÃ­ky tomu jsou operace jako `get()`, `put()` a `remove()` velmi rychlÃ© â€“ **konstantnÃ­ Äas `O(1)`**.

---

#### PÅ™Ã­klad pouÅ¾itÃ­

```java
import java.util.EnumMap;

enum Ovoce {
    JABLKO, HRUSKA, BANAN
}

public class Main {
    public static void main(String[] args) {
        EnumMap<Ovoce, Integer> map = new EnumMap<>(Ovoce.class);

        map.put(Ovoce.JABLKO, 10);
        map.put(Ovoce.HRUSKA, 5);
        map.put(Ovoce.BANAN, 7);

        System.out.println("Obsah mapy: " + map);
    }
}
```

#### VÃ½stup programu:
```
Obsah mapy: {JABLKO=10, HRUSKA=5, BANAN=7}
```

### TreeMap

`TreeMap` je implementace rozhranÃ­ `Map`, kterÃ¡ udrÅ¾uje prvky **seÅ™azenÃ© podle klÃ­Äe**.

---

#### ZÃ¡kladnÃ­ vlastnosti

- KlÃ­Äe jsou **seÅ™azenÃ© pÅ™irozenÃ½m zpÅ¯sobem** (`Comparable`) nebo pomocÃ­ zadanÃ©ho `Comparator`.
- **NeumoÅ¾Åˆuje `null` klÃ­Ä**, ale hodnoty `null` jsou povoleny.
- ImplementovÃ¡na pomocÃ­ **vyvÃ¡Å¾enÃ©ho binÃ¡rnÃ­ho stromu (Red-Black Tree)**.
- TypickÃ¡ sloÅ¾itost operacÃ­: **`O(log n)`**.

---

#### Jak funguje

- KaÅ¾dÃ½ novÃ½ klÃ­Ä je umÃ­stÄ›n do stromu podle srovnÃ¡nÃ­ s ostatnÃ­mi klÃ­Äi.
- DÃ­ky tomu je moÅ¾nÃ© efektivnÄ› hledat, pÅ™idÃ¡vat a mazat, ale operace jsou pomalejÅ¡Ã­ neÅ¾ u `HashMap`.

---

#### PÅ™Ã­klad pouÅ¾itÃ­

```java
import java.util.TreeMap;

public class Main {
    public static void main(String[] args) {
        TreeMap<String, Integer> map = new TreeMap<>();

        map.put("Jablko", 10);
        map.put("HruÅ¡ka", 5);
        map.put("BanÃ¡n", 7);

        System.out.println("Obsah mapy: " + map);
    }
}
```
#### VÃ½stup programu:
```
Obsah mapy: {BanÃ¡n=7, HruÅ¡ka=5, Jablko=10}
```
_PoznÃ¡mka: VÃ½stup je seÅ™azenÃ½ abecednÄ› podle klÃ­ÄÅ¯._

V TreeMap jsou jednotlivÃ© prvky seÅ™azeny podle hodnoty klÃ­Äe.
TreeMap se pouÅ¾Ã­vÃ¡ (stejnÄ› jako TreeSet) mÃ©nÄ›, kdyÅ¾ potÅ™ebujeme mÃ­t prvky seÅ™azenÃ©.
SeÅ™azenÃ­ klÃ­ÄÅ¯ je nezbytnÃ© v tom pÅ™Ã­padÄ›, kdy potÅ™ebujeme zÃ­skat z mapy:

- nejvÄ›tÅ¡Ã­ Äi nejmenÅ¡Ã­ klÃ­Ä,
- â€podmapuâ€œ v zÃ¡vislosti na hodnotÄ› klÃ­Äe.

TreeMap podporuje vÅ¡echny operace ze tÅ™Ã­dy HashMap a pÅ™idÃ¡vÃ¡ k nim jeÅ¡tÄ›:

- zÃ­skÃ¡nÃ­ nejmenÅ¡Ã­ho klÃ­Äe
- zÃ­skÃ¡nÃ­ nejvÄ›tÅ¡Ã­ho klÃ­Äe