<div align="center" style="margin-top: 16px;">
    <strong>OtÃ¡zka 4</strong>
</div>

<nav style="
    position: sticky;
    top: 0;
    z-index: 100;
    background: rgba(0,0,0,0.8);
    padding: 8px 0 4px 0;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    text-align: center;
">
    <a href="03.md" style="color:white; text-decoration:none; margin: 0 16px;">â¬…ï¸ PÅ™edchozÃ­</a>
    <a href="../README.md" style="color:white; text-decoration:none; margin: 0 16px;">ğŸ  DomÅ¯</a>
    <a href="05.md" style="color:white; text-decoration:none; margin: 0 16px;">NÃ¡sledujÃ­cÃ­ â¡ï¸</a>
</nav>

# NÃ¡vrhovÃ© vzory a jejich vyuÅ¾itÃ­ pro zlepÅ¡enÃ­ objektovÃ©ho nÃ¡vrhu aplikacÃ­

**OtÃ¡zka:** PouÅ¾itÃ­ nÃ¡vrhovÃ½ch vzorÅ¯ pro vytvÃ¡Å™enÃ­ instancÃ­ objektÅ¯ (napÅ™. AbstraktnÃ­ tovÃ¡rna, Stavitel) a omezenÃ­ mnoÅ¾stvÃ­
objektÅ¯ (napÅ™. JedinÃ¡Äek); vyuÅ¾itÃ­ nÃ¡vrhovÃ½ch vzorÅ¯ Å™eÅ¡Ã­cÃ­ch chovÃ¡nÃ­ systÃ©mu (napÅ™. Stav, PÅ™Ã­kaz); nÃ¡vrhovÃ© vzory tÃ½kajÃ­cÃ­ se struktury aplikace (napÅ™. DekorÃ¡tor)

---

### NÃ¡vrhovÃ© vzory
NÃ¡vrhovÃ© vzory jsou metodiky (Å¡ablony) pro Å™eÅ¡enÃ­ rÅ¯znÃ½ch problÃ©mÅ¯, se kterÃ½mi se vÃ½vojÃ¡Å™ mÅ¯Å¾e setkat.
Existuje 23 zÃ¡kladnÃ­ch vzorÅ¯, od kterÃ½ch se odvozujÃ­ dalÅ¡Ã­.
Vzorem mÅ¯Å¾e bÃ½t jakÃ©koliv Å™eÅ¡enÃ­ problÃ©mu.

Velmi Äasto se uÅ¾Ã­vajÃ­ pÅ™i objektovÄ› orientovanÃ©m programovÃ¡nÃ­, kdy je tÅ™eba Å™eÅ¡it programÃ¡torskÃ© postupy a dojÃ­t ke
vhodnÃ½m nÃ¡vrhÅ¯m (Best practise), abychom se pozdÄ›ji vyhnuli nutnosti pÅ™episovat nÃ¡Å¡ kÃ³d kvÅ¯li Å¡patnÃ©mu nÃ¡vrhu.
NejednÃ¡ se o knihovnu nebo ÄÃ¡st zdrojovÃ©ho kÃ³du, kterÃ¡ by se dala pÅ™Ã­mo vloÅ¾it do naÅ¡eho programu.
ObjektovÄ› orientovanÃ© nÃ¡vrhovÃ© vzory typicky ukazujÃ­ vztahy a interakce mezi tÅ™Ã­dami a objekty, aniÅ¾ by urÄovaly
implementaci konkrÃ©tnÃ­ tÅ™Ã­dy.

NÃ¡vrhovÃ© vzory dÄ›lÃ­me do tÅ™Ã­ zÃ¡kladnÃ­ch skupin:

- `TvoÅ™ivÃ© vzory` - Å™eÅ¡Ã­ problÃ©my okolo vytvÃ¡Å™enÃ­ objektÅ¯ Äili jako zajiÅ¡tÄ›nÃ­
  sprÃ¡vnÃ©ho poÄtu instancÃ­, vÃ½bÄ›r vhodnÃ© tÅ™Ã­dy novÃ©ho objektu atp.
- `StrukturÃ¡lnÃ­ vzory` - snahou je zpÅ™ehlednit, resp. vhodnÄ›
  strukturovat systÃ©m. ZabÃ½vajÃ­ se uspoÅ™Ã¡dÃ¡nÃ­m a propojenÃ­m objektÅ¯
- `Vzory chovÃ¡nÃ­` - zapouzdÅ™Ã­ urÄitÃ© procesy provÃ¡dÄ›nÃ© v systÃ©mu.
  NapÅ™. jak zajistit spoluprÃ¡ci nÄ›kolika tÅ™Ã­d pÅ™i Å™eÅ¡enÃ­ problÃ©mu.

### TvoÅ™ivÃ© vzory

1. **TovÃ¡rnÃ­ metoda** (Factory method)

- nahrazuje pÅ™Ã­mÃ© volÃ¡nÃ­ konstruktoru tÅ™Ã­dy (operÃ¡tor `new`) volÃ¡nÃ­m speciÃ¡lnÃ­ tovÃ¡rnÃ­ metody
- objekty vrÃ¡cenÃ© tovÃ¡rnÃ­ metodou se oznaÄujÃ­ jako produkty
- konstruktor mÅ¯Å¾e poÅ¾adovat spoustu argumentÅ¯ a rÅ¯znÃ¡ nastavenÃ­, to nechÃ¡m na tovÃ¡rnÃ­ metodÄ› a instance tÅ™Ã­d si
  vytvÃ¡Å™Ã­m zjednoduÅ¡enÄ› pomocÃ­ nÃ­
- obÄas ani nepotÅ™ebuji nebo nechci znÃ¡t, jakÃ© konkrÃ©tnÃ­ objekty mi metoda vytvÃ¡Å™Ã­

![TovÃ¡rnÃ­ metoda](img/factory-method.png)

2. **TovÃ¡rna** (Factory)

- poskytuje rozhranÃ­ pro vytvÃ¡Å™enÃ­ instancÃ­ objektÅ¯ v nadtÅ™Ã­dÄ›, pÅ™iÄemÅ¾ podtÅ™Ã­dy mohou mÄ›nit typ vytvÃ¡Å™enÃ½ch objektÅ¯
- tovÃ¡rna se Äasto implementuje jako samostatnÃ¡ tÅ™Ã­da s jednou nebo vÃ­ce tovÃ¡rnÃ­mi metodami
- umoÅ¾Åˆuje vytvÃ¡Å™enÃ­ objektÅ¯ bez specifikace pÅ™esnÃ© tÅ™Ã­dy, kterÃ¡ mÃ¡ bÃ½t vytvoÅ™ena
- logika rozhodujÃ­cÃ­, kterÃ½ objekt vytvoÅ™it je centralizovÃ¡na prÃ¡vÄ› v tovÃ¡rnÄ›
  factory

3. **AbstraktnÃ­ tovÃ¡rna** (Abstract factory)

- vzor dovolujÃ­cÃ­ vytvÃ¡Å™et rodiny pÅ™Ã­buznÃ½ch objektÅ¯ bez urÄenÃ­ jejich konkrÃ©tnÃ­ch tÅ™Ã­d
- umoÅ¾Åˆuje vytvoÅ™enÃ­ skupiny souvisejÃ­cÃ­ch objektÅ¯ (napÅ™. rÅ¯znÃ© druhy widgetÅ¯ v GUI) s pouÅ¾itÃ­m jedinÃ© tovÃ¡rny
- nikdo nemÅ¯Å¾e vytvoÅ™it chybnou instanci
- abstraktnÃ­ tovÃ¡rna ani nevÃ­, kterÃ½ typ instancÃ­ vytvÃ¡Å™Ã­
- stejnÄ› jako obyÄejnÃ¡ tovÃ¡rna vnitÅ™nÄ› operuje pomocÃ­ tovÃ¡rnÃ­ch metod, tak abstraktnÃ­ tovÃ¡rna vnitÅ™nÄ› operuje pomocÃ­
  obyÄejnÃ½ch tovÃ¡ren

![AbstraktnÃ­ tovÃ¡rna](img/abstract-factory.png)

4. **Stavitel** (Builder)

- nÃ¡vrhovÃ½ vzor, kterÃ½ se pouÅ¾Ã­vÃ¡ pro konstrukci opravdu sloÅ¾itÃ½ch objektÅ¯
- pomocÃ­ nÄ›j se objekt vytvÃ¡Å™Ã­ po jednotlivÃ½ch krocÃ­ch
- jednotlivÃ© koneÄnÃ© objekty mohou vypadat rÅ¯znÄ› podle toho, kterÃ© kroky pÅ™i tvorbÄ› budou vykonÃ¡ny

- builder se implementuje tak, Å¾e udÄ›lÃ¡me nÄ›kolik samostatnÃ½ch tÅ™Ã­d, kterÃ© se budou
  specializovat na tvorbu rÅ¯znÃ½ch variant vytvÃ¡Å™enÃ©ho objektu
- kaÅ¾dÃ¡ tÅ™Ã­da bude implementovat vÅ¡echny kroky nezbytnÃ© k jeho vytvoÅ™enÃ­
- Å™Ã­dÃ­cÃ­ tÅ™Ã­da dostane Å™eÄeno, kterÃ©ho buildera pouÅ¾ije a zavolÃ¡ metody pro vytvoÅ™enÃ­ produktu

- na rozdÃ­l od tovÃ¡rny, kterÃ¡ vyprodukuje produkt hned, tak builder jej vytvÃ¡Å™Ã­ postupnÄ› volÃ¡nÃ­m jednotlivÃ½ch metod
- nenÃ­ to tedy alternativa tovÃ¡rny
- tady se nevyrÃ¡bÃ­ rÅ¯znÃ­ potomci produktu, ale stÃ¡le jen jeden a ten samÃ½ produkt, jen mÅ¯Å¾e
  vypadat rÅ¯znÄ›

![Stavitel](img/builder.png)

5. **JedinÃ¡Äek** (Singleton)

- jedinÃ¡Äek je objekt jedinÃ½ svÃ©ho druhu v celÃ© aplikaci
- je to nÃ¡vrhovÃ½ vzor, kterÃ½ umoÅ¾Åˆuje zajistit, aby tÅ™Ã­da mÄ›la pouze jednu instanci a zÃ¡roveÅˆ poskytovala globÃ¡lnÃ­
  pÅ™Ã­stupovÃ½ bod k tÃ©to instanci
- jedinÃ¡Äek se implementuje tak, Å¾e oznaÄÃ­me konstruktor tÅ™Ã­dy jako *private* a vytvoÅ™Ã­me statickou metodu, kterÃ¡ nÃ¡m
  bude zastupovat konstruktor
- metoda bude kontrolovat, jestli uÅ¾ jedinÃ¡Äek existuje, pokud ne, tak ho vytvoÅ™Ã­ pomocÃ­ skrytÃ©ho konstruktoru
- pokud jedinÃ¡Äek uÅ¾ bude existovat, tak jej vrÃ¡tÃ­

![JedinÃ¡Äek](img/singleton.png)

### StrukturÃ¡lnÃ­ vzory

1. **Stav**

- dovoluje objektu zmÄ›nit jeho vnitÅ™nÃ­ chovÃ¡nÃ­ na zÃ¡kladnÄ› vnitÅ™nÃ­ stavovÃ© zmÄ›ny
- pokud Å™eÅ¡Ã­me v nÄ›kolika metodÃ¡ch sÃ©rie obdobnÃ½ch podmÃ­nek, poruÅ¡ujeme princip DRY
- jednÃ¡ se Äasto o Å™etÄ›zce podmÃ­nek napÅ™.: je student prezenÄnÃ­ pakâ€¦, pokud je dÃ¡lkovÃ½, takâ€¦
- implementaÄnÄ› se tento problÃ©m Äasto Å™eÅ¡Ã­ pomocÃ­ rÅ¯znÃ½ch zanoÅ™enÃ½ch switch pÅ™Ã­kazÅ¯

- tyto podmÃ­nky je moÅ¾nÃ© rozdÄ›lit do stavÅ¯
- stavy jsou pak uloÅ¾eny jako samostatnÃ© tÅ™Ã­dy
- tyto tÅ™Ã­dy neobsahujÃ­ vÄ›tÅ¡inou Å¾Ã¡dnÃ© atributy, ale pouze metody, v jistÃ½ch jazycÃ­ch (Java, Kotlin) lze pak stavy
  implementovat ÄistÄ› pomocÃ­ rozhranÃ­
- kaÅ¾dÃ¡ metoda vnoÅ™enÃ© stavovÃ© tÅ™Ã­dy implementuje jen jednu ÄÃ¡st
  podmÃ­nky coÅ¾ je velmi pÅ™ehlednÃ© a rozÅ¡iÅ™itelnÃ©

- stav se implementuje tak, Å¾e mÃ¡me kontextovou tÅ™Ã­du, kterÃ¡ v sobÄ› stav drÅ¾Ã­ jako atribut
- na zÃ¡kladÄ› toho, v jakÃ©m stavu se nachÃ¡zÃ­, se vykonÃ¡vajÃ­ rÅ¯znÃ© metody
- kontextovÃ¡ tÅ™Ã­da potom svÃ© vlastnÃ­ metody zaloÅ¾enÃ© na stavech volÃ¡ tak, Å¾e pouÅ¾ije metodu stavu
- podle toho, jakÃ½ zrovna stav bude uloÅ¾enÃ½ v atributu tÅ™Ã­dy, podle toho se zavolÃ¡ konkrÃ©tnÃ­ implementace
- long live polymorfismus a dÄ›diÄnost, dÃ­ky kterÃ½m je toto vÅ¯bec moÅ¾nÃ©

![Stav](img/state.png)

### Vzory chovÃ¡nÃ­

1. **DekorÃ¡tor**

- nÃ¡vrhovÃ½ vzor, kterÃ½ umoÅ¾Åˆuje pÅ™ipojit k objektÅ¯m novÃ© chovÃ¡nÃ­
- dokÃ¡Å¾e umÃ­stit objekty do speciÃ¡lnÃ­ch obalÅ¯ (jinÃ½ch objektÅ¯), kterÃ© obsahujÃ­ novÃ© chovÃ¡nÃ­
- pÅ™i implementaci tedy tÅ™Ã­du obalÃ­me do jinÃ© tÅ™Ã­dy, kterÃ¡ bude vÄ›tÅ¡inou volat pÅ¯vodnÃ­ metody a jen doplnÃ­ poÅ¾adovanou
  novou funkcionalitu
- toto obalenÃ­ je implementovÃ¡no pomocÃ­ agregaÄnÃ­ vazby, takÅ¾e je dynamickÃ© a lze ho mÄ›nit za bÄ›hu programu
- zkrÃ¡cenÄ› tedy dekorÃ¡tor obalÃ­ objekt mÃ­sto aby se dÄ›dilo a to pÅ™inÃ¡Å¡Ã­ dynamickÃ© rozÅ¡iÅ™ovÃ¡nÃ­ funkcionality
  ![DekorÃ¡tor](img/decorator.png)