<div align="center" style="margin-top: 16px;">
    <strong>Ot√°zka 4</strong>
</div>

<nav style="
    position: sticky;
    top: 0;
    z-index: 100;
    background: rgba(0,0,0,0.8);
    padding: 8px 0 4px 0;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    text-align: center;
">
    <a href="03.md" style="color:white; text-decoration:none; margin: 0 16px;">‚¨ÖÔ∏è P≈ôedchoz√≠</a>
    <a href="../README.md" style="color:white; text-decoration:none; margin: 0 16px;">üè† Dom≈Ø</a>
    <a href="05.md" style="color:white; text-decoration:none; margin: 0 16px;">N√°sleduj√≠c√≠ ‚û°Ô∏è</a>
</nav>

# N√°vrhov√© vzory a jejich vyu≈æit√≠ pro zlep≈°en√≠ objektov√©ho n√°vrhu aplikac√≠

<span style="background:#ffebee; color:#b71c1c; padding:2px 8px; border-radius:4px; font-weight:bold;">üî¥ Kl√≠ƒçov√° ot√°zka 4</span>

<div align="center">

[<kbd>üåê Top zdroj (EN)</kbd>](https://refactoring.guru/design-patterns/factory-method)  
[<kbd>üåê Top zdroj (CZ)</kbd>](https://www.algoritmy.net/article/51224/Navrhove-vzory)

</div>

---

**Ot√°zka:** Pou≈æit√≠ n√°vrhov√Ωch vzor≈Ø pro vytv√°≈ôen√≠ instanc√≠ objekt≈Ø (nap≈ô. Abstraktn√≠ tov√°rna, Stavitel) a omezen√≠ mno≈æstv√≠
objekt≈Ø (nap≈ô. Jedin√°ƒçek); vyu≈æit√≠ n√°vrhov√Ωch vzor≈Ø ≈ôe≈°√≠c√≠ch chov√°n√≠ syst√©mu (nap≈ô. Stav, P≈ô√≠kaz); n√°vrhov√© vzory t√Ωkaj√≠c√≠ se struktury aplikace (nap≈ô. Dekor√°tor)

---

### N√°vrhov√© vzory
N√°vrhov√© vzory jsou metodiky (≈°ablony) pro ≈ôe≈°en√≠ r≈Øzn√Ωch probl√©m≈Ø, se kter√Ωmi se v√Ωvoj√°≈ô m≈Ø≈æe setkat.
Existuje 23 z√°kladn√≠ch vzor≈Ø, od kter√Ωch se odvozuj√≠ dal≈°√≠.
Vzorem m≈Ø≈æe b√Ωt jak√©koliv ≈ôe≈°en√≠ probl√©mu.

Velmi ƒçasto se u≈æ√≠vaj√≠ p≈ôi objektovƒõ orientovan√©m programov√°n√≠, kdy je t≈ôeba ≈ôe≈°it program√°torsk√© postupy a doj√≠t ke
vhodn√Ωm n√°vrh≈Øm (Best practise), abychom se pozdƒõji vyhnuli nutnosti p≈ôepisovat n√°≈° k√≥d kv≈Øli ≈°patn√©mu n√°vrhu.
Nejedn√° se o knihovnu nebo ƒç√°st zdrojov√©ho k√≥du, kter√° by se dala p≈ô√≠mo vlo≈æit do na≈°eho programu.
Objektovƒõ orientovan√© n√°vrhov√© vzory typicky ukazuj√≠ vztahy a interakce mezi t≈ô√≠dami a objekty, ani≈æ by urƒçovaly
implementaci konkr√©tn√≠ t≈ô√≠dy.

N√°vrhov√© vzory dƒõl√≠me do t≈ô√≠ z√°kladn√≠ch skupin:

- `Tvo≈ôiv√© vzory` - ≈ôe≈°√≠ probl√©my okolo vytv√°≈ôen√≠ objekt≈Ø ƒçili jako zaji≈°tƒõn√≠
  spr√°vn√©ho poƒçtu instanc√≠, v√Ωbƒõr vhodn√© t≈ô√≠dy nov√©ho objektu atp.
- `Struktur√°ln√≠ vzory` - snahou je zp≈ôehlednit, resp. vhodnƒõ
  strukturovat syst√©m. Zab√Ωvaj√≠ se uspo≈ô√°d√°n√≠m a propojen√≠m objekt≈Ø
- `Vzory chov√°n√≠` - zapouzd≈ô√≠ urƒçit√© procesy prov√°dƒõn√© v syst√©mu.
  Nap≈ô. jak zajistit spolupr√°ci nƒõkolika t≈ô√≠d p≈ôi ≈ôe≈°en√≠ probl√©mu.

### Tvo≈ôiv√© vzory

1. **Tov√°rn√≠ metoda** (Factory method)

- nahrazuje p≈ô√≠m√© vol√°n√≠ konstruktoru t≈ô√≠dy (oper√°tor `new`) vol√°n√≠m speci√°ln√≠ tov√°rn√≠ metody
- objekty vr√°cen√© tov√°rn√≠ metodou se oznaƒçuj√≠ jako produkty
- konstruktor m≈Ø≈æe po≈æadovat spoustu argument≈Ø a r≈Øzn√° nastaven√≠, to nech√°m na tov√°rn√≠ metodƒõ a instance t≈ô√≠d si
  vytv√°≈ô√≠m zjednodu≈°enƒõ pomoc√≠ n√≠
- obƒças ani nepot≈ôebuji nebo nechci zn√°t, jak√© konkr√©tn√≠ objekty mi metoda vytv√°≈ô√≠

![Tov√°rn√≠ metoda](img/factory-method.png)

P≈ô√≠klad v Javƒõ:
```java
class Auto {
    private String typ;

    public Auto(String typ) {
        this.typ = typ;
    }

    public String info() {
        return "Auto typu: " + typ;
    }
}

class AutoTovarna {
    public static Auto vytvorAuto(String typ) {
        if ("sedan".equals(typ)) {
            return new Auto("Sedan");
        } else if ("suv".equals(typ)) {
            return new Auto("SUV");
        } else {
            return new Auto("Nezn√°m√Ω typ");
        }
    }
}

// Pou≈æit√≠
public class FactoryMethodDemo {
    public static void main(String[] args) {
        Auto auto1 = AutoTovarna.vytvorAuto("sedan");
        Auto auto2 = AutoTovarna.vytvorAuto("suv");
        System.out.println(auto1.info()); // Auto typu: Sedan
        System.out.println(auto2.info()); // Auto typu: SUV
    }
}
```

2. **Tov√°rna** (Factory)

- poskytuje rozhran√≠ pro vytv√°≈ôen√≠ instanc√≠ objekt≈Ø v nadt≈ô√≠dƒõ, p≈ôiƒçem≈æ podt≈ô√≠dy mohou mƒõnit typ vytv√°≈ôen√Ωch objekt≈Ø
- tov√°rna se ƒçasto implementuje jako samostatn√° t≈ô√≠da s jednou nebo v√≠ce tov√°rn√≠mi metodami
- umo≈æ≈àuje vytv√°≈ôen√≠ objekt≈Ø bez specifikace p≈ôesn√© t≈ô√≠dy, kter√° m√° b√Ωt vytvo≈ôena
- logika rozhoduj√≠c√≠, kter√Ω objekt vytvo≈ôit je centralizov√°na pr√°vƒõ v tov√°rnƒõ
  factory

3. **Abstraktn√≠ tov√°rna** (Abstract factory)

- vzor dovoluj√≠c√≠ vytv√°≈ôet rodiny p≈ô√≠buzn√Ωch objekt≈Ø bez urƒçen√≠ jejich konkr√©tn√≠ch t≈ô√≠d
- umo≈æ≈àuje vytvo≈ôen√≠ skupiny souvisej√≠c√≠ch objekt≈Ø (nap≈ô. r≈Øzn√© druhy widget≈Ø v GUI) s pou≈æit√≠m jedin√© tov√°rny
- nikdo nem≈Ø≈æe vytvo≈ôit chybnou instanci
- abstraktn√≠ tov√°rna ani nev√≠, kter√Ω typ instanc√≠ vytv√°≈ô√≠
- stejnƒõ jako obyƒçejn√° tov√°rna vnit≈ônƒõ operuje pomoc√≠ tov√°rn√≠ch metod, tak abstraktn√≠ tov√°rna vnit≈ônƒõ operuje pomoc√≠
  obyƒçejn√Ωch tov√°ren

![Abstraktn√≠ tov√°rna](img/abstract-factory.png)

P≈ô√≠klad v Javƒõ:
```java
// Abstraktn√≠ produkty
interface Tlacitko {
    String klikni();
}

interface Okno {
    String zobraz();
}

// Konkr√©tn√≠ produkty pro Windows
class WindowsTlacitko implements Tlacitko {
    public String klikni() {
        return "Windows tlaƒç√≠tko kliknuto";
    }
}

class WindowsOkno implements Okno {
    public String zobraz() {
        return "Windows okno zobrazeno";
    }
}

// Konkr√©tn√≠ produkty pro Mac
class MacTlacitko implements Tlacitko {
    public String klikni() {
        return "Mac tlaƒç√≠tko kliknuto";
    }
}

class MacOkno implements Okno {
    public String zobraz() {
        return "Mac okno zobrazeno";
    }
}

// Abstraktn√≠ tov√°rna
interface GUITovarna {
    Tlacitko vytvorTlacitko();
    Okno vytvorOkno();
}

// Konkr√©tn√≠ tov√°rny
class WindowsTovarna implements GUITovarna {
    public Tlacitko vytvorTlacitko() {
        return new WindowsTlacitko();
    }
    public Okno vytvorOkno() {
        return new WindowsOkno();
    }
}

class MacTovarna implements GUITovarna {
    public Tlacitko vytvorTlacitko() {
        return new MacTlacitko();
    }
    public Okno vytvorOkno() {
        return new MacOkno();
    }
}

// Pou≈æit√≠
public class AbstractFactoryDemo {
    public static void main(String[] args) {
        GUITovarna tovarna = new WindowsTovarna();
        Tlacitko tlacitko = tovarna.vytvorTlacitko();
        Okno okno = tovarna.vytvorOkno();
        System.out.println(tlacitko.klikni()); // Windows tlaƒç√≠tko kliknuto
        System.out.println(okno.zobraz());     // Windows okno zobrazeno
    }
}
```

4. **Stavitel** (Builder)

- n√°vrhov√Ω vzor, kter√Ω se pou≈æ√≠v√° pro konstrukci opravdu slo≈æit√Ωch objekt≈Ø
- pomoc√≠ nƒõj se objekt vytv√°≈ô√≠ po jednotliv√Ωch kroc√≠ch
- jednotliv√© koneƒçn√© objekty mohou vypadat r≈Øznƒõ podle toho, kter√© kroky p≈ôi tvorbƒõ budou vykon√°ny

- builder se implementuje tak, ≈æe udƒõl√°me nƒõkolik samostatn√Ωch t≈ô√≠d, kter√© se budou
  specializovat na tvorbu r≈Øzn√Ωch variant vytv√°≈ôen√©ho objektu
- ka≈æd√° t≈ô√≠da bude implementovat v≈°echny kroky nezbytn√© k jeho vytvo≈ôen√≠
- ≈ô√≠d√≠c√≠ t≈ô√≠da dostane ≈ôeƒçeno, kter√©ho buildera pou≈æije a zavol√° metody pro vytvo≈ôen√≠ produktu

- na rozd√≠l od tov√°rny, kter√° vyprodukuje produkt hned, tak builder jej vytv√°≈ô√≠ postupnƒõ vol√°n√≠m jednotliv√Ωch metod
- nen√≠ to tedy alternativa tov√°rny
- tady se nevyr√°b√≠ r≈Øzn√≠ potomci produktu, ale st√°le jen jeden a ten sam√Ω produkt, jen m≈Ø≈æe
  vypadat r≈Øznƒõ

![Stavitel](img/builder.png)

P≈ô√≠klad v Javƒõ:
```java
class Pocitac {
    private String cpu;
    private String ram;
    private String disk;

    public void setCpu(String cpu) {
        this.cpu = cpu;
    }
    public void setRam(String ram) {
        this.ram = ram;
    }
    public void setDisk(String disk) {
        this.disk = disk;
    }

    @Override
    public String toString() {
        return "Poƒç√≠taƒç: CPU=" + cpu + ", RAM=" + ram + ", Disk=" + disk;
    }
}

class PocitacBuilder {
    private Pocitac pocitac;

    public PocitacBuilder() {
        this.pocitac = new Pocitac();
    }

    public PocitacBuilder nastavitCpu(String cpu) {
        pocitac.setCpu(cpu);
        return this;
    }

    public PocitacBuilder nastavitRam(String ram) {
        pocitac.setRam(ram);
        return this;
    }

    public PocitacBuilder nastavitDisk(String disk) {
        pocitac.setDisk(disk);
        return this;
    }

    public Pocitac sestavit() {
        return pocitac;
    }
}

// Pou≈æit√≠
public class BuilderDemo {
    public static void main(String[] args) {
        Pocitac pocitac = new PocitacBuilder()
            .nastavitCpu("Intel i7")
            .nastavitRam("16GB")
            .nastavitDisk("1TB SSD")
            .sestavit();
        System.out.println(pocitac); // Poƒç√≠taƒç: CPU=Intel i7, RAM=16GB, Disk=1TB SSD
    }
}
```

1. **Jedin√°ƒçek** (Singleton)

- jedin√°ƒçek je objekt jedin√Ω sv√©ho druhu v cel√© aplikaci
- je to n√°vrhov√Ω vzor, kter√Ω umo≈æ≈àuje zajistit, aby t≈ô√≠da mƒõla pouze jednu instanci a z√°rove≈à poskytovala glob√°ln√≠
  p≈ô√≠stupov√Ω bod k t√©to instanci
- jedin√°ƒçek se implementuje tak, ≈æe oznaƒç√≠me konstruktor t≈ô√≠dy jako *private* a vytvo≈ô√≠me statickou metodu, kter√° n√°m
  bude zastupovat konstruktor
- metoda bude kontrolovat, jestli u≈æ jedin√°ƒçek existuje, pokud ne, tak ho vytvo≈ô√≠ pomoc√≠ skryt√©ho konstruktoru
- pokud jedin√°ƒçek u≈æ bude existovat, tak jej vr√°t√≠

![Jedin√°ƒçek](img/singleton.png)

P≈ô√≠klad v Javƒõ:
```java
class Databaze {
    private static Databaze instance;
    public String pripojeni;

    private Databaze() {
        pripojeni = "P≈ôipojeno k datab√°zi";
    }

    public static Databaze getInstance() {
        if (instance == null) {
            instance = new Databaze();
        }
        return instance;
    }

    public String dotaz(String sql) {
        return "Vykon√°v√°m dotaz: " + sql;
    }
}

// Pou≈æit√≠
public class SingletonDemo {
    public static void main(String[] args) {
        Databaze db1 = Databaze.getInstance();
        Databaze db2 = Databaze.getInstance();

        System.out.println(db1 == db2); // true - stejn√° instance
        System.out.println(db1.dotaz("SELECT * FROM users")); // Vykon√°v√°m dotaz: SELECT * FROM users
    }
}
```

### Struktur√°ln√≠ vzory

1. **Stav**

- dovoluje objektu zmƒõnit jeho vnit≈ôn√≠ chov√°n√≠ na z√°kladnƒõ vnit≈ôn√≠ stavov√© zmƒõny
- pokud ≈ôe≈°√≠me v nƒõkolika metod√°ch s√©rie obdobn√Ωch podm√≠nek, poru≈°ujeme princip DRY
- jedn√° se ƒçasto o ≈ôetƒõzce podm√≠nek nap≈ô.: je student prezenƒçn√≠ pak‚Ä¶, pokud je d√°lkov√Ω, tak‚Ä¶
- implementaƒçnƒõ se tento probl√©m ƒçasto ≈ôe≈°√≠ pomoc√≠ r≈Øzn√Ωch zano≈ôen√Ωch switch p≈ô√≠kaz≈Ø

- tyto podm√≠nky je mo≈æn√© rozdƒõlit do stav≈Ø
- stavy jsou pak ulo≈æeny jako samostatn√© t≈ô√≠dy
- tyto t≈ô√≠dy neobsahuj√≠ vƒõt≈°inou ≈æ√°dn√© atributy, ale pouze metody, v jist√Ωch jazyc√≠ch (Java, Kotlin) lze pak stavy
  implementovat ƒçistƒõ pomoc√≠ rozhran√≠
- ka≈æd√° metoda vno≈ôen√© stavov√© t≈ô√≠dy implementuje jen jednu ƒç√°st
  podm√≠nky co≈æ je velmi p≈ôehledn√© a roz≈°i≈ôiteln√©

- stav se implementuje tak, ≈æe m√°me kontextovou t≈ô√≠du, kter√° v sobƒõ stav dr≈æ√≠ jako atribut
- na z√°kladƒõ toho, v jak√©m stavu se nach√°z√≠, se vykon√°vaj√≠ r≈Øzn√© metody
- kontextov√° t≈ô√≠da potom sv√© vlastn√≠ metody zalo≈æen√© na stavech vol√° tak, ≈æe pou≈æije metodu stavu
- podle toho, jak√Ω zrovna stav bude ulo≈æen√Ω v atributu t≈ô√≠dy, podle toho se zavol√° konkr√©tn√≠ implementace
- long live polymorfismus a dƒõdiƒçnost, d√≠ky kter√Ωm je toto v≈Øbec mo≈æn√©

![Stav](img/state.png)

P≈ô√≠klad v Javƒõ:
```java
class Telefon {
    private Stav stav;

    public Telefon() {
        this.stav = new VypnutyStav();
    }

    public void nastavitStav(Stav stav) {
        this.stav = stav;
    }

    public void stisknoutTlacitko() {
        stav.stisknoutTlacitko(this);
    }
}

interface Stav {
    void stisknoutTlacitko(Telefon telefon);
}

class VypnutyStav implements Stav {
    public void stisknoutTlacitko(Telefon telefon) {
        System.out.println("Telefon se zap√≠n√°...");
        telefon.nastavitStav(new ZapnutyStav());
    }
}

class ZapnutyStav implements Stav {
    public void stisknoutTlacitko(Telefon telefon) {
        System.out.println("Telefon se vyp√≠n√°...");
        telefon.nastavitStav(new VypnutyStav());
    }
}

// Pou≈æit√≠
public class StateDemo {
    public static void main(String[] args) {
        Telefon telefon = new Telefon();
        telefon.stisknoutTlacitko(); // Telefon se zap√≠n√°...
        telefon.stisknoutTlacitko(); // Telefon se vyp√≠n√°...
    }
}
```

### Vzory chov√°n√≠

1. **Dekor√°tor**

- n√°vrhov√Ω vzor, kter√Ω umo≈æ≈àuje p≈ôipojit k objekt≈Øm nov√© chov√°n√≠
- dok√°≈æe um√≠stit objekty do speci√°ln√≠ch obal≈Ø (jin√Ωch objekt≈Ø), kter√© obsahuj√≠ nov√© chov√°n√≠
- p≈ôi implementaci tedy t≈ô√≠du obal√≠me do jin√© t≈ô√≠dy, kter√° bude vƒõt≈°inou volat p≈Øvodn√≠ metody a jen dopln√≠ po≈æadovanou
  novou funkcionalitu
- toto obalen√≠ je implementov√°no pomoc√≠ agregaƒçn√≠ vazby, tak≈æe je dynamick√© a lze ho mƒõnit za bƒõhu programu
- zkr√°cenƒõ tedy dekor√°tor obal√≠ objekt m√≠sto aby se dƒõdilo a to p≈ôin√°≈°√≠ dynamick√© roz≈°i≈ôov√°n√≠ funkcionality
  ![Dekor√°tor](img/decorator.png)

P≈ô√≠klad v Javƒõ:
```java
interface Kava {
    int cena();
    String popis();
}

class ZakladniKava implements Kava {
    public int cena() {
        return 30;
    }
    public String popis() {
        return "Z√°kladn√≠ k√°va";
    }
}

abstract class KavaDekorator implements Kava {
    protected Kava kava;
    public KavaDekorator(Kava kava) {
        this.kava = kava;
    }
    public int cena() {
        return kava.cena();
    }
    public String popis() {
        return kava.popis();
    }
}

class Mleko extends KavaDekorator {
    public Mleko(Kava kava) {
        super(kava);
    }
    public int cena() {
        return kava.cena() + 10;
    }
    public String popis() {
        return kava.popis() + " + ml√©ko";
    }
}

class Cukr extends KavaDekorator {
    public Cukr(Kava kava) {
        super(kava);
    }
    public int cena() {
        return kava.cena() + 5;
    }
    public String popis() {
        return kava.popis() + " + cukr";
    }
}

// Pou≈æit√≠
public class DekoratorDemo {
    public static void main(String[] args) {
        Kava kava = new ZakladniKava();
        Kava kavaSMlekem = new Mleko(kava);
        Kava kavaSMlekemACukrem = new Cukr(kavaSMlekem);

        System.out.println(kavaSMlekemACukrem.popis() + ": " + kavaSMlekemACukrem.cena() + " Kƒç");
        // Z√°kladn√≠ k√°va + ml√©ko + cukr: 45 Kƒç
    }
}
```