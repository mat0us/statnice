<div align="center" style="margin-top: 16px;">
    <strong>OtÃ¡zka 6</strong>
</div>

<nav style="
    position: sticky;
    top: 0;
    z-index: 100;
    background: rgba(0,0,0,0.8);
    padding: 8px 0 4px 0;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    text-align: center;
">
    <a href="08.md" style="color:white; text-decoration:none; margin: 0 16px;">â¬…ï¸ PÅ™edchozÃ­</a>
    <a href="../README.md" style="color:white; text-decoration:none; margin: 0 16px;">ğŸ  DomÅ¯</a>
    <a href="10.md" style="color:white; text-decoration:none; margin: 0 16px;">NÃ¡sledujÃ­cÃ­ â¡ï¸</a>
</nav>

# 9. VÃ½voj vÃ­cevlÃ¡knovÃ½ch aplikacÃ­ v C++/JavÄ›

**OtÃ¡zka:** MoÅ¾nÃ© dÅ¯vody pouÅ¾itÃ­ vÃ­ce vlÃ¡ken, Å¾ivotnÃ­ cyklus vlÃ¡kna, ÃºskalÃ­ pÅ™Ã­stupu vlÃ¡ken ke spoleÄnÃ½m datovÃ½m strukturÃ¡m. Diskuse o moÅ¾nÃ©m vyuÅ¾itÃ­ vÃ­ce vlÃ¡ken v aplikaci vytvoÅ™enÃ© v rÃ¡mci zÃ¡vÄ›reÄnÃ© prÃ¡ce

---

### VlÃ¡kna obecnÄ›

VlÃ¡kna pÅ™edstavujÃ­ zpÅ¯sob, jak v rÃ¡mci jednoho procesu provÃ¡dÄ›t vÃ­ce ÄinnostÃ­ paralelnÄ› (na poÄÃ­taÄi s vÃ­ce procesory
nebo s vÃ­cejÃ¡drovÃ½m procesorem) nebo pseudoparalelnÄ› (na poÄÃ­taÄi s jednÃ­m jednojÃ¡drovÃ½m procesorem).
VlÃ¡kno je posloupnostÃ­ po sobÄ› jdoucÃ­ch operacÃ­ (pÅ™Ã­kazÅ¯, instrukcÃ­, ...).
KaÅ¾dÃ½ proces je tvoÅ™en nejmÃ©nÄ› jednÃ­m vlÃ¡knem.
V rÃ¡mci kaÅ¾dÃ©ho z vlÃ¡ken je vykonÃ¡vÃ¡n kÃ³d nezÃ¡visle na ostatnÃ­ch vlÃ¡knech.
VÃ­cevlÃ¡knovÃ© programovÃ¡nÃ­ mÃ¡ smysl napÅ™Ã­klad u tÄ›chto typÅ¯ Ãºloh:

- u ÄasovÄ› nÃ¡roÄnÃ½ch vÃ½poÄtÅ¯, kdy jedno vlÃ¡kno provÃ¡dÃ­ vÃ½poÄet a druhÃ© vlÃ¡kno mÅ¯Å¾e prÅ¯bÄ›Å¾nÄ› informovat uÅ¾ivatele o stavu
  vÃ½poÄtu,
- za ÃºÄelem vyuÅ¾itÃ­ Äasu strÃ¡venÃ©ho ÄekÃ¡nÃ­m na vstup od uÅ¾ivatele,
- pokud program simuluje aktivitu vÃ­ce entit, napÅ™. pohyb molekul plynu,
- u klientâ€“server aplikacÃ­, kde bÃ½vÃ¡ Äasto pro obsluhu kaÅ¾dÃ©ho pÅ™ipojenÃ©ho klienta vytvoÅ™eno samostatnÃ© vlÃ¡kno,
- v ÃºlohÃ¡ch typu producentâ€“konzument, kde producent pÅ™ipravuje data, kterÃ¡ konzument spotÅ™ebovÃ¡vÃ¡.

VlÃ¡kna majÃ­ oproti procesÅ¯m Å™adu vÃ½hod:

- VlÃ¡kno se vytvoÅ™Ã­ rychleji neÅ¾ proces.
- VlÃ¡kno se ukonÄÃ­ rychleji neÅ¾ proces.
- Mezi vlÃ¡kny se rychleji pÅ™epÃ­nÃ¡ neÅ¾ mezi procesy.
- Lze dosÃ¡hnout lepÅ¡Ã­ strukturalizace programu.

### VlÃ¡kna v JavÄ›

Java pÅ™Ã­mo podporuje vÃ­cevlÃ¡knovÃ½ bÄ›h programu.
VlÃ¡kno lze vytvoÅ™it dÄ›dÄ›nÃ­m z tÅ™Ã­dy `Thread` nebo implementacÃ­ rozhranÃ­ `Runnable`.

VlÃ¡kno lze vytvoÅ™it jako instanci tÅ™Ã­dy java.lang.Thread nebo jejÃ­ podtÅ™Ã­dy.
V nejjednoduÅ¡Å¡Ã­m pÅ™Ã­padÄ› staÄÃ­ odvodit potomka od tÅ™Ã­dy Thread a pÅ™ekrÃ½t klÃ­Äovou metodu `run()`, kterÃ¡ popisuje, co
vlÃ¡kno pÅ™i svÃ©m bÄ›hu vlastnÄ› dÄ›lÃ¡.
Metoda `run()` vlÃ¡kna se nespouÅ¡tÃ­ pÅ™Ã­mo, ale pomocÃ­ volÃ¡nÃ­ metody `start()` zdÄ›dÄ›nÃ© ze tÅ™Ã­dy `Thread`.

Pro prÃ¡ci s vlÃ¡kny se pouÅ¾Ã­vÃ¡ nÄ›kolik dÅ¯leÅ¾itÃ½ch metod:
- `getState()` - vracÃ­ aktuÃ¡lnÃ­ stav vlÃ¡kna
- `yield()` - mÅ¯Å¾e vlÃ¡kno nabÃ­dnout pÅ™edÃ¡nÃ­ Å™Ã­zenÃ­ jinÃ©mu vlÃ¡knu
- `sleep()` - uspÃ­ vlÃ¡kno na zadanÃ½ poÄet milisekund
- `wait()` - pozastavÃ­ vlÃ¡kno do doby, neÅ¾ bude probuzeno metodou `notify()`, `notifyAll()` nebo bude neÅ¾ bude pÅ™eruÅ¡eno metodou `interrupt()`
- `isAlive()` - zjistÃ­, jestli vlÃ¡kno Å¾ije, tzn. nachÃ¡zÃ­ se mezi spuÅ¡tÄ›nÃ­m metodou start() a ukonÄenÃ­m metody run()
- `join()` - pozastavÃ­ bÄ›h metody vlÃ¡kna, dokud neskonÄÃ­ jinÃ© vlÃ¡kno

VlÃ¡kna je moÅ¾nÃ¡ pÅ™eruÅ¡it.
PÅ™eruÅ¡enÃ­m oznamujeme vlÃ¡knu, Å¾e by mÄ›lo pÅ™estat vykonÃ¡vat svoji bÄ›Å¾nou Äinnost a udÄ›lat nÄ›co jinÃ©ho.
Je na programÃ¡torovi, aby rozhodl, jak bude vlÃ¡kno reagovat na pÅ™eruÅ¡enÃ­.
Je ovÅ¡em obvyklÃ© ukonÄit Äinnost vlÃ¡kna (tedy metody `run()`).
Metoda vyvolÃ¡ vÃ½jimku `InterruptedException`, kterou je tÅ™eba oÅ¡etÅ™it v bloku `catch`.

### Å½ivotnÃ­ cyklus vlÃ¡ken

![Å½ivotnÃ­ cyklus vlÃ¡ken](img/threading.png)

KaÅ¾dÃ© vlÃ¡kno se v kaÅ¾dÃ©m okamÅ¾iku nachÃ¡zÃ­ v jednom z Å¡esti moÅ¾nÃ½ch stavÅ¯.
PÅ™echody mezi tÄ›mito stavy zajiÅ¡Å¥ujÃ­ nejÄastÄ›ji metody tÅ™Ã­dy `Thread`.
Stavy vlÃ¡ken jsou:

- **New** - novÃ© vlÃ¡kno, bylo vytvoÅ™eno pomocÃ­ konstruktoru, ale dosud nebylo spuÅ¡tÄ›no metodou `start()`
- **Runnable** - bÄ›huschopnÃ© vlÃ¡kno, metoda `start()` jiÅ¾ probÄ›hla. TÄ›chto vlÃ¡ken mÅ¯Å¾e bÃ½t vÃ­c, ale pouze jedno mÅ¯Å¾e bÃ½t
  **bÄ›Å¾Ã­cÃ­**, ostatnÃ­ ÄekajÃ­ na pÅ™edÃ¡nÃ­ Å™Ã­zenÃ­.
- **Blocked** - zablokovanÃ© vlÃ¡kno, kterÃ© ÄekÃ¡ na zÃ­skÃ¡nÃ­ zÃ¡mku od jinÃ©ho vlÃ¡kna, kterÃ© ho prÃ¡vÄ› vlastnÃ­
- **Waiting** - vlÃ¡kno ÄekajÃ­ buÄ na dobÄ›hnutÃ­ jinÃ©ho vlÃ¡kna (metoda `join()`) nebo bylo do ÄekÃ¡nÃ­ uvedeno
  metodou `wait()` a bude pÅ™evedeno zpÄ›t do stavu Runnable po zavolÃ¡nÃ­ metody `notify()` nebo `notifyAll()`
- **Timed Waiting** - uspanÃ© vlÃ¡kno ÄekajÃ­cÃ­ po urÄitou Äasovou dobu, nejÄastÄ›ji uspÃ¡no metodou `sleep()`
- **Terminated** - mrtvÃ© vlÃ¡kno, jeho metoda `run()` skonÄila

### Priority
KaÅ¾dÃ© vlÃ¡kno mÃ¡ prioritu, podle kterÃ© je mu pÅ™edÃ¡vÃ¡no Å™Ã­zenÃ­ (tj. poskytovÃ¡ny systÃ©movÃ© prostÅ™edky).
To znamenÃ¡, Å¾e pokud jsou bÄ›huschopnÃ¡ dvÄ› vlÃ¡kna, bude vÅ¾dy pÅ™edÃ¡no Å™Ã­zenÃ­ vlÃ¡knu s vyÅ¡Å¡Ã­ prioritou.
ZmÄ›nit prioritu vlÃ¡kna lze pÅ™ed i po jeho spuÅ¡tÄ›nÃ­ metodou `start()`. 

NejniÅ¾Å¡Ã­ priorita mÃ¡ hodnotu MIN_PRIORITY, nejvyÅ¡Å¡Ã­ MAX_PRIORITY, normÃ¡lnÃ­ je NORM_PRIORITY, coÅ¾ je priorita standardnÄ› pÅ™idÄ›lenÃ¡ novÄ› vznikajÃ­cÃ­m vlÃ¡knÅ¯m.
ze pouÅ¾Ã­t i ÄÃ­sla v rozsahu od 1 do 10, pÅ™iÄemÅ¾ platÃ­: 
- MIN_PRIORITY = 1,
- NORM_PRIORITY = 5,
- MAX_PRIORITY = 10.

### DÃ©moni
Pokud program pouÅ¾Ã­vÃ¡ bÄ›Å¾nÃ¡ vlÃ¡kna, nemÅ¯Å¾e skonÄit dÅ™Ã­ve, neÅ¾ jsou ukonÄena vÅ¡echna vlÃ¡kna (tzn. jejich metody `run()`).
NÄ›kdy vÅ¡ak vlÃ¡kno slouÅ¾Ã­ pouze k obsluze urÄitÃ½ch poÅ¾adavkÅ¯ a jeho existence po skonÄenÃ­ ostatnÃ­ch vlÃ¡ken je nepotÅ™ebnÃ¡.
Pokud vlÃ¡kno oznaÄÃ­me jako dÃ©mona, program skonÄÃ­ bez ohledu na to, zda jiÅ¾ vlÃ¡kno dobÄ›hlo Äi nikoliv. 

### Synchronizace vlÃ¡ken
VlÃ¡kna pÅ™inÃ¡Å¡ejÃ­ spoustu vÃ½hod a dovolujÃ­ dobrou paralelizaci programu.
Jsou zde ovÅ¡em takÃ© nevÃ½hody, jako je **soubÄ›h**.
Ten nastÃ¡vÃ¡, kdyÅ¾ nÄ›kolik vlÃ¡ken sdÃ­lÃ­ data.
ProblÃ©m konzistence sdÃ­lenÃ½ch dat vlÃ¡ken:
- VlÃ¡kna jednoho procesu sdÃ­lÃ­ pamÄ›Å¥ a soubory, a tudÃ­Å¾ mohou mezi sebou komunikovat, aniÅ¾ by k tomu potÅ™ebovaly sluÅ¾by jÃ¡dra. 
- VlÃ¡kna jednÃ© aplikace se proto musÃ­ mezi sebou synchronizovat, aby se zachovala konzistentnost zpracovÃ¡vanÃ½ch dat. 

Nekonzistenci dat lze pÅ™edejÃ­t pouÅ¾itÃ­m tzv. **monitoru**.
Monitor je synchronizaÄnÃ­ prvek, kterÃ½ se pouÅ¾Ã­vÃ¡ pro Å™Ã­zenÃ­ pÅ™Ã­stupu ke sdÃ­lenÃ½m prostÅ™edkÅ¯m.
Monitor se sklÃ¡dÃ¡ z dat, ke kterÃ½m je potÅ™eba Å™Ã­dit pÅ™Ã­stup, a mnoÅ¾iny funkcÃ­, kterÃ© nad tÄ›mito daty operujÃ­.
V JavÄ› mÃ¡ kaÅ¾dÃ½ objekt automaticky pÅ™iÅ™azen svÅ¯j monitor.
Funkce, kterÃ© patÅ™Ã­ do monitoru, jsou oznaÄeny pomocÃ­ klÃ­ÄovÃ©ho slova `synchronized`.
Synchronizace mÅ¯Å¾e zpÅ¯sobit uvÃ¡znutÃ­ (deadlock).

ExistujÃ­ i jinÃ© metody synchronizace vlÃ¡ken, neÅ¾ je monitor.
DalÅ¡Ã­mi populÃ¡rnÃ­mi moÅ¾nostmi jsou:
- zÃ¡mek (Lock)
- Mutex
- semafor
