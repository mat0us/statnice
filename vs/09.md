<div align="center" style="margin-top: 16px;">
    <strong>OtÃ¡zka 9</strong>
</div>

<nav style="
    position: sticky;
    top: 0;
    z-index: 100;
    background: rgba(0,0,0,0.8);
    padding: 8px 0 4px 0;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    text-align: center;
">
    <a href="08.md" style="color:white; text-decoration:none; margin: 0 16px;">â¬…ï¸ PÅ™edchozÃ­</a>
    <a href="../README.md" style="color:white; text-decoration:none; margin: 0 16px;">ğŸ  DomÅ¯</a>
    <a href="10.md" style="color:white; text-decoration:none; margin: 0 16px;">NÃ¡sledujÃ­cÃ­ â¡ï¸</a>
</nav>

# 9. VÃ½voj vÃ­cevlÃ¡knovÃ½ch aplikacÃ­ v C++/JavÄ›

> [!TIP]OtÃ¡zka
> MoÅ¾nÃ© dÅ¯vody pouÅ¾itÃ­ vÃ­ce vlÃ¡ken, Å¾ivotnÃ­ cyklus vlÃ¡kna, ÃºskalÃ­ pÅ™Ã­stupu vlÃ¡ken ke spoleÄnÃ½m datovÃ½m strukturÃ¡m. Diskuse o moÅ¾nÃ©m vyuÅ¾itÃ­ vÃ­ce vlÃ¡ken v aplikaci vytvoÅ™enÃ© v rÃ¡mci zÃ¡vÄ›reÄnÃ© prÃ¡ce

---

## VlÃ¡kna obecnÄ›

VlÃ¡kna pÅ™edstavujÃ­ zpÅ¯sob, jak v rÃ¡mci jednoho procesu provÃ¡dÄ›t vÃ­ce ÄinnostÃ­ paralelnÄ› (na poÄÃ­taÄi s vÃ­ce procesory
nebo s vÃ­cejÃ¡drovÃ½m procesorem) nebo pseudoparalelnÄ› (na poÄÃ­taÄi s jednÃ­m jednojÃ¡drovÃ½m procesorem).
VlÃ¡kno je posloupnostÃ­ po sobÄ› jdoucÃ­ch operacÃ­ (pÅ™Ã­kazÅ¯, instrukcÃ­, ...).
KaÅ¾dÃ½ proces je tvoÅ™en nejmÃ©nÄ› jednÃ­m vlÃ¡knem.
V rÃ¡mci kaÅ¾dÃ©ho z vlÃ¡ken je vykonÃ¡vÃ¡n kÃ³d nezÃ¡visle na ostatnÃ­ch vlÃ¡knech.
VÃ­cevlÃ¡knovÃ© programovÃ¡nÃ­ mÃ¡ smysl napÅ™Ã­klad u tÄ›chto typÅ¯ Ãºloh:

- **ÄŒasovÄ› nÃ¡roÄnÃ© vÃ½poÄty**: Jedno vlÃ¡kno provÃ¡dÃ­ vÃ½poÄet, zatÃ­mco druhÃ© vlÃ¡kno prÅ¯bÄ›Å¾nÄ› informuje uÅ¾ivatele o stavu vÃ½poÄtu.
- **ÄŒekÃ¡nÃ­ na vstup**: VyuÅ¾itÃ­ Äasu strÃ¡venÃ©ho ÄekÃ¡nÃ­m na vstup od uÅ¾ivatele, napÅ™Ã­klad pÅ™i interaktivnÃ­ch aplikacÃ­ch.
- **Simulace vÃ­ce entit**: Simulace aktivity vÃ­ce entit, napÅ™Ã­klad pohyb molekul plynu nebo jinÃ½ch fyzikÃ¡lnÃ­ch procesÅ¯.
- **Klientâ€“server aplikace**: VytvoÅ™enÃ­ samostatnÃ©ho vlÃ¡kna pro obsluhu kaÅ¾dÃ©ho pÅ™ipojenÃ©ho klienta, coÅ¾ zvyÅ¡uje efektivitu a Å¡kÃ¡lovatelnost.
- **Producentâ€“konzument Ãºlohy**: Producent pÅ™ipravuje data, kterÃ¡ konzument nÃ¡slednÄ› spotÅ™ebovÃ¡vÃ¡, coÅ¾ umoÅ¾Åˆuje paralelnÃ­ zpracovÃ¡nÃ­.

VlÃ¡kna majÃ­ oproti procesÅ¯m Å™adu vÃ½hod:

- VlÃ¡kno se vytvoÅ™Ã­ rychleji neÅ¾ proces.
- VlÃ¡kno se ukonÄÃ­ rychleji neÅ¾ proces.
- Mezi vlÃ¡kny se rychleji pÅ™epÃ­nÃ¡ neÅ¾ mezi procesy.
- Lze dosÃ¡hnout lepÅ¡Ã­ strukturalizace programu.

## VlÃ¡kna v JavÄ›

Java pÅ™Ã­mo podporuje vÃ­cevlÃ¡knovÃ½ bÄ›h programu.
VlÃ¡kno lze vytvoÅ™it dÄ›dÄ›nÃ­m z tÅ™Ã­dy `Thread` nebo implementacÃ­ rozhranÃ­ `Runnable`.

VlÃ¡kno lze vytvoÅ™it jako instanci tÅ™Ã­dy java.lang.Thread nebo jejÃ­ podtÅ™Ã­dy.
V nejjednoduÅ¡Å¡Ã­m pÅ™Ã­padÄ› staÄÃ­ odvodit potomka od tÅ™Ã­dy Thread a pÅ™ekrÃ½t klÃ­Äovou metodu `run()`, kterÃ¡ popisuje, co
vlÃ¡kno pÅ™i svÃ©m bÄ›hu vlastnÄ› dÄ›lÃ¡.
Metoda `run()` vlÃ¡kna se nespouÅ¡tÃ­ pÅ™Ã­mo, ale pomocÃ­ volÃ¡nÃ­ metody `start()` zdÄ›dÄ›nÃ© ze tÅ™Ã­dy `Thread`.

Pro prÃ¡ci s vlÃ¡kny se pouÅ¾Ã­vÃ¡ nÄ›kolik dÅ¯leÅ¾itÃ½ch metod:
- `getState()` - vracÃ­ aktuÃ¡lnÃ­ stav vlÃ¡kna
- `yield()` - mÅ¯Å¾e vlÃ¡kno nabÃ­dnout pÅ™edÃ¡nÃ­ Å™Ã­zenÃ­ jinÃ©mu vlÃ¡knu
- `sleep()` - uspÃ­ vlÃ¡kno na zadanÃ½ poÄet milisekund
- `wait()` - pozastavÃ­ vlÃ¡kno do doby, neÅ¾ bude probuzeno metodou `notify()`, `notifyAll()` nebo bude neÅ¾ bude pÅ™eruÅ¡eno metodou `interrupt()`
- `isAlive()` - zjistÃ­, jestli vlÃ¡kno Å¾ije, tzn. nachÃ¡zÃ­ se mezi spuÅ¡tÄ›nÃ­m metodou start() a ukonÄenÃ­m metody run()
- `join()` - pozastavÃ­ bÄ›h metody vlÃ¡kna, dokud neskonÄÃ­ jinÃ© vlÃ¡kno

VlÃ¡kna je moÅ¾nÃ¡ pÅ™eruÅ¡it.
PÅ™eruÅ¡enÃ­m oznamujeme vlÃ¡knu, Å¾e by mÄ›lo pÅ™estat vykonÃ¡vat svoji bÄ›Å¾nou Äinnost a udÄ›lat nÄ›co jinÃ©ho.
Je na programÃ¡torovi, aby rozhodl, jak bude vlÃ¡kno reagovat na pÅ™eruÅ¡enÃ­.
Je ovÅ¡em obvyklÃ© ukonÄit Äinnost vlÃ¡kna (tedy metody `run()`).
Metoda vyvolÃ¡ vÃ½jimku `InterruptedException`, kterou je tÅ™eba oÅ¡etÅ™it v bloku `catch`.

### Å½ivotnÃ­ cyklus vlÃ¡ken

![Å½ivotnÃ­ cyklus vlÃ¡ken](img/threading.png)

KaÅ¾dÃ© vlÃ¡kno se v kaÅ¾dÃ©m okamÅ¾iku nachÃ¡zÃ­ v jednom z Å¡esti moÅ¾nÃ½ch stavÅ¯.
PÅ™echody mezi tÄ›mito stavy zajiÅ¡Å¥ujÃ­ nejÄastÄ›ji metody tÅ™Ã­dy `Thread`.
Stavy vlÃ¡ken jsou:

JistÄ›! Zde je struÄnÃ½ pÅ™ehled stavÅ¯ vlÃ¡ken v JavÄ›, ke kaÅ¾dÃ©mu stavu je pÅ™idÃ¡n jednoduchÃ½ pÅ™Ã­klad v kÃ³du:

- **New**  
  NovÃ© vlÃ¡kno, kterÃ© bylo vytvoÅ™eno pomocÃ­ konstruktoru, ale jeÅ¡tÄ› nebylo spuÅ¡tÄ›no metodou `start()`.  
  **PÅ™Ã­klad:**
  ```java
  Thread t = new Thread(() -> System.out.println("Ahoj"));
  // t je nynÃ­ ve stavu New
  ```

- **Runnable**  
  BÄ›huschopnÃ© vlÃ¡kno, u kterÃ©ho jiÅ¾ probÄ›hla metoda `start()`. TakovÃ½ch vlÃ¡ken mÅ¯Å¾e bÃ½t vÃ­ce, ale v danÃ©m okamÅ¾iku mÅ¯Å¾e bÃ½t skuteÄnÄ› **bÄ›Å¾Ã­cÃ­** jen jedno (na jednom procesorovÃ©m jÃ¡dru), ostatnÃ­ ÄekajÃ­ na pÅ™idÄ›lenÃ­ procesorovÃ©ho Äasu.  
  **PÅ™Ã­klad:**
  ```java
  t.start();
  // t je nynÃ­ ve stavu Runnable
  ```

- **Blocked**  
  ZablokovanÃ© vlÃ¡kno, kterÃ© ÄekÃ¡ na zÃ­skÃ¡nÃ­ zÃ¡mku (locku) od jinÃ©ho vlÃ¡kna, kterÃ© ho prÃ¡vÄ› vlastnÃ­.  
  **PÅ™Ã­klad:**
  ```java
  Object lock = new Object();

  Thread t1 = new Thread(() -> {
      synchronized(lock) {
          try { Thread.sleep(1000); } catch (InterruptedException e) {}
      }
  });

  Thread t2 = new Thread(() -> {
      synchronized(lock) {
          System.out.println("t2 zÃ­skal zÃ¡mek");
      }
  });

  t1.start();
  Thread.sleep(100); // zajistÃ­, Å¾e t1 zÃ­skÃ¡ zÃ¡mek jako prvnÃ­
  t2.start(); // t2 je nynÃ­ ve stavu Blocked, dokud t1 nepustÃ­ zÃ¡mek
  ```

- **Waiting**  
  VlÃ¡kno ÄekajÃ­cÃ­ buÄ na dobÄ›hnutÃ­ jinÃ©ho vlÃ¡kna (metoda `join()`), nebo bylo do ÄekÃ¡nÃ­ uvedeno metodou `wait()`. Ze stavu Waiting se dostane zpÄ›t do Runnable po zavolÃ¡nÃ­ metody `notify()` nebo `notifyAll()`, pÅ™Ã­padnÄ› po dokonÄenÃ­ sledovanÃ©ho vlÃ¡kna.  
  **PÅ™Ã­klad:**
  ```java
  Thread t3 = new Thread(() -> {
      synchronized(lock) {
          try { lock.wait(); } catch (InterruptedException e) {}
      }
  });

  t3.start();
  // t3 je nynÃ­ ve stavu Waiting, dokud nÄ›kdo nezavolÃ¡ lock.notify()
  ```

- **Timed Waiting**  
  UspanÃ© vlÃ¡kno, kterÃ© ÄekÃ¡ po urÄitou Äasovou dobu, napÅ™Ã­klad metodou `sleep()`, `wait(timeout)`, nebo `join(timeout)`.  
  **PÅ™Ã­klad:**
  ```java
  Thread t4 = new Thread(() -> {
      try { Thread.sleep(5000); } catch (InterruptedException e) {}
  });

  t4.start();
  // t4 je nynÃ­ ve stavu Timed Waiting po dobu 5 sekund
  ```

- **Terminated**  
  MrtvÃ© vlÃ¡kno, jehoÅ¾ metoda `run()` skonÄila â€“ buÄ normÃ¡lnÄ›, nebo v dÅ¯sledku neodchycenÃ© vÃ½jimky.  
  **PÅ™Ã­klad:**
  ```java
  Thread t5 = new Thread(() -> System.out.println("Hotovo"));
  t5.start();
  t5.join(); // Po dokonÄenÃ­ je t5 ve stavu Terminated
  ```

Tento pÅ™ehled obsahuje struÄnÃ© vysvÄ›tlenÃ­ kaÅ¾dÃ©ho stavu i konkrÃ©tnÃ­ ukÃ¡zku v kÃ³du.


### Priority
KaÅ¾dÃ© vlÃ¡kno mÃ¡ prioritu, podle kterÃ© je mu pÅ™edÃ¡vÃ¡no Å™Ã­zenÃ­ (tj. poskytovÃ¡ny systÃ©movÃ© prostÅ™edky).
To znamenÃ¡, Å¾e pokud jsou bÄ›huschopnÃ¡ dvÄ› vlÃ¡kna, bude vÅ¾dy pÅ™edÃ¡no Å™Ã­zenÃ­ vlÃ¡knu s vyÅ¡Å¡Ã­ prioritou.
ZmÄ›nit prioritu vlÃ¡kna lze pÅ™ed i po jeho spuÅ¡tÄ›nÃ­ metodou `start()`. 

NejniÅ¾Å¡Ã­ priorita mÃ¡ hodnotu `MIN_PRIORITY`, nejvyÅ¡Å¡Ã­ `MAX_PRIORITY`, normÃ¡lnÃ­ je `NORM_PRIORITY`, coÅ¾ je priorita standardnÄ› pÅ™idÄ›lenÃ¡ novÄ› vznikajÃ­cÃ­m vlÃ¡knÅ¯m.
ze pouÅ¾Ã­t i ÄÃ­sla v rozsahu od 1 do 10, pÅ™iÄemÅ¾ platÃ­: 
- `MIN_PRIORITY` = 1,
- `NORM_PRIORITY` = 5,
- `MAX_PRIORITY` = 10.

### DÃ©moni
Pokud program pouÅ¾Ã­vÃ¡ bÄ›Å¾nÃ¡ vlÃ¡kna, nemÅ¯Å¾e skonÄit dÅ™Ã­ve, neÅ¾ jsou ukonÄena vÅ¡echna vlÃ¡kna (tzn. jejich metody `run()`). NÄ›kdy vÅ¡ak vlÃ¡kno slouÅ¾Ã­ pouze k obsluze urÄitÃ½ch poÅ¾adavkÅ¯ a jeho existence po skonÄenÃ­ ostatnÃ­ch vlÃ¡ken je nepotÅ™ebnÃ¡. Pokud vlÃ¡kno oznaÄÃ­me jako dÃ©mona, program skonÄÃ­ bez ohledu na to, zda jiÅ¾ vlÃ¡kno dobÄ›hlo Äi nikoliv. 

### Synchronizace vlÃ¡ken
VlÃ¡kna pÅ™inÃ¡Å¡ejÃ­ spoustu vÃ½hod a dovolujÃ­ dobrou paralelizaci programu. Jsou zde ovÅ¡em takÃ© nevÃ½hody, jako je **soubÄ›h**. Ten nastÃ¡vÃ¡, kdyÅ¾ nÄ›kolik vlÃ¡ken sdÃ­lÃ­ data. 

ProblÃ©m konzistence sdÃ­lenÃ½ch dat vlÃ¡ken:

- VlÃ¡kna jednoho procesu sdÃ­lÃ­ pamÄ›Å¥ a soubory, a tudÃ­Å¾ mohou mezi sebou komunikovat, aniÅ¾ by k tomu potÅ™ebovaly sluÅ¾by jÃ¡dra. 
- VlÃ¡kna jednÃ© aplikace se proto musÃ­ mezi sebou synchronizovat, aby se zachovala konzistentnost zpracovÃ¡vanÃ½ch dat. 

Nekonzistenci dat lze pÅ™edejÃ­t pouÅ¾itÃ­m tzv. **monitoru**. Monitor je synchronizaÄnÃ­ prvek, kterÃ½ se pouÅ¾Ã­vÃ¡ pro Å™Ã­zenÃ­ pÅ™Ã­stupu ke sdÃ­lenÃ½m prostÅ™edkÅ¯m. Monitor se sklÃ¡dÃ¡ z dat, ke kterÃ½m je potÅ™eba Å™Ã­dit pÅ™Ã­stup, a mnoÅ¾iny funkcÃ­, kterÃ© nad tÄ›mito daty operujÃ­. V JavÄ› mÃ¡ kaÅ¾dÃ½ objekt automaticky pÅ™iÅ™azen svÅ¯j monitor. Funkce, kterÃ© patÅ™Ã­ do monitoru, jsou oznaÄeny pomocÃ­ klÃ­ÄovÃ©ho slova `synchronized`. Synchronizace mÅ¯Å¾e zpÅ¯sobit uvÃ¡znutÃ­ (deadlock).

ExistujÃ­ i jinÃ© metody synchronizace vlÃ¡ken, neÅ¾ je monitor.

Zde je struÄnÃ© vysvÄ›tlenÃ­ a srovnÃ¡nÃ­ tÅ™Ã­ zÃ¡kladnÃ­ch synchronizaÄnÃ­ch mechanismÅ¯: zÃ¡mek (Lock), mutex a semafor, vÄetnÄ› jejich pouÅ¾itÃ­ v JavÄ›.

---

## ZÃ¡mek (Lock)
- **Popis:**  
  ZÃ¡mek je synchronizaÄnÃ­ mechanismus, kterÃ½ umoÅ¾Åˆuje pouze jednomu vlÃ¡knu vstoupit do kritickÃ© sekce kÃ³du, zatÃ­mco ostatnÃ­ musÃ­ Äekat. V JavÄ› lze pouÅ¾Ã­t buÄ klÃ­ÄovÃ© slovo `synchronized` (vnitÅ™nÃ­ zÃ¡mek objektu), nebo explicitnÃ­ zÃ¡mky z balÃ­ku `java.util.concurrent.locks`, napÅ™Ã­klad `ReentrantLock`.
- **VÃ½hody explicitnÃ­ch zÃ¡mkÅ¯ (`Lock`):**  
  - MoÅ¾nost pokusit se o zamÄenÃ­ (`tryLock()`)
  - NastavenÃ­ timeoutu
  - PÅ™eruÅ¡itelnÃ© operace
  - Podpora podmÃ­nÄ›nÃ©ho ÄekÃ¡nÃ­ (`Condition`)
  - LepÅ¡Ã­ kontrola nad zamykÃ¡nÃ­m a odemykÃ¡nÃ­m
- **PÅ™Ã­klad v JavÄ›:**
  ```java
  import java.util.concurrent.locks.Lock;
  import java.util.concurrent.locks.ReentrantLock;

  public class Counter {
      private int value = 0;
      private final Lock lock = new ReentrantLock();

      public int next() {
          lock.lock();
          try {
              return value++;
          } finally {
              lock.unlock();
          }
      }
  }
  ```
  ZÃ¡mek musÃ­ bÃ½t vÅ¾dy odemÄen ve `finally` bloku![1][6].

---

## Mutex
- **Popis:**  
  Mutex (zkratka pro "mutual exclusion") je speciÃ¡lnÃ­ typ zÃ¡mku, kterÃ½ zajiÅ¡Å¥uje, Å¾e pouze jedno vlÃ¡kno mÅ¯Å¾e v danÃ©m okamÅ¾iku pÅ™istupovat ke sdÃ­lenÃ©mu zdroji. V podstatÄ› je to zÃ¡mek s jednoduchou politikou â€“ buÄ je zamÄenÃ½, nebo odemÄenÃ½.
- **RozdÃ­l oproti bÄ›Å¾nÃ©mu zÃ¡mku:**  
  V JavÄ› nenÃ­ samostatnÃ¡ tÅ™Ã­da `Mutex`, ale chovÃ¡nÃ­ mutexu je implementovÃ¡no prÃ¡vÄ› pomocÃ­ vnitÅ™nÃ­ch zÃ¡mkÅ¯ (`synchronized`) nebo tÅ™Ã­d jako `ReentrantLock`. V jinÃ½ch jazycÃ­ch (napÅ™. C/C++) je mutex Äasto samostatnÃ½ synchronizaÄnÃ­ objekt.
- **PouÅ¾itÃ­ v JavÄ›:**  
  KaÅ¾dÃ½ synchronizovanÃ½ blok (`synchronized`) nebo metoda v JavÄ› vyuÅ¾Ã­vÃ¡ vnitÅ™nÃ­ mutex objektu.  
  ```java
  public synchronized void increment() {
      // pouze jedno vlÃ¡kno najednou
      value++;
  }
  ```
  nebo
  ```java
  synchronized(lockObject) {
      // kritickÃ¡ sekce
  }
  ```


---

## Semafor
- **Popis:**  
  Semafor je synchronizaÄnÃ­ mechanismus, kterÃ½ umoÅ¾Åˆuje omezenÃ©mu poÄtu vlÃ¡ken souÄasnÄ› pÅ™Ã­stup ke sdÃ­lenÃ©mu zdroji. Semafor mÃ¡ ÄÃ­taÄ, kterÃ½ urÄuje, kolik vlÃ¡ken mÅ¯Å¾e bÃ½t v kritickÃ© sekci najednou.
- **PouÅ¾itÃ­:**  
  - OmezovÃ¡nÃ­ paralelnÃ­ho pÅ™Ã­stupu (napÅ™Ã­klad maximÃ¡lnÄ› 5 vlÃ¡ken najednou)
  - Implementace bariÃ©r, front atd.
- **PÅ™Ã­klad v JavÄ›:**
  ```java
  import java.util.concurrent.Semaphore;

  public class Example {
      private final Semaphore semaphore = new Semaphore(3); // povolÃ­ max 3 vlÃ¡kna

      public void accessResource() throws InterruptedException {
          semaphore.acquire(); // zÃ­skÃ¡nÃ­ povolenÃ­
          try {
              // kritickÃ¡ sekce
          } finally {
              semaphore.release(); // uvolnÄ›nÃ­ povolenÃ­
          }
      }
  }
  ```


---

## ShrnutÃ­ rozdÃ­lÅ¯

| Mechanismus | PoÄet vlÃ¡ken v kritickÃ© sekci | TypickÃ© pouÅ¾itÃ­          |
|-------------|------------------------------|--------------------------|
| ZÃ¡mek/Mutex | 1                            | Ochrana sdÃ­lenÃ½ch dat    |
| Semafor     | N (urÄenÃ© ÄÃ­taÄem)           | OmezovÃ¡nÃ­ paralelismu    |

---

**ZÃ¡mek** a **mutex** v JavÄ› Äasto znamenajÃ­ totÃ©Å¾ (zajiÅ¡Å¥ujÃ­ vÃ½luÄnÃ½ pÅ™Ã­stup), zatÃ­mco **semafor** umoÅ¾Åˆuje Å™Ã­dit, kolik vlÃ¡ken mÅ¯Å¾e souÄasnÄ› vstoupit do chrÃ¡nÄ›nÃ© sekce. VÅ¡echny tyto prostÅ™edky jsou klÃ­ÄovÃ© pro bezpeÄnou synchronizaci v paralelnÃ­ch programech.
