<div align="center" style="margin-top: 16px;">
    <strong>OtÃ¡zka 5</strong>
</div>

<nav style="
    position: sticky;
    top: 0;
    z-index: 100;
    background: rgba(0,0,0,0.8);
    padding: 8px 0 4px 0;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    text-align: center;
">
    <a href="04.md" style="color:white; text-decoration:none; margin: 0 16px;">â¬…ï¸ PÅ™edchozÃ­</a>
    <a href="../README.md" style="color:white; text-decoration:none; margin: 0 16px;">ğŸ  DomÅ¯</a>
    <a href="06.md" style="color:white; text-decoration:none; margin: 0 16px;">NÃ¡sledujÃ­cÃ­ â¡ï¸</a>
</nav>

# GenerickÃ© programovÃ¡nÃ­ v C++/JavÄ›

<span style="background:#fffde7; color:#f9a825; padding:2px 8px; border-radius:4px; font-weight:bold;">ğŸŸ¡ DÅ¯leÅ¾itÃ¡ otÃ¡zka 1</span>  

<div align="center">

[<kbd>ğŸŒ Vizualizace (EN)</kbd>](https://visualgo.net/en)  

</div>

> [!TIP]OtÃ¡zka
> VyuÅ¾itÃ­ Å¡ablon abstraktnÃ­ch datovÃ½ch struktur pro uloÅ¾enÃ­ dat (rozdÃ­ly mezi strukturami, vÃ½bÄ›r vhodnÃ© abstraktnÃ­ datovÃ© struktury, prÃ¡ce s iterÃ¡tory); aplikace generickÃ½ch algoritmÅ¯ a jejich rozÅ¡iÅ™itelnost prostÅ™ednictvÃ­m lambda vÃ½razÅ¯

---

## DatovÃ© struktury

DatovÃ¡ struktura je zpÅ¯sob organizace dat v pamÄ›ti poÄÃ­taÄe, kterÃ½ zajiÅ¡Å¥uje, aby mohla data bÃ½t pouÅ¾Ã­vÃ¡na efektivnÄ›.
DatovÃ¡ struktura umoÅ¾Åˆuje uchovÃ¡vat a zpracovÃ¡vat mnoÅ¾inu dat buÄ stejnÃ©ho typu nebo rÅ¯znorodÃ½ch, ale logicky
souvisejÃ­cÃ­ch.

### Pole                [<kbd>Link</kbd>](https://www.geeksforgeeks.org/array-data-structure-guide/)

Pole je skupina dat stejnÃ©ho typu.
PÅ™i inicializaci dostane svou dÃ©lku a ta je dÃ¡le nemÄ›nnÃ¡.
NemÄ›nnost dÃ©lky je nutnÃ¡, protoÅ¾e pÅ™i svÃ© inicializace pole alokuje v pamÄ›ti buÅˆky, kterÃ© jdou hned za sebou (podle
datovÃ©ho typu se zmÄ›Å™Ã­ velikost buÅˆky a podle dÃ©lky pole se vypoÄÃ­tÃ¡ jak velkÃ½ Ãºsek pamÄ›ti je k uchovÃ¡nÃ­ pole nutnÃ½).
Proto nelze pole po vytvoÅ™enÃ­ zvÄ›tÅ¡ovat nebo zmenÅ¡ovat.
NÄ›kterÃ© programovacÃ­ jazyky umoÅ¾ÅˆujÃ­ zvÄ›tÅ¡enÃ­ pole, takovÃ½ Ãºkon je ovÅ¡em velice ÄasovÄ› nÃ¡roÄnÃ½ (realokace pamÄ›ti).

K jednotlivÃ½m prvkÅ¯m pole mÅ¯Å¾eme pÅ™istupovat pÅ™Ã­mo pomocÃ­ indexÅ¯.
Pole je vhodnÃ¡ datovÃ¡ struktura, pokud pÅ™edem znÃ¡me poÄet prvkÅ¯, kterÃ½ do nÄ›j chceme umÃ­stit a nebudeme poÄet tÄ›chto
prvkÅ¯ moc Äasto mÄ›nit.

<img src="img/pole.png" alt="pole v pamÄ›ti">

### LineÃ¡rnÃ­ seznam     [<kbd>Link</kbd>](https://www.geeksforgeeks.org/linked-list-data-structure/)

TÃ©Å¾ znÃ¡m jako spojovÃ½ seznam, je datovÃ¡ struktura urÄenÃ¡ k uklÃ¡dÃ¡nÃ­ dat pÅ™edem neznÃ¡mÃ© dÃ©lky.
Seznamy jsou tvoÅ™eny vzÃ¡jemnÄ› propojenÃ½mi uzly.
KaÅ¾dÃ½ uzel obsahuje jednu hodnotu a jeden nebo vÃ­ce ukazatelÅ¯ na dalÅ¡Ã­ uzly.
V pamÄ›ti nenÃ­ seznam tedy uloÅ¾enÃ½ v buÅˆkÃ¡ch jdoucÃ­ch pÅ™Ã­mo za sebou, ale jeho prvky jsou rozmÃ­stÄ›ny rÅ¯znÄ› po pamÄ›ti.
Pokud hledÃ¡me specifickÃ½ prvek seznamu, musÃ­me ho projÃ­t celÃ½ dokud nenarazÃ­me na prvek, kterÃ½ hledÃ¡me.
Na zÃ¡kladÄ› pouÅ¾itÃ½ch ukazatelÅ¯ rozliÅ¡ujeme nÄ›kolik druhÅ¯ spojovÃ½ch seznamÅ¯:

- jednosmÄ›rnÄ› zÅ™etÄ›zenÃ½ spojovÃ½ seznam: kaÅ¾dÃ½ prvek obsahuje odkaz na nÃ¡sledujÃ­cÃ­
- obousmÄ›rnÄ› zÅ™etÄ›zenÃ½ spojovÃ½ seznam: kaÅ¾dÃ½ prvek obsahuje odkaz na nÃ¡sledujÃ­cÃ­ a pÅ™edchozÃ­
- kruhovÃ½ spojovÃ½ seznam: obousmÄ›rnÄ› zÅ™etÄ›zenÃ½ s tÃ­m, Å¾e prvnÃ­ odkazuje na poslednÃ­ a poslednÃ­ na prvnÃ­

<img src="img/list.png" alt="seznam v pamÄ›ti">

### Strom               [<kbd>Link</kbd>](https://www.geeksforgeeks.org/introduction-to-tree-data-structure/)

Strom je datovÃ¡ struktura, kterÃ¡ slouÅ¾Ã­ pro uchovÃ¡vÃ¡nÃ­ hierarchicky uspoÅ™Ã¡danÃ½ch dat.
Strom je souvislÃ½ graf neobsahujÃ­cÃ­ cyklus.
NejvyÅ¡Å¡Ã­ prvek stromu se nazÃ½vÃ¡ **koÅ™en** - je to jedinÃ½ prvek stromu, kterÃ½ nemÃ¡ pÅ™edka.
Prvek, kterÃ½ nemÃ¡ Å¾Ã¡dnÃ©ho potomka se nazÃ½vÃ¡ **list** a je to tedy poslednÃ­ prvek ve vÄ›tvi.
**VÄ›tev** je cesta mezi koÅ™enem a listem stromu.
KaÅ¾dÃ½ prvek, kterÃ½ nenÃ­ ani listem a ani koÅ™enem se nazÃ½vÃ¡ **vnitÅ™nÃ­ uzel**.

V pamÄ›ti je strom uloÅ¾en podobnÄ› jako lineÃ¡rnÃ­ seznam - pomocÃ­ ukazatelÅ¯.

Strom mÅ¯Å¾e obsahovat i podstrom, staÄÃ­ si oznaÄit jinÃ½ prvek jako koÅ™en.
Pokud kaÅ¾dÃ½ vnitÅ™nÃ­ prvek stromu mÃ¡ maximÃ¡lnÄ› dva dalÅ¡Ã­ syny, nazÃ½vÃ¡me ho **binÃ¡rnÃ­ strom**.
Prvky takovÃ©ho stromku majÃ­ svou levou a pravou vÄ›tev.

BinÃ¡rnÃ­ strom mÃ¡ svÅ¯j speciÃ¡lnÃ­ pÅ™Ã­pad: **BinÃ¡rnÃ­ vyhledÃ¡vacÃ­ strom**.
To je datovÃ¡ struktura velmi vhodnÃ¡ pro hledÃ¡nÃ­ prvku podle hodnoty, jak jiÅ¾ napovÃ­dÃ¡ jejÃ­ nÃ¡zev.
Abychom mohli binÃ¡rnÃ­ strom oznaÄit za BVS, musÃ­ mÃ­t tyto vlastnosti:
- LevÃ½ podstrom kaÅ¾dÃ©ho uzlu obsahuje pouze klÃ­Äe menÅ¡Ã­ neÅ¾ je klÃ­Ä tohoto uzlu
- PravÃ½ podstrom uzlu obsahuje pouze klÃ­Äe vÄ›tÅ¡Ã­ neÅ¾ je klÃ­Ä tohoto uzlu

![s10273305302025](https://a.okmd.dev/md/68396bf76b79f.png)



Strom mÅ¯Å¾eme prochÃ¡zet dvÄ›ma rÅ¯znÃ½mi algoritmy: 

[<kbd>Link</kbd>](https://www.geeksforgeeks.org/difference-between-bfs-and-dfs/)

- `BFS` (Breadth First Search) â€“ prohledÃ¡vÃ¡nÃ­ do Å¡Ã­Å™ky, prohledÃ¡vÃ¡ strom po celÃ½ch patrech)
- `DFS` (Depth First Search) â€“ prohledÃ¡vÃ¡nÃ­ do hloubky, prohledÃ¡vÃ¡ strom po jednotlivÃ½ch vÄ›tvÃ­ch. Implementace tohoto algoritmu mÃ¡ nÄ›kolik variant podle poÅ™adÃ­ operacÃ­:
    - **Inorder**: projde se levÃ½ podstrom, provede se akce a projde se pravÃ½ podstrom
    - **Preorder**: provede se akce, projde se levÃ½ podstrom, projde se pravÃ½ podstrom
    - **Postorder**: projde levÃ½ podstrom, projde pravÃ½ podstrom, provede akci

### Halda               [<kbd>Link</kbd>](https://www.geeksforgeeks.org/heap-data-structure/)

Halda je stromovÃ¡ datovÃ¡ struktura.
Od obyÄejnÃ©ho stromu se lÃ­Å¡Ã­ tÃ­m, Å¾e jsou jejÃ­ prvky seÅ™azeny.
PlatÃ­ zde pravidlo pravidlo haldy a to mÅ¯Å¾e bÃ½t rÅ¯znÃ© buÄ se jednÃ¡ o max-heap nebo min-heap.
V pÅ™Ã­padÄ› max-heap vÅ¾dy platÃ­, Å¾e kaÅ¾dÃ½ uzel vÄ›tÅ¡Ã­ nebo roven uzlÅ¯m, kteÅ™Ã­ se nachÃ¡zejÃ­ pod nÃ­m.
U min-heap je to obrÃ¡cenÄ› a tedy kaÅ¾dÃ½ uzel je menÅ¡Ã­ nebo roven uzlÅ¯m pod nÃ­m.

U max-heap tedy platÃ­, Å¾e v koÅ™enu je nejvyÅ¡Å¡Ã­ ÄÃ­slo.
U min-heap je v koÅ™enu ÄÃ­slo nejmenÅ¡Ã­.
![s10074705302025](https://a.okmd.dev/md/683967559192c.png)
![s10082505302025](https://a.okmd.dev/md/6839677ab8c9a.png)
![s10090305302025](https://a.okmd.dev/md/683967a1e47f0.png)
![s10103805302025](https://a.okmd.dev/md/683968018bf82.png)
Halda mÃ¡ nÄ›kolik vyuÅ¾itÃ­:
- Å™adÃ­cÃ­ algoritmus heapsort
- tvorba prioritnÃ­ch front
- implementace grafovÃ½ch algoritmÅ¯ (DijkstrÅ¯v nebo PrimovÅ¯v algoritmsu)

### Fronta              [<kbd>Link</kbd>](https://www.geeksforgeeks.org/queue-data-structure/)


Fronta (queue) je datovÃ¡ struktura podporujÃ­cÃ­ vklÃ¡dÃ¡nÃ­ a odebÃ­rÃ¡nÃ­ prvkÅ¯.
VyuÅ¾Ã­vÃ¡ princip **FIFO** (first in â€“ first out), tedy prvek, kterÃ½ byl vloÅ¾en jako prvnÃ­, bude i jako prvnÃ­ odebrÃ¡n.
RozliÅ¡ujeme tedy zaÄÃ¡tek a konec neboli hlavu a ocÃ¡sek fronty.
Na zaÄÃ¡tku je prvek pÅ™ipravenÃ½ k odebrÃ¡nÃ­, naopak operaci vloÅ¾enÃ­ vykonÃ¡vÃ¡me na konci fronty.
Nelze vklÃ¡dat ani ÄÃ­st z prostÅ™edka fronty.

![s10240005302025](https://a.okmd.dev/md/68396b220f2b7.png)

### ZÃ¡sobnÃ­k            [<kbd>Link</kbd>](https://www.geeksforgeeks.org/stack-data-structure/)

ZÃ¡sobnÃ­k (stack) je datovÃ¡ struktura podporujÃ­cÃ­ vklÃ¡dÃ¡nÃ­ a odebÃ­rÃ¡nÃ­ prvkÅ¯.
ZÃ¡sobnÃ­k mÃ¡ vrchol a dno.
SpecifickÃ½ je v tom, Å¾e uplatÅˆuje metodu **LIFO** (last in â€“ first out), tedy pÅ™i odebÃ­rÃ¡nÃ­ z nÄ›j mÅ¯Å¾eme vÅ¾dy vybrat
pouze ten prvek, kterÃ½ byl vloÅ¾en jako poslednÃ­ a nachÃ¡zÃ­ se na vrcholu.

NovÃ½ prvek dÃ¡me na vrchol a nechÃ¡me ho spadnout na zbylÃ© prvky v zÃ¡sobnÃ­ku.
Prvek vloÅ¾enÃ½ jako prvnÃ­ je tedy na dnÄ› a pÅ™eÄteme ho, aÅ¾ kdyÅ¾ vytÃ¡hneme vÅ¡echny prvky nad nÃ­m.
Na rozdÃ­l od lineÃ¡rnÃ­ho seznamu, nenÃ­ moÅ¾nÃ© vklÃ¡dat novÃ© prvky doprostÅ™ed zÃ¡sobnÃ­ku, ani odtud ÄÃ­st.

ZÃ¡sobnÃ­k pouÅ¾Ã­vÃ¡ ÄtyÅ™i zÃ¡kladnÃ­ operace:

- vloÅ¾enÃ­ prvku (push)
- odebrÃ¡nÃ­ prvku (pop)
- nahlÃ©dnutÃ­ na vrchol zÃ¡sobnÃ­ku (peek)
- test prÃ¡zdnoty (isEmpty)

![s10363805302025](https://a.okmd.dev/md/68396e18162d9.png)

### HaÅ¡ovacÃ­ tabulka    [<kbd>Link</kbd>](https://www.geeksforgeeks.org/hash-table-data-structure/)

HaÅ¡ovacÃ­ tabulka je datovÃ¡ struktura, kterÃ¡ se sklÃ¡dÃ¡ z unikÃ¡tnÃ­ch klÃ­ÄÅ¯ a hodnot.
KaÅ¾dÃ½ klÃ­Ä je zde mapovÃ¡n na hodnotu.
NÄ›kdy se tÃ©Å¾ nazÃ½vÃ¡ slovnÃ­k, hash map nebo jen mapa.

Na rozdÃ­l od pole zde ke konkrÃ©tnÃ­ hodnotÄ› nepÅ™istupujeme pomocÃ­ indexu, ale pomocÃ­ unikÃ¡tnÃ­ho klÃ­Äe.
KlÃ­Äe tabulky musÃ­ bÃ½t obvykle jednoduchÃ© typy (napÅ™Ã­klad celÃ¡ ÄÃ­sla nebo Å™etÄ›zce), zatÃ­mco hodnoty mohou bÃ½t jakÃ©hokoli typu.

KlÃ­Äe ve slovnÃ­ku musÃ­ bÃ½t jedineÄnÃ©; pokus o vytvoÅ™enÃ­ duplicitnÃ­ho klÃ­Äe obvykle konÄÃ­ pÅ™epsÃ¡nÃ­m hodnoty pod stÃ¡vajÃ­cÃ­m klÃ­Äem.

![s10380805302025](https://a.okmd.dev/md/68396e7221533.png)

### MnoÅ¾ina             [<kbd>Link</kbd>](https://www.geeksforgeeks.org/introduction-to-set-data-structure/)    

MnoÅ¾ina je datovÃ¡ struktura, kterÃ¡ je schopna uloÅ¾it urÄitÃ© hodnoty bez jakÃ©hokoliv poÅ™adÃ­ a bez opakujÃ­cÃ­ch se hodnot.
StejnÄ› jako v matematice se v mnoÅ¾inÄ› nemohou nachÃ¡zet duplikÃ¡ty.
Na rozdÃ­l od jinÃ½ch datovÃ½ch struktur se mnoÅ¾ina pouÅ¾Ã­vÃ¡ spÃ­Å¡e pro testovÃ¡nÃ­, zdali se konkrÃ©tnÃ­ hodnota nachÃ¡zÃ­ v mnoÅ¾inÄ› dat neÅ¾li pro zÃ­skÃ¡vÃ¡nÃ­ specifickÃ½ch prvkÅ¯ z mnoÅ¾iny.

NÄ›kterÃ© mnoÅ¾iny jsou navrÅ¾eny jako statickÃ© a s jejich vytvoÅ™enÃ­m se Å¾Ã¡dnÃ© prvky uÅ¾ dÃ¡le nepÅ™idÃ¡vajÃ­ ani neodebÃ­rajÃ­.

## IterÃ¡tory            [<kbd>Link</kbd>](https://www.geeksforgeeks.org/iterators-in-java/)
IterÃ¡tor je nÃ¡vrhovÃ½ vzor, kterÃ½ umoÅ¾Åˆuje sekvenÄnÄ› prochÃ¡zet prvky nÄ›jakÃ© sloÅ¾itÃ© datovÃ© struktury (kolekce) bez nutnosti znÃ¡t jejÃ­ vnitÅ™nÃ­ implementaci. PouÅ¾Ã­vÃ¡ se napÅ™Ã­klad pÅ™i prochÃ¡zenÃ­ kolekce, kdy zÃ¡roveÅˆ potÅ™ebujeme modifikovat jejÃ­ obsah (odebrat nebo pÅ™idat prvek), coÅ¾ by pomocÃ­ klasickÃ©ho `for` nebo `while` cyklu nebylo moÅ¾nÃ© provÃ©st bezpeÄnÄ›.

<img src="img/iterator.png" width="350">

## GenerickÃ© programovÃ¡nÃ­ [<kbd>Link</kbd>](https://www.geeksforgeeks.org/generics-in-java/)

GenerickÃ© programovÃ¡nÃ­ je tvorba algoritmÅ¯ univerzÃ¡lnÃ­m zpÅ¯sobem. V programovacÃ­ch jazycÃ­ch je generiÄnost implementovÃ¡na rÅ¯znÄ› a ne vÅ¡echny jazyky ji podporujÃ­. GeneriÄnosti kÃ³du dosÃ¡hneme tak, Å¾e mÃ­sto konkrÃ©tnÃ­ch definic datovÃ½ch typÅ¯ dosadÃ­me pouze parametry. VytvoÅ™Ã­me tÃ­m tzv. Å¡ablonu. Za Å¡ablonu potÃ© mÅ¯Å¾eme v kÃ³du pozdÄ›ji dosadit konkrÃ©tnÃ­ datovÃ½ typ.

PouÅ¾itÃ­m genericity lze dosÃ¡hnout nejlepÅ¡Ã­ho moÅ¾nÃ©ho zobecnÄ›nÃ­ kÃ³du. Genericitu pouÅ¾Ã­vajÃ­ i sloÅ¾itÄ›jÅ¡Ã­ datovÃ© struktury. Ze svÄ›ta Javy lze zmÃ­nit napÅ™Ã­klad vÄ›tÅ¡inu tÅ™Ã­d pro sprÃ¡vu kolekcÃ­ z balÃ­Äku `java.util` a tedy:

- List\<T> a jeho implementace ArrayList\<T> a LinkedList\<T>
- Set\<T> a jeho implementace HashSet\<T> a TreeSet\<T>
- Map\<T> a jeho implementace HashMap\<T> a TreeMap\<T>

Tyto pÅ™edpisy jsou tedy **generickÃ©** datovÃ© struktury a umÄ›jÃ­ pracovat s jakÃ½mkoliv typem dat.
Pokud tedy chceme pouÅ¾Ã­t datovou strukturu s konkrÃ©tnÃ­m typem, udÄ›lÃ¡me to takto:

```java
List<Car> cars = new ArrayList<Car>();
```

## Lambda vÃ½razy        [<kbd>Link</kbd>](https://www.geeksforgeeks.org/lambda-expressions-java-8/)

Lambda vÃ½razy jsou souÄÃ¡stÃ­ funkcionÃ¡lnÃ­ho programovacÃ­ho paradigmatu. JednÃ¡ se o tzv. anonymnÃ­ podprogramy tedy podprogramy bez jmÃ©na. NedefinujÃ­ se s hlaviÄkou pro opakovatelnÃ© pouÅ¾itÃ­, ale zapisujÃ­ se pouze jako tÄ›lo podprogramu. Jsou velmi uÅ¾iteÄnÃ© a pouÅ¾Ã­vajÃ­ se na zjednoduÅ¡enÃ­ Äitelnosti kÃ³du. ÄŒasto se stane, Å¾e mÃ¡me nÄ›jakou opravdu krÃ¡tkou a jednoduchou funkcionalitu a nechceme kvÅ¯li nÃ­ definovat celÃ½ blok i s hlaviÄkou. Proto mÃ­sto dlouhÃ© definice pouze zapÃ­Å¡eme krÃ¡tkÃ© tÄ›lo. Podprogram je zpracovÃ¡n a chovÃ¡ se tak jako kaÅ¾dÃ½ jinÃ½ vÃ½raz.

Jako lambda vÃ½raz mÅ¯Å¾eme implementovat jak podprogramy typu funkce tak podprogramy typu procedury. Lambda vÃ½raz tedy ani nemusÃ­ nic vracet. Ve struÄnosti je tedy lambda vÃ½raz pouze zkrÃ¡cenÃ½ zÃ¡pis podprogramu.

### Lambda v JavÄ›

Pro definici lambda vÃ½razu se pouÅ¾Ã­vÃ¡ operÃ¡tor Å¡ipky `->`, na levÃ© stranÄ› stojÃ­ parametry vÃ½razu a na pravÃ© stranÄ› vÃ½raz samotnÃ½. Syntaxe lambda vÃ½razu mÃ¡ svÃ¡ omezenÃ­. JednoduchÃ© vÃ½razy nemusejÃ­ obsahovat klÃ­ÄovÃ© slovo `return`. JednoduchÃ½ vÃ½raz za Å¡ipkou nesmÃ­ obsahovat sloÅ¾itÄ›jÅ¡Ã­ struktury jako jsou podmÃ­nky nebo cykly. Pokud je chceme pouÅ¾Ã­t, musÃ­me mu explicitnÄ› definovat tÄ›lo pomocÃ­ sloÅ¾enÃ½ch zÃ¡vorek `{ }`.

```java
// lambda s jednÃ­m parametrem
parameter -> expression

// lambda s vÃ­ce parametry
(parameter1, parameter2) -> expression

// sloÅ¾itejÅ¡Ã­ lambda vÃ½raz
(parameter1, parameter2) -> {code block }
```

**UkÃ¡zka pouÅ¾itÃ­ lambda vÃ½razu**

```java
ArrayList<Integer> numbers = new ArrayList<Integer>();
numbers.forEach( (n) -> {System.out.println(n); });
```

Lambdy lze v JavÄ› typicky vyuÅ¾Ã­t u `Stream` API, kterÃ© nabÃ­zÃ­ funkce:
- map
- filter
- forEach
- sorted
- a spoustu dalÅ¡Ã­ch, kde se dÃ¡ lambda pouÅ¾Ã­t
```java
// pouÅ¾itÃ­ lambdy u Stream API
Stream<String> values = Stream
        .generate(() -> randomString())
        .limit(10)
        .filter(s -> s.contains("f"))
        .map(s -> s.toLowerCase())
        .sorted((o1, o2) -> o1.compareTo(o2));
```