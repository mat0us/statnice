<div align="center" style="margin-top: 16px;">
    <strong>OtÃ¡zka 3</strong>
</div>

<nav style="
    position: sticky;
    top: 0;
    z-index: 100;
    background: rgba(0,0,0,0.8);
    padding: 8px 0 4px 0;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    text-align: center;
">
    <a href="02.md" style="color:white; text-decoration:none; margin: 0 16px;">â¬…ï¸ PÅ™edchozÃ­</a>
    <a href="../README.md" style="color:white; text-decoration:none; margin: 0 16px;">ğŸ  DomÅ¯</a>
    <a href="04.md" style="color:white; text-decoration:none; margin: 0 16px;">NÃ¡sledujÃ­cÃ­ â¡ï¸</a>
</nav>

# Implementace objektovÃ©ho software

> [!TIP]OtÃ¡zka
> Implementace vhodnÃ© struktury tÅ™Ã­dy a vazeb mezi tÅ™Ã­dami; vÃ½znam zapouzdÅ™enÃ­ pro zabezpeÄenÃ­ kÃ³du; dÄ›diÄnost, polymorfismus a jejich vÃ½znam pro rozÅ¡iÅ™itelnost kÃ³du; vyuÅ¾itÃ­ uvedenÃ½ch konceptÅ¯ v rÃ¡mci zÃ¡vÄ›reÄnÃ© prÃ¡ce

---

### ObjektovÃ½ software

ObjektovÃ½ software je program vytvoÅ™enÃ½ pomocÃ­ objektovÄ› orientovanÃ©ho programovacÃ­ho paradigmatu.
ObjektovÃ© paradigma je styl programovÃ¡nÃ­, kterÃ½ modeluje realitu pomocÃ­ prvkÅ¯ - **objektÅ¯**.
KaÅ¾dÃ½ objekt mÅ¯Å¾e mÃ­t vlastnosti (atributy) a mÅ¯Å¾e vykonÃ¡vat operace (metody).
OOP pÅ™edpoklÃ¡dÃ¡, Å¾e se celÃ½ svÄ›t sklÃ¡dÃ¡ z rÅ¯znÃ½ch objektÅ¯, kterÃ© na sebe navzÃ¡jem reagujÃ­.

CelÃ© OOP stojÃ­ na nÄ›kolika zÃ¡kladnÃ­ch konceptech

1. `Dekompozice`: rozdÄ›lenÃ­ sloÅ¾itÃ©ho problÃ©mu na menÅ¡Ã­ ÄÃ¡sti a jejich postupnÃ© Å™eÅ¡enÃ­
2. `Abstrakce`: ignorovÃ¡nÃ­ nedÅ¯leÅ¾itÃ½ch detailÅ¯ a vytvÃ¡Å™enÃ­ zjednoduÅ¡enÃ½ch modelÅ¯
3. `Hierarchie`: nalezenÃ­ hierarchickÃ½ch zÃ¡vislostÃ­ v systÃ©mu a urÄenÃ­ vazeb mezi ÄÃ¡stmi systÃ©mu

### TÅ™Ã­dy

TÅ™Ã­da je pÅ™edpis, pomocÃ­ kterÃ©ho se vytvÃ¡Å™ejÃ­ objekty.
Objekty lze takÃ© nazÃ½vat jako **instance tÅ™Ã­dy**.
TÅ™Ã­dy mÅ¯Å¾eme pÅ™irovnat k formÄ› na bÃ¡bovku: mÃ¡me jednu formu a pomocÃ­ nÃ­ mÅ¯Å¾eme vytvÃ¡Å™et spoustu bÃ¡bovek (ÄokolÃ¡dovou,
kakaovou, ...).
Forma je v tomto pÅ™Ã­padÄ› tedy tÅ™Ã­dou a konkrÃ©tnÃ­ bÃ¡bovka je objektem.

Pokud chceme v OOP vytvÃ¡Å™et objekty, musÃ­me nejprve pÅ™edepsat tÅ™Ã­du.
TÅ™Ã­da definuje vÃ½slednÃ½ tvar objektu: objekt bude mÃ­t stejnÃ© vlastnosti a metody jako tÅ™Ã­da.
**Vlastnosti** jsou vÅ¡echny promÄ›nnÃ©, kterÃ© se ke tÅ™Ã­dÄ› vztahujÃ­ (u tÅ™Ã­dy Person napÅ™ name, age, ...).
**Metody** jsou funkce, kterÃ© se nachÃ¡zejÃ­ uvnitÅ™ tÅ™Ã­dy (u tÅ™Ã­dy Person napÅ™. run(), sleep(), ...).

### Vazby

StejnÄ› jako mezi objekty reÃ¡lnÃ©ho svÄ›ta, takÃ© mezi objekty v programech existujÃ­ urÄitÃ© vztahy.
Vztahy jsou rÅ¯znÃ½ch typÅ¯.
Z programÃ¡torskÃ©ho hlediska se jednÃ¡ o interakci mezi objekty.
KaÅ¾dÃ¡ vazba obsahuje:

- popis
- nÃ¡sobnost
- typ
- orientaci

NÃ¡sobnosti vazeb mohou bÃ½t `1:1`, `1:N`, `N:1`, `M:N`.
ProblÃ©mem je vazba M:N, kterÃ¡ musÃ­ bÃ½t vÅ¾dy vyÅ™eÅ¡ena pomocÃ­ tÅ™etÃ­ tzv. asociaÄnÃ­ tÅ™Ã­dy.

Typy vazeb:

- `asociace` - jednorÃ¡zovÃ¡ vÃ½mÄ›na informacÃ­
- `agregace` - doÄasnÃ© provÃ¡zÃ¡nÃ­ objektÅ¯ (na nÄ›jakou chvÃ­li je jeden uloÅ¾en v druhÃ©m)
- `kompozice` - trvalÃ© provÃ¡zÃ¡nÃ­ (objekty spoleÄnÄ› vznikajÃ­ i zanikajÃ­)

### ZapouzdÅ™enÃ­

Objekty by mÄ›ly fungovat jako ÄernÃ© skÅ™Ã­Åˆky.
Pro jejich pouÅ¾itÃ­ by nemÄ›lo bÃ½t nutnÃ© chÃ¡pat jak vnitÅ™nÄ› fungujÃ­.
MÄ›lo by staÄit podÃ­vat se, jakÃ© operace mohu s tÅ™Ã­dou provÃ¡dÄ›t a zbytek by mÄ›l bÃ½t skryt.
To je princip zapouzdÅ™enÃ­.

Implementace zapouzdÅ™enÃ­ se provÃ¡dÃ­ pomocÃ­ **modifikÃ¡torÅ¯ viditelnosti**.
Ty Å™Ã­dÃ­ pÅ™Ã­stup a viditelnost metody nebo atributu.
V rÅ¯znÃ½ch jazycÃ­ch jsou implementovÃ¡ny rÅ¯znÃ© modifikÃ¡tory viditelnosti.
NejÄastÄ›ji se vÅ¡ak pouÅ¾Ã­vajÃ­ 4:

- `public` - veÅ™ejnÄ› viditelnÃ© odkudkoliv
- `protected` - viditelnÃ© pouze v potomcÃ­ch danÃ© tÅ™Ã­dy
- `package-private` - viditelnÃ© v rÃ¡mci stejnÃ©ho balÃ­Äku
- `private` - viditelnÃ© pouze v danÃ© tÅ™Ã­dÄ›

MnoÅ¾ina vÅ¡ech informacÃ­, kterÃ© o sobÄ› tÅ™Ã­da zveÅ™ejÅˆuje se nazÃ½vÃ¡ **rozhranÃ­** (interface).
Je to tedy soubor veÅ™ejnÃ½ch metod a atributÅ¯.
V nÄ›kterÃ½ch jazycÃ­ch (Java, Kotlin, C#, ...) je rozhranÃ­ extra struktura (asi na Ãºrovni tÅ™Ã­dy Äi vÃ½Ätu) a slouÅ¾Ã­ prÃ¡vÄ›
pro pÅ™edpis veÅ™ejnÃ½ch metod.
RozhranÃ­ pak mÅ¯Å¾e bÃ½t implementovÃ¡no konkrÃ©tnÃ­ tÅ™Ã­dou.

### DÄ›diÄnost

DÄ›diÄnost je dalÅ¡Ã­m z konceptÅ¯ OOP, kterÃ½ omezuje redundanci kÃ³du.
SlouÅ¾Ã­ ke tvoÅ™enÃ­ novÃ½ch tÅ™Ã­d na zÃ¡kladÄ› starÃ½ch â€“ pouÅ¾Ã­vÃ¡ se v pÅ™Ã­padÄ›, kde by tÅ™Ã­dy mÄ›ly spoleÄnÃ© vlastnosti nebo
metody.
UmoÅ¾Åˆuje od urÄitÃ© tÅ™Ã­dy oznaÄovanÃ© jako **pÅ™edek** odvozovat specializovanÃ© tÅ™Ã­dy â€“ **potomky**.
Potomek je specializovanÃ¡ verze pÅ™edka.
Potomek (subclass) pÅ™ebÃ­rÃ¡ od pÅ™edka (superclass) jeho vlastnosti a takÃ© metody.
Na mÃ­stech, kde je oÄekÃ¡vÃ¡na instance pÅ™edka, mÅ¯Å¾eme pouÅ¾Ã­t potomka.

Potomek dÄ›dÃ­ vÅ¡echny vlastnosti pÅ™edka.
I to, co bylo zapouzdÅ™eno jako private potomek mÃ¡, i kdyÅ¾ to nenÃ­ v jeho tÅ™Ã­dÄ› pÅ™Ã­mo dostupnÃ©.

### Polymorfismus

Objekty dvou tÅ™Ã­d mohou mÃ­t metodu se stejnÃ½m nÃ¡zvem, ale rozdÃ­lnou implementacÃ­.
Polymorfismus je vyuÅ¾Ã­vÃ¡n v souvislosti s pozdnÃ­ vazbou â€“ vytvoÅ™Ã­me si ukazatel na obecnÃ©ho pÅ™edka, dosazujeme rÅ¯znÃ©
potomky a volÃ¡me metody definovanÃ© ve spoleÄnÃ©m rozhranÃ­.
PÅ™i zavolÃ¡nÃ­ metody se dÃ­ky pozdnÃ­ vazbÄ› zavolÃ¡ metoda konkrÃ©tnÃ­ho potomka.